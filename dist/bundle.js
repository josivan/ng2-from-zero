(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){
/**
 * @license Angular v2.4.5
 * (c) 2010-2016 Google, Inc. https://angular.io/
 * License: MIT
 */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('rxjs/Subject'), require('rxjs/Observable')) :
    typeof define === 'function' && define.amd ? define(['exports', 'rxjs/Subject', 'rxjs/Observable'], factory) :
    (factory((global.ng = global.ng || {}, global.ng.core = global.ng.core || {}),global.Rx,global.Rx));
}(this, function (exports,rxjs_Subject,rxjs_Observable) { 'use strict';

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var /** @type {?} */ globalScope;
    if (typeof window === 'undefined') {
        if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
            // TODO: Replace any with WorkerGlobalScope from lib.webworker.d.ts #3492
            globalScope = (self);
        }
        else {
            globalScope = (global);
        }
    }
    else {
        globalScope = (window);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    function scheduleMicroTask(fn) {
        Zone.current.scheduleMicroTask('scheduleMicrotask', fn);
    }
    // Need to declare a new variable for global here since TypeScript
    // exports the original value of the symbol.
    var /** @type {?} */ global$1 = globalScope;
    /**
     * @param {?} type
     * @return {?}
     */
    function getTypeNameForDebugging(type) {
        return type['name'] || typeof type;
    }
    // TODO: remove calls to assert in production environment
    // Note: Can't just export this and import in in other files
    // as `assert` is a reserved keyword in Dart
    global$1.assert = function assert(condition) {
        // TODO: to be fixed properly via #2830, noop for now
    };
    /**
     * @param {?} obj
     * @return {?}
     */
    function isPresent(obj) {
        return obj != null;
    }
    /**
     * @param {?} obj
     * @return {?}
     */
    function isBlank(obj) {
        return obj == null;
    }
    /**
     * @param {?} token
     * @return {?}
     */
    function stringify(token) {
        if (typeof token === 'string') {
            return token;
        }
        if (token == null) {
            return '' + token;
        }
        if (token.overriddenName) {
            return "" + token.overriddenName;
        }
        if (token.name) {
            return "" + token.name;
        }
        var /** @type {?} */ res = token.toString();
        var /** @type {?} */ newLineIndex = res.indexOf('\n');
        return newLineIndex === -1 ? res : res.substring(0, newLineIndex);
    }
    /**
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    function looseIdentical(a, b) {
        return a === b || typeof a === 'number' && typeof b === 'number' && isNaN(a) && isNaN(b);
    }
    /**
     * @param {?} o
     * @return {?}
     */
    function isJsObject(o) {
        return o !== null && (typeof o === 'function' || typeof o === 'object');
    }
    /**
     * @param {?} obj
     * @return {?}
     */
    function print(obj) {
        // tslint:disable-next-line:no-console
        console.log(obj);
    }
    /**
     * @param {?} obj
     * @return {?}
     */
    function warn(obj) {
        console.warn(obj);
    }
    var /** @type {?} */ _symbolIterator = null;
    /**
     * @return {?}
     */
    function getSymbolIterator() {
        if (!_symbolIterator) {
            if (((globalScope)).Symbol && Symbol.iterator) {
                _symbolIterator = Symbol.iterator;
            }
            else {
                // es6-shim specific logic
                var /** @type {?} */ keys = Object.getOwnPropertyNames(Map.prototype);
                for (var /** @type {?} */ i = 0; i < keys.length; ++i) {
                    var /** @type {?} */ key = keys[i];
                    if (key !== 'entries' && key !== 'size' &&
                        ((Map)).prototype[key] === Map.prototype['entries']) {
                        _symbolIterator = key;
                    }
                }
            }
        }
        return _symbolIterator;
    }
    /**
     * @param {?} obj
     * @return {?}
     */
    function isPrimitive(obj) {
        return !isJsObject(obj);
    }

    var /** @type {?} */ _nextClassId = 0;
    var /** @type {?} */ Reflect = global$1.Reflect;
    /**
     * @param {?} annotation
     * @return {?}
     */
    function extractAnnotation(annotation) {
        if (typeof annotation === 'function' && annotation.hasOwnProperty('annotation')) {
            // it is a decorator, extract annotation
            annotation = annotation.annotation;
        }
        return annotation;
    }
    /**
     * @param {?} fnOrArray
     * @param {?} key
     * @return {?}
     */
    function applyParams(fnOrArray, key) {
        if (fnOrArray === Object || fnOrArray === String || fnOrArray === Function ||
            fnOrArray === Number || fnOrArray === Array) {
            throw new Error("Can not use native " + stringify(fnOrArray) + " as constructor");
        }
        if (typeof fnOrArray === 'function') {
            return fnOrArray;
        }
        if (Array.isArray(fnOrArray)) {
            var /** @type {?} */ annotations = fnOrArray;
            var /** @type {?} */ annoLength = annotations.length - 1;
            var /** @type {?} */ fn = fnOrArray[annoLength];
            if (typeof fn !== 'function') {
                throw new Error("Last position of Class method array must be Function in key " + key + " was '" + stringify(fn) + "'");
            }
            if (annoLength != fn.length) {
                throw new Error("Number of annotations (" + annoLength + ") does not match number of arguments (" + fn.length + ") in the function: " + stringify(fn));
            }
            var /** @type {?} */ paramsAnnotations = [];
            for (var /** @type {?} */ i = 0, /** @type {?} */ ii = annotations.length - 1; i < ii; i++) {
                var /** @type {?} */ paramAnnotations = [];
                paramsAnnotations.push(paramAnnotations);
                var /** @type {?} */ annotation = annotations[i];
                if (Array.isArray(annotation)) {
                    for (var /** @type {?} */ j = 0; j < annotation.length; j++) {
                        paramAnnotations.push(extractAnnotation(annotation[j]));
                    }
                }
                else if (typeof annotation === 'function') {
                    paramAnnotations.push(extractAnnotation(annotation));
                }
                else {
                    paramAnnotations.push(annotation);
                }
            }
            Reflect.defineMetadata('parameters', paramsAnnotations, fn);
            return fn;
        }
        throw new Error("Only Function or Array is supported in Class definition for key '" + key + "' is '" + stringify(fnOrArray) + "'");
    }
    /**
     * Provides a way for expressing ES6 classes with parameter annotations in ES5.
     *
     * ## Basic Example
     *
     * ```
     * var Greeter = ng.Class({
     *   constructor: function(name) {
     *     this.name = name;
     *   },
     *
     *   greet: function() {
     *     alert('Hello ' + this.name + '!');
     *   }
     * });
     * ```
     *
     * is equivalent to ES6:
     *
     * ```
     * class Greeter {
     *   constructor(name) {
     *     this.name = name;
     *   }
     *
     *   greet() {
     *     alert('Hello ' + this.name + '!');
     *   }
     * }
     * ```
     *
     * or equivalent to ES5:
     *
     * ```
     * var Greeter = function (name) {
     *   this.name = name;
     * }
     *
     * Greeter.prototype.greet = function () {
     *   alert('Hello ' + this.name + '!');
     * }
     * ```
     *
     * ### Example with parameter annotations
     *
     * ```
     * var MyService = ng.Class({
     *   constructor: [String, [new Optional(), Service], function(name, myService) {
     *     ...
     *   }]
     * });
     * ```
     *
     * is equivalent to ES6:
     *
     * ```
     * class MyService {
     *   constructor(name: string, \@Optional() myService: Service) {
     *     ...
     *   }
     * }
     * ```
     *
     * ### Example with inheritance
     *
     * ```
     * var Shape = ng.Class({
     *   constructor: (color) {
     *     this.color = color;
     *   }
     * });
     *
     * var Square = ng.Class({
     *   extends: Shape,
     *   constructor: function(color, size) {
     *     Shape.call(this, color);
     *     this.size = size;
     *   }
     * });
     * ```
     * \@stable
     * @param {?} clsDef
     * @return {?}
     */
    function Class(clsDef) {
        var /** @type {?} */ constructor = applyParams(clsDef.hasOwnProperty('constructor') ? clsDef.constructor : undefined, 'constructor');
        var /** @type {?} */ proto = constructor.prototype;
        if (clsDef.hasOwnProperty('extends')) {
            if (typeof clsDef.extends === 'function') {
                ((constructor)).prototype = proto =
                    Object.create(((clsDef.extends)).prototype);
            }
            else {
                throw new Error("Class definition 'extends' property must be a constructor function was: " + stringify(clsDef.extends));
            }
        }
        for (var key in clsDef) {
            if (key !== 'extends' && key !== 'prototype' && clsDef.hasOwnProperty(key)) {
                proto[key] = applyParams(clsDef[key], key);
            }
        }
        if (this && this.annotations instanceof Array) {
            Reflect.defineMetadata('annotations', this.annotations, constructor);
        }
        var /** @type {?} */ constructorName = constructor['name'];
        if (!constructorName || constructorName === 'constructor') {
            ((constructor))['overriddenName'] = "class" + _nextClassId++;
        }
        return (constructor);
    }
    /**
     * @param {?} name
     * @param {?} props
     * @param {?=} parentClass
     * @param {?=} chainFn
     * @return {?}
     */
    function makeDecorator(name, props, parentClass, chainFn) {
        if (chainFn === void 0) { chainFn = null; }
        var /** @type {?} */ metaCtor = makeMetadataCtor([props]);
        /**
         * @param {?} objOrType
         * @return {?}
         */
        function DecoratorFactory(objOrType) {
            if (!(Reflect && Reflect.getOwnMetadata)) {
                throw 'reflect-metadata shim is required when using class decorators';
            }
            if (this instanceof DecoratorFactory) {
                metaCtor.call(this, objOrType);
                return this;
            }
            var /** @type {?} */ annotationInstance = new ((DecoratorFactory))(objOrType);
            var /** @type {?} */ chainAnnotation = typeof this === 'function' && Array.isArray(this.annotations) ? this.annotations : [];
            chainAnnotation.push(annotationInstance);
            var /** @type {?} */ TypeDecorator = (function TypeDecorator(cls) {
                var /** @type {?} */ annotations = Reflect.getOwnMetadata('annotations', cls) || [];
                annotations.push(annotationInstance);
                Reflect.defineMetadata('annotations', annotations, cls);
                return cls;
            });
            TypeDecorator.annotations = chainAnnotation;
            TypeDecorator.Class = Class;
            if (chainFn)
                chainFn(TypeDecorator);
            return TypeDecorator;
        }
        if (parentClass) {
            DecoratorFactory.prototype = Object.create(parentClass.prototype);
        }
        DecoratorFactory.prototype.toString = function () { return ("@" + name); };
        ((DecoratorFactory)).annotationCls = DecoratorFactory;
        return DecoratorFactory;
    }
    /**
     * @param {?} props
     * @return {?}
     */
    function makeMetadataCtor(props) {
        return function ctor() {
            var _this = this;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            props.forEach(function (prop, i) {
                var /** @type {?} */ argVal = args[i];
                if (Array.isArray(prop)) {
                    // plain parameter
                    _this[prop[0]] = argVal === undefined ? prop[1] : argVal;
                }
                else {
                    for (var propName in prop) {
                        _this[propName] =
                            argVal && argVal.hasOwnProperty(propName) ? argVal[propName] : prop[propName];
                    }
                }
            });
        };
    }
    /**
     * @param {?} name
     * @param {?} props
     * @param {?=} parentClass
     * @return {?}
     */
    function makeParamDecorator(name, props, parentClass) {
        var /** @type {?} */ metaCtor = makeMetadataCtor(props);
        /**
         * @param {...?} args
         * @return {?}
         */
        function ParamDecoratorFactory() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            if (this instanceof ParamDecoratorFactory) {
                metaCtor.apply(this, args);
                return this;
            }
            var /** @type {?} */ annotationInstance = new ((_a = ((ParamDecoratorFactory))).bind.apply(_a, [void 0].concat(args)))();
            ((ParamDecorator)).annotation = annotationInstance;
            return ParamDecorator;
            /**
             * @param {?} cls
             * @param {?} unusedKey
             * @param {?} index
             * @return {?}
             */
            function ParamDecorator(cls, unusedKey, index) {
                var /** @type {?} */ parameters = Reflect.getOwnMetadata('parameters', cls) || [];
                // there might be gaps if some in between parameters do not have annotations.
                // we pad with nulls.
                while (parameters.length <= index) {
                    parameters.push(null);
                }
                parameters[index] = parameters[index] || [];
                parameters[index].push(annotationInstance);
                Reflect.defineMetadata('parameters', parameters, cls);
                return cls;
            }
            var _a;
        }
        if (parentClass) {
            ParamDecoratorFactory.prototype = Object.create(parentClass.prototype);
        }
        ParamDecoratorFactory.prototype.toString = function () { return ("@" + name); };
        ((ParamDecoratorFactory)).annotationCls = ParamDecoratorFactory;
        return ParamDecoratorFactory;
    }
    /**
     * @param {?} name
     * @param {?} props
     * @param {?=} parentClass
     * @return {?}
     */
    function makePropDecorator(name, props, parentClass) {
        var /** @type {?} */ metaCtor = makeMetadataCtor(props);
        /**
         * @param {...?} args
         * @return {?}
         */
        function PropDecoratorFactory() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            if (this instanceof PropDecoratorFactory) {
                metaCtor.apply(this, args);
                return this;
            }
            var /** @type {?} */ decoratorInstance = new ((_a = ((PropDecoratorFactory))).bind.apply(_a, [void 0].concat(args)))();
            return function PropDecorator(target, name) {
                var /** @type {?} */ meta = Reflect.getOwnMetadata('propMetadata', target.constructor) || {};
                meta[name] = meta.hasOwnProperty(name) && meta[name] || [];
                meta[name].unshift(decoratorInstance);
                Reflect.defineMetadata('propMetadata', meta, target.constructor);
            };
            var _a;
        }
        if (parentClass) {
            PropDecoratorFactory.prototype = Object.create(parentClass.prototype);
        }
        PropDecoratorFactory.prototype.toString = function () { return ("@" + name); };
        ((PropDecoratorFactory)).annotationCls = PropDecoratorFactory;
        return PropDecoratorFactory;
    }

    /**
     * Inject decorator and metadata.
     *
     * @stable
     * @Annotation
     */
    var /** @type {?} */ Inject = makeParamDecorator('Inject', [['token', undefined]]);
    /**
     * Optional decorator and metadata.
     *
     * @stable
     * @Annotation
     */
    var /** @type {?} */ Optional = makeParamDecorator('Optional', []);
    /**
     * Injectable decorator and metadata.
     *
     * @stable
     * @Annotation
     */
    var /** @type {?} */ Injectable = (makeDecorator('Injectable', []));
    /**
     * Self decorator and metadata.
     *
     * @stable
     * @Annotation
     */
    var /** @type {?} */ Self = makeParamDecorator('Self', []);
    /**
     * SkipSelf decorator and metadata.
     *
     * @stable
     * @Annotation
     */
    var /** @type {?} */ SkipSelf = makeParamDecorator('SkipSelf', []);
    /**
     * Host decorator and metadata.
     *
     * @stable
     * @Annotation
     */
    var /** @type {?} */ Host = makeParamDecorator('Host', []);

    var OpaqueToken = (function () {
        /**
         * @param {?} _desc
         */
        function OpaqueToken(_desc) {
            this._desc = _desc;
        }
        /**
         * @return {?}
         */
        OpaqueToken.prototype.toString = function () { return "Token " + this._desc; };
        OpaqueToken.decorators = [
            { type: Injectable },
        ];
        /** @nocollapse */
        OpaqueToken.ctorParameters = function () { return [
            null,
        ]; };
        return OpaqueToken;
    }());

    /**
     * This token can be used to create a virtual provider that will populate the
     * `entryComponents` fields of components and ng modules based on its `useValue`.
     * All components that are referenced in the `useValue` value (either directly
     * or in a nested array or map) will be added to the `entryComponents` property.
     *
     * ### Example
     * The following example shows how the router can populate the `entryComponents`
     * field of an NgModule based on the router configuration which refers
     * to components.
     *
     * ```typescript
     * // helper function inside the router
     * function provideRoutes(routes) {
     *   return [
     *     {provide: ROUTES, useValue: routes},
     *     {provide: ANALYZE_FOR_ENTRY_COMPONENTS, useValue: routes, multi: true}
     *   ];
     * }
     *
     * // user code
     * let routes = [
     *   {path: '/root', component: RootComp},
     *   {path: '/teams', component: TeamsComp}
     * ];
     *
     * @NgModule({
     *   providers: [provideRoutes(routes)]
     * })
     * class ModuleWithRoutes {}
     * ```
     *
     * @experimental
     */
    var /** @type {?} */ ANALYZE_FOR_ENTRY_COMPONENTS = new OpaqueToken('AnalyzeForEntryComponents');
    /**
     * Attribute decorator and metadata.
     *
     * @stable
     * @Annotation
     */
    var /** @type {?} */ Attribute = makeParamDecorator('Attribute', [['attributeName', undefined]]);
    /**
     * Base class for query metadata.
     *
     * See {\@link ContentChildren}, {\@link ContentChild}, {\@link ViewChildren}, {\@link ViewChild} for
     * more information.
     *
     * \@stable
     * @abstract
     */
    var Query = (function () {
        function Query() {
        }
        return Query;
    }());
    /**
     * ContentChildren decorator and metadata.
     *
     *  @stable
     *  @Annotation
     */
    var /** @type {?} */ ContentChildren = (makePropDecorator('ContentChildren', [
        ['selector', undefined], {
            first: false,
            isViewQuery: false,
            descendants: false,
            read: undefined,
        }
    ], Query));
    /**
     * ContentChild decorator and metadata.
     *
     * @stable
     * @Annotation
     */
    var /** @type {?} */ ContentChild = makePropDecorator('ContentChild', [
        ['selector', undefined], {
            first: true,
            isViewQuery: false,
            descendants: true,
            read: undefined,
        }
    ], Query);
    /**
     * ViewChildren decorator and metadata.
     *
     * @stable
     * @Annotation
     */
    var /** @type {?} */ ViewChildren = makePropDecorator('ViewChildren', [
        ['selector', undefined], {
            first: false,
            isViewQuery: true,
            descendants: true,
            read: undefined,
        }
    ], Query);
    /**
     * ViewChild decorator and metadata.
     *
     * @stable
     * @Annotation
     */
    var /** @type {?} */ ViewChild = makePropDecorator('ViewChild', [
        ['selector', undefined], {
            first: true,
            isViewQuery: true,
            descendants: true,
            read: undefined,
        }
    ], Query);

    var ChangeDetectionStrategy = {};
    ChangeDetectionStrategy.OnPush = 0;
    ChangeDetectionStrategy.Default = 1;
    ChangeDetectionStrategy[ChangeDetectionStrategy.OnPush] = "OnPush";
    ChangeDetectionStrategy[ChangeDetectionStrategy.Default] = "Default";
    var ChangeDetectorStatus = {};
    ChangeDetectorStatus.CheckOnce = 0;
    ChangeDetectorStatus.Checked = 1;
    ChangeDetectorStatus.CheckAlways = 2;
    ChangeDetectorStatus.Detached = 3;
    ChangeDetectorStatus.Errored = 4;
    ChangeDetectorStatus.Destroyed = 5;
    ChangeDetectorStatus[ChangeDetectorStatus.CheckOnce] = "CheckOnce";
    ChangeDetectorStatus[ChangeDetectorStatus.Checked] = "Checked";
    ChangeDetectorStatus[ChangeDetectorStatus.CheckAlways] = "CheckAlways";
    ChangeDetectorStatus[ChangeDetectorStatus.Detached] = "Detached";
    ChangeDetectorStatus[ChangeDetectorStatus.Errored] = "Errored";
    ChangeDetectorStatus[ChangeDetectorStatus.Destroyed] = "Destroyed";
    /**
     * @param {?} changeDetectionStrategy
     * @return {?}
     */
    function isDefaultChangeDetectionStrategy(changeDetectionStrategy) {
        return isBlank(changeDetectionStrategy) ||
            changeDetectionStrategy === ChangeDetectionStrategy.Default;
    }

    /**
     * Directive decorator and metadata.
     *
     * @stable
     * @Annotation
     */
    var /** @type {?} */ Directive = (makeDecorator('Directive', {
        selector: undefined,
        inputs: undefined,
        outputs: undefined,
        host: undefined,
        providers: undefined,
        exportAs: undefined,
        queries: undefined
    }));
    /**
     * Component decorator and metadata.
     *
     * @stable
     * @Annotation
     */
    var /** @type {?} */ Component = (makeDecorator('Component', {
        selector: undefined,
        inputs: undefined,
        outputs: undefined,
        host: undefined,
        exportAs: undefined,
        moduleId: undefined,
        providers: undefined,
        viewProviders: undefined,
        changeDetection: ChangeDetectionStrategy.Default,
        queries: undefined,
        templateUrl: undefined,
        template: undefined,
        styleUrls: undefined,
        styles: undefined,
        animations: undefined,
        encapsulation: undefined,
        interpolation: undefined,
        entryComponents: undefined
    }, Directive));
    /**
     * Pipe decorator and metadata.
     *
     * @stable
     * @Annotation
     */
    var /** @type {?} */ Pipe = (makeDecorator('Pipe', {
        name: undefined,
        pure: true,
    }));
    /**
     * Input decorator and metadata.
     *
     * @stable
     * @Annotation
     */
    var /** @type {?} */ Input = makePropDecorator('Input', [['bindingPropertyName', undefined]]);
    /**
     * Output decorator and metadata.
     *
     * @stable
     * @Annotation
     */
    var /** @type {?} */ Output = makePropDecorator('Output', [['bindingPropertyName', undefined]]);
    /**
     * HostBinding decorator and metadata.
     *
     * @stable
     * @Annotation
     */
    var /** @type {?} */ HostBinding = makePropDecorator('HostBinding', [['hostPropertyName', undefined]]);
    /**
     * HostListener decorator and metadata.
     *
     * @stable
     * @Annotation
     */
    var /** @type {?} */ HostListener = makePropDecorator('HostListener', [['eventName', undefined], ['args', []]]);

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var LifecycleHooks = {};
    LifecycleHooks.OnInit = 0;
    LifecycleHooks.OnDestroy = 1;
    LifecycleHooks.DoCheck = 2;
    LifecycleHooks.OnChanges = 3;
    LifecycleHooks.AfterContentInit = 4;
    LifecycleHooks.AfterContentChecked = 5;
    LifecycleHooks.AfterViewInit = 6;
    LifecycleHooks.AfterViewChecked = 7;
    LifecycleHooks[LifecycleHooks.OnInit] = "OnInit";
    LifecycleHooks[LifecycleHooks.OnDestroy] = "OnDestroy";
    LifecycleHooks[LifecycleHooks.DoCheck] = "DoCheck";
    LifecycleHooks[LifecycleHooks.OnChanges] = "OnChanges";
    LifecycleHooks[LifecycleHooks.AfterContentInit] = "AfterContentInit";
    LifecycleHooks[LifecycleHooks.AfterContentChecked] = "AfterContentChecked";
    LifecycleHooks[LifecycleHooks.AfterViewInit] = "AfterViewInit";
    LifecycleHooks[LifecycleHooks.AfterViewChecked] = "AfterViewChecked";
    var /** @type {?} */ LIFECYCLE_HOOKS_VALUES = [
        LifecycleHooks.OnInit, LifecycleHooks.OnDestroy, LifecycleHooks.DoCheck, LifecycleHooks.OnChanges,
        LifecycleHooks.AfterContentInit, LifecycleHooks.AfterContentChecked, LifecycleHooks.AfterViewInit,
        LifecycleHooks.AfterViewChecked
    ];
    /**
     * \@whatItDoes Lifecycle hook that is called when any data-bound property of a directive changes.
     * \@howToUse
     * {\@example core/ts/metadata/lifecycle_hooks_spec.ts region='OnChanges'}
     *
     * \@description
     * `ngOnChanges` is called right after the data-bound properties have been checked and before view
     * and content children are checked if at least one of them has changed.
     * The `changes` parameter contains the changed properties.
     *
     * See {\@linkDocs guide/lifecycle-hooks#onchanges "Lifecycle Hooks Guide"}.
     *
     * \@stable
     * @abstract
     */
    var OnChanges = (function () {
        function OnChanges() {
        }
        /**
         * @abstract
         * @param {?} changes
         * @return {?}
         */
        OnChanges.prototype.ngOnChanges = function (changes) { };
        return OnChanges;
    }());
    /**
     * \@whatItDoes Lifecycle hook that is called after data-bound properties of a directive are
     * initialized.
     * \@howToUse
     * {\@example core/ts/metadata/lifecycle_hooks_spec.ts region='OnInit'}
     *
     * \@description
     * `ngOnInit` is called right after the directive's data-bound properties have been checked for the
     * first time, and before any of its children have been checked. It is invoked only once when the
     * directive is instantiated.
     *
     * See {\@linkDocs guide/lifecycle-hooks "Lifecycle Hooks Guide"}.
     *
     * \@stable
     * @abstract
     */
    var OnInit = (function () {
        function OnInit() {
        }
        /**
         * @abstract
         * @return {?}
         */
        OnInit.prototype.ngOnInit = function () { };
        return OnInit;
    }());
    /**
     * \@whatItDoes Lifecycle hook that is called when Angular dirty checks a directive.
     * \@howToUse
     * {\@example core/ts/metadata/lifecycle_hooks_spec.ts region='DoCheck'}
     *
     * \@description
     * `ngDoCheck` gets called to check the changes in the directives in addition to the default
     * algorithm. The default change detection algorithm looks for differences by comparing
     * bound-property values by reference across change detection runs.
     *
     * Note that a directive typically should not use both `DoCheck` and {\@link OnChanges} to respond to
     * changes on the same input, as `ngOnChanges` will continue to be called when the default change
     * detector detects changes.
     *
     * See {\@link KeyValueDiffers} and {\@link IterableDiffers} for implementing custom dirty checking
     * for collections.
     *
     * See {\@linkDocs guide/lifecycle-hooks#docheck "Lifecycle Hooks Guide"}.
     *
     * \@stable
     * @abstract
     */
    var DoCheck = (function () {
        function DoCheck() {
        }
        /**
         * @abstract
         * @return {?}
         */
        DoCheck.prototype.ngDoCheck = function () { };
        return DoCheck;
    }());
    /**
     * \@whatItDoes Lifecycle hook that is called when a directive, pipe or service is destroyed.
     * \@howToUse
     * {\@example core/ts/metadata/lifecycle_hooks_spec.ts region='OnDestroy'}
     *
     * \@description
     * `ngOnDestroy` callback is typically used for any custom cleanup that needs to occur when the
     * instance is destroyed.
     *
     * See {\@linkDocs guide/lifecycle-hooks "Lifecycle Hooks Guide"}.
     *
     * \@stable
     * @abstract
     */
    var OnDestroy = (function () {
        function OnDestroy() {
        }
        /**
         * @abstract
         * @return {?}
         */
        OnDestroy.prototype.ngOnDestroy = function () { };
        return OnDestroy;
    }());
    /**
     *
     * \@whatItDoes Lifecycle hook that is called after a directive's content has been fully
     * initialized.
     * \@howToUse
     * {\@example core/ts/metadata/lifecycle_hooks_spec.ts region='AfterContentInit'}
     *
     * \@description
     * See {\@linkDocs guide/lifecycle-hooks#aftercontent "Lifecycle Hooks Guide"}.
     *
     * \@stable
     * @abstract
     */
    var AfterContentInit = (function () {
        function AfterContentInit() {
        }
        /**
         * @abstract
         * @return {?}
         */
        AfterContentInit.prototype.ngAfterContentInit = function () { };
        return AfterContentInit;
    }());
    /**
     * \@whatItDoes Lifecycle hook that is called after every check of a directive's content.
     * \@howToUse
     * {\@example core/ts/metadata/lifecycle_hooks_spec.ts region='AfterContentChecked'}
     *
     * \@description
     * See {\@linkDocs guide/lifecycle-hooks#aftercontent "Lifecycle Hooks Guide"}.
     *
     * \@stable
     * @abstract
     */
    var AfterContentChecked = (function () {
        function AfterContentChecked() {
        }
        /**
         * @abstract
         * @return {?}
         */
        AfterContentChecked.prototype.ngAfterContentChecked = function () { };
        return AfterContentChecked;
    }());
    /**
     * \@whatItDoes Lifecycle hook that is called after a component's view has been fully
     * initialized.
     * \@howToUse
     * {\@example core/ts/metadata/lifecycle_hooks_spec.ts region='AfterViewInit'}
     *
     * \@description
     * See {\@linkDocs guide/lifecycle-hooks#afterview "Lifecycle Hooks Guide"}.
     *
     * \@stable
     * @abstract
     */
    var AfterViewInit = (function () {
        function AfterViewInit() {
        }
        /**
         * @abstract
         * @return {?}
         */
        AfterViewInit.prototype.ngAfterViewInit = function () { };
        return AfterViewInit;
    }());
    /**
     * \@whatItDoes Lifecycle hook that is called after every check of a component's view.
     * \@howToUse
     * {\@example core/ts/metadata/lifecycle_hooks_spec.ts region='AfterViewChecked'}
     *
     * \@description
     * See {\@linkDocs guide/lifecycle-hooks#afterview "Lifecycle Hooks Guide"}.
     *
     * \@stable
     * @abstract
     */
    var AfterViewChecked = (function () {
        function AfterViewChecked() {
        }
        /**
         * @abstract
         * @return {?}
         */
        AfterViewChecked.prototype.ngAfterViewChecked = function () { };
        return AfterViewChecked;
    }());

    /**
     * Defines a schema that will allow:
     * - any non-Angular elements with a `-` in their name,
     * - any properties on elements with a `-` in their name which is the common rule for custom
     * elements.
     *
     * @stable
     */
    var /** @type {?} */ CUSTOM_ELEMENTS_SCHEMA = {
        name: 'custom-elements'
    };
    /**
     * Defines a schema that will allow any property on any element.
     *
     * @experimental
     */
    var /** @type {?} */ NO_ERRORS_SCHEMA = {
        name: 'no-errors-schema'
    };
    /**
     * NgModule decorator and metadata.
     *
     * @stable
     * @Annotation
     */
    var /** @type {?} */ NgModule = (makeDecorator('NgModule', {
        providers: undefined,
        declarations: undefined,
        imports: undefined,
        exports: undefined,
        entryComponents: undefined,
        bootstrap: undefined,
        schemas: undefined,
        id: undefined,
    }));

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var ViewEncapsulation = {};
    ViewEncapsulation.Emulated = 0;
    ViewEncapsulation.Native = 1;
    ViewEncapsulation.None = 2;
    ViewEncapsulation[ViewEncapsulation.Emulated] = "Emulated";
    ViewEncapsulation[ViewEncapsulation.Native] = "Native";
    ViewEncapsulation[ViewEncapsulation.None] = "None";
    /**
     * Metadata properties available for configuring Views.
     *
     * For details on the `\@Component` annotation, see {\@link Component}.
     *
     * ### Example
     *
     * ```
     * \@Component({
     *   selector: 'greet',
     *   template: 'Hello {{name}}!',
     * })
     * class Greet {
     *   name: string;
     *
     *   constructor() {
     *     this.name = 'World';
     *   }
     * }
     * ```
     *
     * @deprecated Use Component instead.
     *
     * {\@link Component}
     */
    var ViewMetadata = (function () {
        /**
         * @param {?=} __0
         */
        function ViewMetadata(_a) {
            var _b = _a === void 0 ? {} : _a, templateUrl = _b.templateUrl, template = _b.template, encapsulation = _b.encapsulation, styles = _b.styles, styleUrls = _b.styleUrls, animations = _b.animations, interpolation = _b.interpolation;
            this.templateUrl = templateUrl;
            this.template = template;
            this.styleUrls = styleUrls;
            this.styles = styles;
            this.encapsulation = encapsulation;
            this.animations = animations;
            this.interpolation = interpolation;
        }
        return ViewMetadata;
    }());

    /**
     * \@whatItDoes Represents the version of Angular
     *
     * \@stable
     */
    var Version = (function () {
        /**
         * @param {?} full
         */
        function Version(full) {
            this.full = full;
        }
        Object.defineProperty(Version.prototype, "major", {
            /**
             * @return {?}
             */
            get: function () { return this.full.split('.')[0]; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Version.prototype, "minor", {
            /**
             * @return {?}
             */
            get: function () { return this.full.split('.')[1]; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Version.prototype, "patch", {
            /**
             * @return {?}
             */
            get: function () { return this.full.split('.').slice(2).join('.'); },
            enumerable: true,
            configurable: true
        });
        return Version;
    }());
    /**
     * @stable
     */
    var /** @type {?} */ VERSION = new Version('2.4.5');

    /**
     * Allows to refer to references which are not yet defined.
     *
     * For instance, `forwardRef` is used when the `token` which we need to refer to for the purposes of
     * DI is declared,
     * but not yet defined. It is also used when the `token` which we use when creating a query is not
     * yet defined.
     *
     * ### Example
     * {\@example core/di/ts/forward_ref/forward_ref_spec.ts region='forward_ref'}
     * \@experimental
     * @param {?} forwardRefFn
     * @return {?}
     */
    function forwardRef(forwardRefFn) {
        ((forwardRefFn)).__forward_ref__ = forwardRef;
        ((forwardRefFn)).toString = function () { return stringify(this()); };
        return (((forwardRefFn)));
    }
    /**
     * Lazily retrieves the reference value from a forwardRef.
     *
     * Acts as the identity function when given a non-forward-ref value.
     *
     * ### Example ([live demo](http://plnkr.co/edit/GU72mJrk1fiodChcmiDR?p=preview))
     *
     * {\@example core/di/ts/forward_ref/forward_ref_spec.ts region='resolve_forward_ref'}
     *
     * See: {\@link forwardRef}
     * \@experimental
     * @param {?} type
     * @return {?}
     */
    function resolveForwardRef(type) {
        if (typeof type === 'function' && type.hasOwnProperty('__forward_ref__') &&
            type.__forward_ref__ === forwardRef) {
            return ((type))();
        }
        else {
            return type;
        }
    }

    var __extends = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * Convenience to throw an Error with 'unimplemented' as the message.
     * @return {?}
     */
    function unimplemented() {
        throw new Error('unimplemented');
    }
    /**
     * \@stable
     */
    var BaseError = (function (_super) {
        __extends(BaseError, _super);
        /**
         * @param {?} message
         */
        function BaseError(message) {
            _super.call(this, message);
            // Errors don't use current this, instead they create a new instance.
            // We have to do forward all of our api to the nativeInstance.
            // TODO(bradfordcsmith): Remove this hack when
            //     google/closure-compiler/issues/2102 is fixed.
            var nativeError = new Error(message);
            this._nativeError = nativeError;
        }
        Object.defineProperty(BaseError.prototype, "message", {
            /**
             * @return {?}
             */
            get: function () { return this._nativeError.message; },
            /**
             * @param {?} message
             * @return {?}
             */
            set: function (message) { this._nativeError.message = message; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseError.prototype, "name", {
            /**
             * @return {?}
             */
            get: function () { return this._nativeError.name; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseError.prototype, "stack", {
            /**
             * @return {?}
             */
            get: function () { return ((this._nativeError)).stack; },
            /**
             * @param {?} value
             * @return {?}
             */
            set: function (value) { ((this._nativeError)).stack = value; },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        BaseError.prototype.toString = function () { return this._nativeError.toString(); };
        return BaseError;
    }(Error));
    /**
     * \@stable
     */
    var WrappedError = (function (_super) {
        __extends(WrappedError, _super);
        /**
         * @param {?} message
         * @param {?} error
         */
        function WrappedError(message, error) {
            _super.call(this, message + " caused by: " + (error instanceof Error ? error.message : error));
            this.originalError = error;
        }
        Object.defineProperty(WrappedError.prototype, "stack", {
            /**
             * @return {?}
             */
            get: function () {
                return (((this.originalError instanceof Error ? this.originalError : this._nativeError)))
                    .stack;
            },
            enumerable: true,
            configurable: true
        });
        return WrappedError;
    }(BaseError));

    var /** @type {?} */ _THROW_IF_NOT_FOUND = new Object();
    var /** @type {?} */ THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;
    var _NullInjector = (function () {
        function _NullInjector() {
        }
        /**
         * @param {?} token
         * @param {?=} notFoundValue
         * @return {?}
         */
        _NullInjector.prototype.get = function (token, notFoundValue) {
            if (notFoundValue === void 0) { notFoundValue = _THROW_IF_NOT_FOUND; }
            if (notFoundValue === _THROW_IF_NOT_FOUND) {
                throw new Error("No provider for " + stringify(token) + "!");
            }
            return notFoundValue;
        };
        return _NullInjector;
    }());
    /**
     * \@whatItDoes Injector interface
     * \@howToUse
     * ```
     * const injector: Injector = ...;
     * injector.get(...);
     * ```
     *
     * \@description
     * For more details, see the {\@linkDocs guide/dependency-injection "Dependency Injection Guide"}.
     *
     * ### Example
     *
     * {\@example core/di/ts/injector_spec.ts region='Injector'}
     *
     * `Injector` returns itself when given `Injector` as a token:
     * {\@example core/di/ts/injector_spec.ts region='injectInjector'}
     *
     * \@stable
     * @abstract
     */
    var Injector = (function () {
        function Injector() {
        }
        /**
         * Retrieves an instance from the injector based on the provided token.
         * If not found:
         * - Throws {\@link NoProviderError} if no `notFoundValue` that is not equal to
         * Injector.THROW_IF_NOT_FOUND is given
         * - Returns the `notFoundValue` otherwise
         * @param {?} token
         * @param {?=} notFoundValue
         * @return {?}
         */
        Injector.prototype.get = function (token, notFoundValue) { return unimplemented(); };
        Injector.THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;
        Injector.NULL = new _NullInjector();
        return Injector;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$1 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * @param {?} keys
     * @return {?}
     */
    function findFirstClosedCycle(keys) {
        var /** @type {?} */ res = [];
        for (var /** @type {?} */ i = 0; i < keys.length; ++i) {
            if (res.indexOf(keys[i]) > -1) {
                res.push(keys[i]);
                return res;
            }
            res.push(keys[i]);
        }
        return res;
    }
    /**
     * @param {?} keys
     * @return {?}
     */
    function constructResolvingPath(keys) {
        if (keys.length > 1) {
            var /** @type {?} */ reversed = findFirstClosedCycle(keys.slice().reverse());
            var /** @type {?} */ tokenStrs = reversed.map(function (k) { return stringify(k.token); });
            return ' (' + tokenStrs.join(' -> ') + ')';
        }
        return '';
    }
    /**
     * Base class for all errors arising from misconfigured providers.
     * \@stable
     */
    var AbstractProviderError = (function (_super) {
        __extends$1(AbstractProviderError, _super);
        /**
         * @param {?} injector
         * @param {?} key
         * @param {?} constructResolvingMessage
         */
        function AbstractProviderError(injector, key, constructResolvingMessage) {
            _super.call(this, 'DI Error');
            this.keys = [key];
            this.injectors = [injector];
            this.constructResolvingMessage = constructResolvingMessage;
            this.message = this.constructResolvingMessage(this.keys);
        }
        /**
         * @param {?} injector
         * @param {?} key
         * @return {?}
         */
        AbstractProviderError.prototype.addKey = function (injector, key) {
            this.injectors.push(injector);
            this.keys.push(key);
            this.message = this.constructResolvingMessage(this.keys);
        };
        return AbstractProviderError;
    }(BaseError));
    /**
     * Thrown when trying to retrieve a dependency by key from {\@link Injector}, but the
     * {\@link Injector} does not have a {\@link Provider} for the given key.
     *
     * ### Example ([live demo](http://plnkr.co/edit/vq8D3FRB9aGbnWJqtEPE?p=preview))
     *
     * ```typescript
     * class A {
     *   constructor(b:B) {}
     * }
     *
     * expect(() => Injector.resolveAndCreate([A])).toThrowError();
     * ```
     * \@stable
     */
    var NoProviderError = (function (_super) {
        __extends$1(NoProviderError, _super);
        /**
         * @param {?} injector
         * @param {?} key
         */
        function NoProviderError(injector, key) {
            _super.call(this, injector, key, function (keys) {
                var first = stringify(keys[0].token);
                return "No provider for " + first + "!" + constructResolvingPath(keys);
            });
        }
        return NoProviderError;
    }(AbstractProviderError));
    /**
     * Thrown when dependencies form a cycle.
     *
     * ### Example ([live demo](http://plnkr.co/edit/wYQdNos0Tzql3ei1EV9j?p=info))
     *
     * ```typescript
     * var injector = Injector.resolveAndCreate([
     *   {provide: "one", useFactory: (two) => "two", deps: [[new Inject("two")]]},
     *   {provide: "two", useFactory: (one) => "one", deps: [[new Inject("one")]]}
     * ]);
     *
     * expect(() => injector.get("one")).toThrowError();
     * ```
     *
     * Retrieving `A` or `B` throws a `CyclicDependencyError` as the graph above cannot be constructed.
     * \@stable
     */
    var CyclicDependencyError = (function (_super) {
        __extends$1(CyclicDependencyError, _super);
        /**
         * @param {?} injector
         * @param {?} key
         */
        function CyclicDependencyError(injector, key) {
            _super.call(this, injector, key, function (keys) {
                return "Cannot instantiate cyclic dependency!" + constructResolvingPath(keys);
            });
        }
        return CyclicDependencyError;
    }(AbstractProviderError));
    /**
     * Thrown when a constructing type returns with an Error.
     *
     * The `InstantiationError` class contains the original error plus the dependency graph which caused
     * this object to be instantiated.
     *
     * ### Example ([live demo](http://plnkr.co/edit/7aWYdcqTQsP0eNqEdUAf?p=preview))
     *
     * ```typescript
     * class A {
     *   constructor() {
     *     throw new Error('message');
     *   }
     * }
     *
     * var injector = Injector.resolveAndCreate([A]);
     * try {
     *   injector.get(A);
     * } catch (e) {
     *   expect(e instanceof InstantiationError).toBe(true);
     *   expect(e.originalException.message).toEqual("message");
     *   expect(e.originalStack).toBeDefined();
     * }
     * ```
     * \@stable
     */
    var InstantiationError = (function (_super) {
        __extends$1(InstantiationError, _super);
        /**
         * @param {?} injector
         * @param {?} originalException
         * @param {?} originalStack
         * @param {?} key
         */
        function InstantiationError(injector, originalException, originalStack, key) {
            _super.call(this, 'DI Error', originalException);
            this.keys = [key];
            this.injectors = [injector];
        }
        /**
         * @param {?} injector
         * @param {?} key
         * @return {?}
         */
        InstantiationError.prototype.addKey = function (injector, key) {
            this.injectors.push(injector);
            this.keys.push(key);
        };
        Object.defineProperty(InstantiationError.prototype, "message", {
            /**
             * @return {?}
             */
            get: function () {
                var /** @type {?} */ first = stringify(this.keys[0].token);
                return this.originalError.message + ": Error during instantiation of " + first + "!" + constructResolvingPath(this.keys) + ".";
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InstantiationError.prototype, "causeKey", {
            /**
             * @return {?}
             */
            get: function () { return this.keys[0]; },
            enumerable: true,
            configurable: true
        });
        return InstantiationError;
    }(WrappedError));
    /**
     * Thrown when an object other then {\@link Provider} (or `Type`) is passed to {\@link Injector}
     * creation.
     *
     * ### Example ([live demo](http://plnkr.co/edit/YatCFbPAMCL0JSSQ4mvH?p=preview))
     *
     * ```typescript
     * expect(() => Injector.resolveAndCreate(["not a type"])).toThrowError();
     * ```
     * \@stable
     */
    var InvalidProviderError = (function (_super) {
        __extends$1(InvalidProviderError, _super);
        /**
         * @param {?} provider
         */
        function InvalidProviderError(provider) {
            _super.call(this, "Invalid provider - only instances of Provider and Type are allowed, got: " + provider);
        }
        return InvalidProviderError;
    }(BaseError));
    /**
     * Thrown when the class has no annotation information.
     *
     * Lack of annotation information prevents the {\@link Injector} from determining which dependencies
     * need to be injected into the constructor.
     *
     * ### Example ([live demo](http://plnkr.co/edit/rHnZtlNS7vJOPQ6pcVkm?p=preview))
     *
     * ```typescript
     * class A {
     *   constructor(b) {}
     * }
     *
     * expect(() => Injector.resolveAndCreate([A])).toThrowError();
     * ```
     *
     * This error is also thrown when the class not marked with {\@link Injectable} has parameter types.
     *
     * ```typescript
     * class B {}
     *
     * class A {
     *   constructor(b:B) {} // no information about the parameter types of A is available at runtime.
     * }
     *
     * expect(() => Injector.resolveAndCreate([A,B])).toThrowError();
     * ```
     * \@stable
     */
    var NoAnnotationError = (function (_super) {
        __extends$1(NoAnnotationError, _super);
        /**
         * @param {?} typeOrFunc
         * @param {?} params
         */
        function NoAnnotationError(typeOrFunc, params) {
            _super.call(this, NoAnnotationError._genMessage(typeOrFunc, params));
        }
        /**
         * @param {?} typeOrFunc
         * @param {?} params
         * @return {?}
         */
        NoAnnotationError._genMessage = function (typeOrFunc, params) {
            var /** @type {?} */ signature = [];
            for (var /** @type {?} */ i = 0, /** @type {?} */ ii = params.length; i < ii; i++) {
                var /** @type {?} */ parameter = params[i];
                if (!parameter || parameter.length == 0) {
                    signature.push('?');
                }
                else {
                    signature.push(parameter.map(stringify).join(' '));
                }
            }
            return 'Cannot resolve all parameters for \'' + stringify(typeOrFunc) + '\'(' +
                signature.join(', ') + '). ' +
                'Make sure that all the parameters are decorated with Inject or have valid type annotations and that \'' +
                stringify(typeOrFunc) + '\' is decorated with Injectable.';
        };
        return NoAnnotationError;
    }(BaseError));
    /**
     * Thrown when getting an object by index.
     *
     * ### Example ([live demo](http://plnkr.co/edit/bRs0SX2OTQiJzqvjgl8P?p=preview))
     *
     * ```typescript
     * class A {}
     *
     * var injector = Injector.resolveAndCreate([A]);
     *
     * expect(() => injector.getAt(100)).toThrowError();
     * ```
     * \@stable
     */
    var OutOfBoundsError = (function (_super) {
        __extends$1(OutOfBoundsError, _super);
        /**
         * @param {?} index
         */
        function OutOfBoundsError(index) {
            _super.call(this, "Index " + index + " is out-of-bounds.");
        }
        return OutOfBoundsError;
    }(BaseError));
    /**
     * Thrown when a multi provider and a regular provider are bound to the same token.
     *
     * ### Example
     *
     * ```typescript
     * expect(() => Injector.resolveAndCreate([
     *   { provide: "Strings", useValue: "string1", multi: true},
     *   { provide: "Strings", useValue: "string2", multi: false}
     * ])).toThrowError();
     * ```
     */
    var MixingMultiProvidersWithRegularProvidersError = (function (_super) {
        __extends$1(MixingMultiProvidersWithRegularProvidersError, _super);
        /**
         * @param {?} provider1
         * @param {?} provider2
         */
        function MixingMultiProvidersWithRegularProvidersError(provider1, provider2) {
            _super.call(this, 'Cannot mix multi providers and regular providers, got: ' + provider1.toString() + ' ' +
                provider2.toString());
        }
        return MixingMultiProvidersWithRegularProvidersError;
    }(BaseError));

    /**
     * A unique object used for retrieving items from the {\@link ReflectiveInjector}.
     *
     * Keys have:
     * - a system-wide unique `id`.
     * - a `token`.
     *
     * `Key` is used internally by {\@link ReflectiveInjector} because its system-wide unique `id` allows
     * the
     * injector to store created objects in a more efficient way.
     *
     * `Key` should not be created directly. {\@link ReflectiveInjector} creates keys automatically when
     * resolving
     * providers.
     * \@experimental
     */
    var ReflectiveKey = (function () {
        /**
         * Private
         * @param {?} token
         * @param {?} id
         */
        function ReflectiveKey(token, id) {
            this.token = token;
            this.id = id;
            if (!token) {
                throw new Error('Token must be defined!');
            }
        }
        Object.defineProperty(ReflectiveKey.prototype, "displayName", {
            /**
             * Returns a stringified token.
             * @return {?}
             */
            get: function () { return stringify(this.token); },
            enumerable: true,
            configurable: true
        });
        /**
         * Retrieves a `Key` for a token.
         * @param {?} token
         * @return {?}
         */
        ReflectiveKey.get = function (token) {
            return _globalKeyRegistry.get(resolveForwardRef(token));
        };
        Object.defineProperty(ReflectiveKey, "numberOfKeys", {
            /**
             * @return {?} the number of keys registered in the system.
             */
            get: function () { return _globalKeyRegistry.numberOfKeys; },
            enumerable: true,
            configurable: true
        });
        return ReflectiveKey;
    }());
    /**
     * \@internal
     */
    var KeyRegistry = (function () {
        function KeyRegistry() {
            this._allKeys = new Map();
        }
        /**
         * @param {?} token
         * @return {?}
         */
        KeyRegistry.prototype.get = function (token) {
            if (token instanceof ReflectiveKey)
                return token;
            if (this._allKeys.has(token)) {
                return this._allKeys.get(token);
            }
            var /** @type {?} */ newKey = new ReflectiveKey(token, ReflectiveKey.numberOfKeys);
            this._allKeys.set(token, newKey);
            return newKey;
        };
        Object.defineProperty(KeyRegistry.prototype, "numberOfKeys", {
            /**
             * @return {?}
             */
            get: function () { return this._allKeys.size; },
            enumerable: true,
            configurable: true
        });
        return KeyRegistry;
    }());
    var /** @type {?} */ _globalKeyRegistry = new KeyRegistry();

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * @whatItDoes Represents a type that a Component or other object is instances of.
     *
     * @description
     *
     * An example of a `Type` is `MyCustomComponent` class, which in JavaScript is be represented by
     * the `MyCustomComponent` constructor function.
     *
     * @stable
     */
    var /** @type {?} */ Type = Function;
    /**
     * @param {?} v
     * @return {?}
     */
    function isType(v) {
        return typeof v === 'function';
    }

    /**
     * Attention: This regex has to hold even if the code is minified!
     */
    var /** @type {?} */ DELEGATE_CTOR = /^function\s+\S+\(\)\s*{\s*("use strict";)?\s*(return\s+)?\S+\.apply\(this,\s*arguments\)/;
    var ReflectionCapabilities = (function () {
        /**
         * @param {?=} reflect
         */
        function ReflectionCapabilities(reflect) {
            this._reflect = reflect || global$1.Reflect;
        }
        /**
         * @return {?}
         */
        ReflectionCapabilities.prototype.isReflectionEnabled = function () { return true; };
        /**
         * @param {?} t
         * @return {?}
         */
        ReflectionCapabilities.prototype.factory = function (t) { return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            return new (t.bind.apply(t, [void 0].concat(args)))();
        }; };
        /**
         * \@internal
         * @param {?} paramTypes
         * @param {?} paramAnnotations
         * @return {?}
         */
        ReflectionCapabilities.prototype._zipTypesAndAnnotations = function (paramTypes, paramAnnotations) {
            var /** @type {?} */ result;
            if (typeof paramTypes === 'undefined') {
                result = new Array(paramAnnotations.length);
            }
            else {
                result = new Array(paramTypes.length);
            }
            for (var /** @type {?} */ i = 0; i < result.length; i++) {
                // TS outputs Object for parameters without types, while Traceur omits
                // the annotations. For now we preserve the Traceur behavior to aid
                // migration, but this can be revisited.
                if (typeof paramTypes === 'undefined') {
                    result[i] = [];
                }
                else if (paramTypes[i] != Object) {
                    result[i] = [paramTypes[i]];
                }
                else {
                    result[i] = [];
                }
                if (paramAnnotations && isPresent(paramAnnotations[i])) {
                    result[i] = result[i].concat(paramAnnotations[i]);
                }
            }
            return result;
        };
        /**
         * @param {?} type
         * @param {?} parentCtor
         * @return {?}
         */
        ReflectionCapabilities.prototype._ownParameters = function (type, parentCtor) {
            // If we have no decorators, we only have function.length as metadata.
            // In that case, to detect whether a child class declared an own constructor or not,
            // we need to look inside of that constructor to check whether it is
            // just calling the parent.
            // This also helps to work around for https://github.com/Microsoft/TypeScript/issues/12439
            // that sets 'design:paramtypes' to []
            // if a class inherits from another class but has no ctor declared itself.
            if (DELEGATE_CTOR.exec(type.toString())) {
                return null;
            }
            // Prefer the direct API.
            if (((type)).parameters && ((type)).parameters !== parentCtor.parameters) {
                return ((type)).parameters;
            }
            // API of tsickle for lowering decorators to properties on the class.
            var /** @type {?} */ tsickleCtorParams = ((type)).ctorParameters;
            if (tsickleCtorParams && tsickleCtorParams !== parentCtor.ctorParameters) {
                // Newer tsickle uses a function closure
                // Retain the non-function case for compatibility with older tsickle
                var /** @type {?} */ ctorParameters = typeof tsickleCtorParams === 'function' ? tsickleCtorParams() : tsickleCtorParams;
                var /** @type {?} */ paramTypes = ctorParameters.map(function (ctorParam) { return ctorParam && ctorParam.type; });
                var /** @type {?} */ paramAnnotations = ctorParameters.map(function (ctorParam) {
                    return ctorParam && convertTsickleDecoratorIntoMetadata(ctorParam.decorators);
                });
                return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);
            }
            // API for metadata created by invoking the decorators.
            if (isPresent(this._reflect) && isPresent(this._reflect.getOwnMetadata)) {
                var /** @type {?} */ paramAnnotations = this._reflect.getOwnMetadata('parameters', type);
                var /** @type {?} */ paramTypes = this._reflect.getOwnMetadata('design:paramtypes', type);
                if (paramTypes || paramAnnotations) {
                    return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);
                }
            }
            // If a class has no decorators, at least create metadata
            // based on function.length.
            // Note: We know that this is a real constructor as we checked
            // the content of the constructor above.
            return new Array(((type.length))).fill(undefined);
        };
        /**
         * @param {?} type
         * @return {?}
         */
        ReflectionCapabilities.prototype.parameters = function (type) {
            // Note: only report metadata if we have at least one class decorator
            // to stay in sync with the static reflector.
            if (!isType(type)) {
                return [];
            }
            var /** @type {?} */ parentCtor = getParentCtor(type);
            var /** @type {?} */ parameters = this._ownParameters(type, parentCtor);
            if (!parameters && parentCtor !== Object) {
                parameters = this.parameters(parentCtor);
            }
            return parameters || [];
        };
        /**
         * @param {?} typeOrFunc
         * @param {?} parentCtor
         * @return {?}
         */
        ReflectionCapabilities.prototype._ownAnnotations = function (typeOrFunc, parentCtor) {
            // Prefer the direct API.
            if (((typeOrFunc)).annotations && ((typeOrFunc)).annotations !== parentCtor.annotations) {
                var /** @type {?} */ annotations = ((typeOrFunc)).annotations;
                if (typeof annotations === 'function' && annotations.annotations) {
                    annotations = annotations.annotations;
                }
                return annotations;
            }
            // API of tsickle for lowering decorators to properties on the class.
            if (((typeOrFunc)).decorators && ((typeOrFunc)).decorators !== parentCtor.decorators) {
                return convertTsickleDecoratorIntoMetadata(((typeOrFunc)).decorators);
            }
            // API for metadata created by invoking the decorators.
            if (this._reflect && this._reflect.getOwnMetadata) {
                return this._reflect.getOwnMetadata('annotations', typeOrFunc);
            }
        };
        /**
         * @param {?} typeOrFunc
         * @return {?}
         */
        ReflectionCapabilities.prototype.annotations = function (typeOrFunc) {
            if (!isType(typeOrFunc)) {
                return [];
            }
            var /** @type {?} */ parentCtor = getParentCtor(typeOrFunc);
            var /** @type {?} */ ownAnnotations = this._ownAnnotations(typeOrFunc, parentCtor) || [];
            var /** @type {?} */ parentAnnotations = parentCtor !== Object ? this.annotations(parentCtor) : [];
            return parentAnnotations.concat(ownAnnotations);
        };
        /**
         * @param {?} typeOrFunc
         * @param {?} parentCtor
         * @return {?}
         */
        ReflectionCapabilities.prototype._ownPropMetadata = function (typeOrFunc, parentCtor) {
            // Prefer the direct API.
            if (((typeOrFunc)).propMetadata &&
                ((typeOrFunc)).propMetadata !== parentCtor.propMetadata) {
                var /** @type {?} */ propMetadata = ((typeOrFunc)).propMetadata;
                if (typeof propMetadata === 'function' && propMetadata.propMetadata) {
                    propMetadata = propMetadata.propMetadata;
                }
                return propMetadata;
            }
            // API of tsickle for lowering decorators to properties on the class.
            if (((typeOrFunc)).propDecorators &&
                ((typeOrFunc)).propDecorators !== parentCtor.propDecorators) {
                var /** @type {?} */ propDecorators_1 = ((typeOrFunc)).propDecorators;
                var /** @type {?} */ propMetadata_1 = ({});
                Object.keys(propDecorators_1).forEach(function (prop) {
                    propMetadata_1[prop] = convertTsickleDecoratorIntoMetadata(propDecorators_1[prop]);
                });
                return propMetadata_1;
            }
            // API for metadata created by invoking the decorators.
            if (this._reflect && this._reflect.getOwnMetadata) {
                return this._reflect.getOwnMetadata('propMetadata', typeOrFunc);
            }
        };
        /**
         * @param {?} typeOrFunc
         * @return {?}
         */
        ReflectionCapabilities.prototype.propMetadata = function (typeOrFunc) {
            if (!isType(typeOrFunc)) {
                return {};
            }
            var /** @type {?} */ parentCtor = getParentCtor(typeOrFunc);
            var /** @type {?} */ propMetadata = {};
            if (parentCtor !== Object) {
                var /** @type {?} */ parentPropMetadata_1 = this.propMetadata(parentCtor);
                Object.keys(parentPropMetadata_1).forEach(function (propName) {
                    propMetadata[propName] = parentPropMetadata_1[propName];
                });
            }
            var /** @type {?} */ ownPropMetadata = this._ownPropMetadata(typeOrFunc, parentCtor);
            if (ownPropMetadata) {
                Object.keys(ownPropMetadata).forEach(function (propName) {
                    var /** @type {?} */ decorators = [];
                    if (propMetadata.hasOwnProperty(propName)) {
                        decorators.push.apply(decorators, propMetadata[propName]);
                    }
                    decorators.push.apply(decorators, ownPropMetadata[propName]);
                    propMetadata[propName] = decorators;
                });
            }
            return propMetadata;
        };
        /**
         * @param {?} type
         * @param {?} lcProperty
         * @return {?}
         */
        ReflectionCapabilities.prototype.hasLifecycleHook = function (type, lcProperty) {
            return type instanceof Type && lcProperty in type.prototype;
        };
        /**
         * @param {?} name
         * @return {?}
         */
        ReflectionCapabilities.prototype.getter = function (name) { return ((new Function('o', 'return o.' + name + ';'))); };
        /**
         * @param {?} name
         * @return {?}
         */
        ReflectionCapabilities.prototype.setter = function (name) {
            return ((new Function('o', 'v', 'return o.' + name + ' = v;')));
        };
        /**
         * @param {?} name
         * @return {?}
         */
        ReflectionCapabilities.prototype.method = function (name) {
            var /** @type {?} */ functionBody = "if (!o." + name + ") throw new Error('\"" + name + "\" is undefined');\n        return o." + name + ".apply(o, args);";
            return ((new Function('o', 'args', functionBody)));
        };
        /**
         * @param {?} type
         * @return {?}
         */
        ReflectionCapabilities.prototype.importUri = function (type) {
            // StaticSymbol
            if (typeof type === 'object' && type['filePath']) {
                return type['filePath'];
            }
            // Runtime type
            return "./" + stringify(type);
        };
        /**
         * @param {?} name
         * @param {?} moduleUrl
         * @param {?} runtime
         * @return {?}
         */
        ReflectionCapabilities.prototype.resolveIdentifier = function (name, moduleUrl, runtime) { return runtime; };
        /**
         * @param {?} enumIdentifier
         * @param {?} name
         * @return {?}
         */
        ReflectionCapabilities.prototype.resolveEnum = function (enumIdentifier, name) { return enumIdentifier[name]; };
        return ReflectionCapabilities;
    }());
    /**
     * @param {?} decoratorInvocations
     * @return {?}
     */
    function convertTsickleDecoratorIntoMetadata(decoratorInvocations) {
        if (!decoratorInvocations) {
            return [];
        }
        return decoratorInvocations.map(function (decoratorInvocation) {
            var /** @type {?} */ decoratorType = decoratorInvocation.type;
            var /** @type {?} */ annotationCls = decoratorType.annotationCls;
            var /** @type {?} */ annotationArgs = decoratorInvocation.args ? decoratorInvocation.args : [];
            return new (annotationCls.bind.apply(annotationCls, [void 0].concat(annotationArgs)))();
        });
    }
    /**
     * @param {?} ctor
     * @return {?}
     */
    function getParentCtor(ctor) {
        var /** @type {?} */ parentProto = Object.getPrototypeOf(ctor.prototype);
        var /** @type {?} */ parentCtor = parentProto ? parentProto.constructor : null;
        // Note: We always use `Object` as the null value
        // to simplify checking later on.
        return parentCtor || Object;
    }

    /**
     * Provides read-only access to reflection data about symbols. Used internally by Angular
     * to power dependency injection and compilation.
     * @abstract
     */
    var ReflectorReader = (function () {
        function ReflectorReader() {
        }
        /**
         * @abstract
         * @param {?} typeOrFunc
         * @return {?}
         */
        ReflectorReader.prototype.parameters = function (typeOrFunc) { };
        /**
         * @abstract
         * @param {?} typeOrFunc
         * @return {?}
         */
        ReflectorReader.prototype.annotations = function (typeOrFunc) { };
        /**
         * @abstract
         * @param {?} typeOrFunc
         * @return {?}
         */
        ReflectorReader.prototype.propMetadata = function (typeOrFunc) { };
        /**
         * @abstract
         * @param {?} typeOrFunc
         * @return {?}
         */
        ReflectorReader.prototype.importUri = function (typeOrFunc) { };
        /**
         * @abstract
         * @param {?} name
         * @param {?} moduleUrl
         * @param {?} runtime
         * @return {?}
         */
        ReflectorReader.prototype.resolveIdentifier = function (name, moduleUrl, runtime) { };
        /**
         * @abstract
         * @param {?} identifier
         * @param {?} name
         * @return {?}
         */
        ReflectorReader.prototype.resolveEnum = function (identifier, name) { };
        return ReflectorReader;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$2 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * Provides access to reflection data about symbols. Used internally by Angular
     * to power dependency injection and compilation.
     */
    var Reflector = (function (_super) {
        __extends$2(Reflector, _super);
        /**
         * @param {?} reflectionCapabilities
         */
        function Reflector(reflectionCapabilities) {
            _super.call(this);
            this.reflectionCapabilities = reflectionCapabilities;
        }
        /**
         * @param {?} caps
         * @return {?}
         */
        Reflector.prototype.updateCapabilities = function (caps) { this.reflectionCapabilities = caps; };
        /**
         * @param {?} type
         * @return {?}
         */
        Reflector.prototype.factory = function (type) { return this.reflectionCapabilities.factory(type); };
        /**
         * @param {?} typeOrFunc
         * @return {?}
         */
        Reflector.prototype.parameters = function (typeOrFunc) {
            return this.reflectionCapabilities.parameters(typeOrFunc);
        };
        /**
         * @param {?} typeOrFunc
         * @return {?}
         */
        Reflector.prototype.annotations = function (typeOrFunc) {
            return this.reflectionCapabilities.annotations(typeOrFunc);
        };
        /**
         * @param {?} typeOrFunc
         * @return {?}
         */
        Reflector.prototype.propMetadata = function (typeOrFunc) {
            return this.reflectionCapabilities.propMetadata(typeOrFunc);
        };
        /**
         * @param {?} type
         * @param {?} lcProperty
         * @return {?}
         */
        Reflector.prototype.hasLifecycleHook = function (type, lcProperty) {
            return this.reflectionCapabilities.hasLifecycleHook(type, lcProperty);
        };
        /**
         * @param {?} name
         * @return {?}
         */
        Reflector.prototype.getter = function (name) { return this.reflectionCapabilities.getter(name); };
        /**
         * @param {?} name
         * @return {?}
         */
        Reflector.prototype.setter = function (name) { return this.reflectionCapabilities.setter(name); };
        /**
         * @param {?} name
         * @return {?}
         */
        Reflector.prototype.method = function (name) { return this.reflectionCapabilities.method(name); };
        /**
         * @param {?} type
         * @return {?}
         */
        Reflector.prototype.importUri = function (type) { return this.reflectionCapabilities.importUri(type); };
        /**
         * @param {?} name
         * @param {?} moduleUrl
         * @param {?} runtime
         * @return {?}
         */
        Reflector.prototype.resolveIdentifier = function (name, moduleUrl, runtime) {
            return this.reflectionCapabilities.resolveIdentifier(name, moduleUrl, runtime);
        };
        /**
         * @param {?} identifier
         * @param {?} name
         * @return {?}
         */
        Reflector.prototype.resolveEnum = function (identifier, name) {
            return this.reflectionCapabilities.resolveEnum(identifier, name);
        };
        return Reflector;
    }(ReflectorReader));

    /**
     * The {@link Reflector} used internally in Angular to access metadata
     * about symbols.
     */
    var /** @type {?} */ reflector = new Reflector(new ReflectionCapabilities());

    /**
     * `Dependency` is used by the framework to extend DI.
     * This is internal to Angular and should not be used directly.
     */
    var ReflectiveDependency = (function () {
        /**
         * @param {?} key
         * @param {?} optional
         * @param {?} lowerBoundVisibility
         * @param {?} upperBoundVisibility
         * @param {?} properties
         */
        function ReflectiveDependency(key, optional, lowerBoundVisibility, upperBoundVisibility, properties) {
            this.key = key;
            this.optional = optional;
            this.lowerBoundVisibility = lowerBoundVisibility;
            this.upperBoundVisibility = upperBoundVisibility;
            this.properties = properties;
        }
        /**
         * @param {?} key
         * @return {?}
         */
        ReflectiveDependency.fromKey = function (key) {
            return new ReflectiveDependency(key, false, null, null, []);
        };
        return ReflectiveDependency;
    }());
    var /** @type {?} */ _EMPTY_LIST = [];
    var ResolvedReflectiveProvider_ = (function () {
        /**
         * @param {?} key
         * @param {?} resolvedFactories
         * @param {?} multiProvider
         */
        function ResolvedReflectiveProvider_(key, resolvedFactories, multiProvider) {
            this.key = key;
            this.resolvedFactories = resolvedFactories;
            this.multiProvider = multiProvider;
        }
        Object.defineProperty(ResolvedReflectiveProvider_.prototype, "resolvedFactory", {
            /**
             * @return {?}
             */
            get: function () { return this.resolvedFactories[0]; },
            enumerable: true,
            configurable: true
        });
        return ResolvedReflectiveProvider_;
    }());
    /**
     * An internal resolved representation of a factory function created by resolving {\@link
     * Provider}.
     * \@experimental
     */
    var ResolvedReflectiveFactory = (function () {
        /**
         * @param {?} factory
         * @param {?} dependencies
         */
        function ResolvedReflectiveFactory(factory, dependencies) {
            this.factory = factory;
            this.dependencies = dependencies;
        }
        return ResolvedReflectiveFactory;
    }());
    /**
     * Resolve a single provider.
     * @param {?} provider
     * @return {?}
     */
    function resolveReflectiveFactory(provider) {
        var /** @type {?} */ factoryFn;
        var /** @type {?} */ resolvedDeps;
        if (provider.useClass) {
            var /** @type {?} */ useClass = resolveForwardRef(provider.useClass);
            factoryFn = reflector.factory(useClass);
            resolvedDeps = _dependenciesFor(useClass);
        }
        else if (provider.useExisting) {
            factoryFn = function (aliasInstance) { return aliasInstance; };
            resolvedDeps = [ReflectiveDependency.fromKey(ReflectiveKey.get(provider.useExisting))];
        }
        else if (provider.useFactory) {
            factoryFn = provider.useFactory;
            resolvedDeps = constructDependencies(provider.useFactory, provider.deps);
        }
        else {
            factoryFn = function () { return provider.useValue; };
            resolvedDeps = _EMPTY_LIST;
        }
        return new ResolvedReflectiveFactory(factoryFn, resolvedDeps);
    }
    /**
     * Converts the {\@link Provider} into {\@link ResolvedProvider}.
     *
     * {\@link Injector} internally only uses {\@link ResolvedProvider}, {\@link Provider} contains
     * convenience provider syntax.
     * @param {?} provider
     * @return {?}
     */
    function resolveReflectiveProvider(provider) {
        return new ResolvedReflectiveProvider_(ReflectiveKey.get(provider.provide), [resolveReflectiveFactory(provider)], provider.multi);
    }
    /**
     * Resolve a list of Providers.
     * @param {?} providers
     * @return {?}
     */
    function resolveReflectiveProviders(providers) {
        var /** @type {?} */ normalized = _normalizeProviders(providers, []);
        var /** @type {?} */ resolved = normalized.map(resolveReflectiveProvider);
        var /** @type {?} */ resolvedProviderMap = mergeResolvedReflectiveProviders(resolved, new Map());
        return Array.from(resolvedProviderMap.values());
    }
    /**
     * Merges a list of ResolvedProviders into a list where
     * each key is contained exactly once and multi providers
     * have been merged.
     * @param {?} providers
     * @param {?} normalizedProvidersMap
     * @return {?}
     */
    function mergeResolvedReflectiveProviders(providers, normalizedProvidersMap) {
        for (var /** @type {?} */ i = 0; i < providers.length; i++) {
            var /** @type {?} */ provider = providers[i];
            var /** @type {?} */ existing = normalizedProvidersMap.get(provider.key.id);
            if (existing) {
                if (provider.multiProvider !== existing.multiProvider) {
                    throw new MixingMultiProvidersWithRegularProvidersError(existing, provider);
                }
                if (provider.multiProvider) {
                    for (var /** @type {?} */ j = 0; j < provider.resolvedFactories.length; j++) {
                        existing.resolvedFactories.push(provider.resolvedFactories[j]);
                    }
                }
                else {
                    normalizedProvidersMap.set(provider.key.id, provider);
                }
            }
            else {
                var /** @type {?} */ resolvedProvider = void 0;
                if (provider.multiProvider) {
                    resolvedProvider = new ResolvedReflectiveProvider_(provider.key, provider.resolvedFactories.slice(), provider.multiProvider);
                }
                else {
                    resolvedProvider = provider;
                }
                normalizedProvidersMap.set(provider.key.id, resolvedProvider);
            }
        }
        return normalizedProvidersMap;
    }
    /**
     * @param {?} providers
     * @param {?} res
     * @return {?}
     */
    function _normalizeProviders(providers, res) {
        providers.forEach(function (b) {
            if (b instanceof Type) {
                res.push({ provide: b, useClass: b });
            }
            else if (b && typeof b == 'object' && ((b)).provide !== undefined) {
                res.push(/** @type {?} */ (b));
            }
            else if (b instanceof Array) {
                _normalizeProviders(b, res);
            }
            else {
                throw new InvalidProviderError(b);
            }
        });
        return res;
    }
    /**
     * @param {?} typeOrFunc
     * @param {?} dependencies
     * @return {?}
     */
    function constructDependencies(typeOrFunc, dependencies) {
        if (!dependencies) {
            return _dependenciesFor(typeOrFunc);
        }
        else {
            var /** @type {?} */ params_1 = dependencies.map(function (t) { return [t]; });
            return dependencies.map(function (t) { return _extractToken(typeOrFunc, t, params_1); });
        }
    }
    /**
     * @param {?} typeOrFunc
     * @return {?}
     */
    function _dependenciesFor(typeOrFunc) {
        var /** @type {?} */ params = reflector.parameters(typeOrFunc);
        if (!params)
            return [];
        if (params.some(function (p) { return p == null; })) {
            throw new NoAnnotationError(typeOrFunc, params);
        }
        return params.map(function (p) { return _extractToken(typeOrFunc, p, params); });
    }
    /**
     * @param {?} typeOrFunc
     * @param {?} metadata
     * @param {?} params
     * @return {?}
     */
    function _extractToken(typeOrFunc, metadata, params) {
        var /** @type {?} */ depProps = [];
        var /** @type {?} */ token = null;
        var /** @type {?} */ optional = false;
        if (!Array.isArray(metadata)) {
            if (metadata instanceof Inject) {
                return _createDependency(metadata.token, optional, null, null, depProps);
            }
            else {
                return _createDependency(metadata, optional, null, null, depProps);
            }
        }
        var /** @type {?} */ lowerBoundVisibility = null;
        var /** @type {?} */ upperBoundVisibility = null;
        for (var /** @type {?} */ i = 0; i < metadata.length; ++i) {
            var /** @type {?} */ paramMetadata = metadata[i];
            if (paramMetadata instanceof Type) {
                token = paramMetadata;
            }
            else if (paramMetadata instanceof Inject) {
                token = paramMetadata.token;
            }
            else if (paramMetadata instanceof Optional) {
                optional = true;
            }
            else if (paramMetadata instanceof Self) {
                upperBoundVisibility = paramMetadata;
            }
            else if (paramMetadata instanceof Host) {
                upperBoundVisibility = paramMetadata;
            }
            else if (paramMetadata instanceof SkipSelf) {
                lowerBoundVisibility = paramMetadata;
            }
        }
        token = resolveForwardRef(token);
        if (token != null) {
            return _createDependency(token, optional, lowerBoundVisibility, upperBoundVisibility, depProps);
        }
        else {
            throw new NoAnnotationError(typeOrFunc, params);
        }
    }
    /**
     * @param {?} token
     * @param {?} optional
     * @param {?} lowerBoundVisibility
     * @param {?} upperBoundVisibility
     * @param {?} depProps
     * @return {?}
     */
    function _createDependency(token, optional, lowerBoundVisibility, upperBoundVisibility, depProps) {
        return new ReflectiveDependency(ReflectiveKey.get(token), optional, lowerBoundVisibility, upperBoundVisibility, depProps);
    }

    // Threshold for the dynamic version
    var /** @type {?} */ _MAX_CONSTRUCTION_COUNTER = 10;
    var /** @type {?} */ UNDEFINED = new Object();
    var ReflectiveProtoInjectorInlineStrategy = (function () {
        /**
         * @param {?} protoEI
         * @param {?} providers
         */
        function ReflectiveProtoInjectorInlineStrategy(protoEI, providers) {
            this.provider0 = null;
            this.provider1 = null;
            this.provider2 = null;
            this.provider3 = null;
            this.provider4 = null;
            this.provider5 = null;
            this.provider6 = null;
            this.provider7 = null;
            this.provider8 = null;
            this.provider9 = null;
            this.keyId0 = null;
            this.keyId1 = null;
            this.keyId2 = null;
            this.keyId3 = null;
            this.keyId4 = null;
            this.keyId5 = null;
            this.keyId6 = null;
            this.keyId7 = null;
            this.keyId8 = null;
            this.keyId9 = null;
            var length = providers.length;
            if (length > 0) {
                this.provider0 = providers[0];
                this.keyId0 = providers[0].key.id;
            }
            if (length > 1) {
                this.provider1 = providers[1];
                this.keyId1 = providers[1].key.id;
            }
            if (length > 2) {
                this.provider2 = providers[2];
                this.keyId2 = providers[2].key.id;
            }
            if (length > 3) {
                this.provider3 = providers[3];
                this.keyId3 = providers[3].key.id;
            }
            if (length > 4) {
                this.provider4 = providers[4];
                this.keyId4 = providers[4].key.id;
            }
            if (length > 5) {
                this.provider5 = providers[5];
                this.keyId5 = providers[5].key.id;
            }
            if (length > 6) {
                this.provider6 = providers[6];
                this.keyId6 = providers[6].key.id;
            }
            if (length > 7) {
                this.provider7 = providers[7];
                this.keyId7 = providers[7].key.id;
            }
            if (length > 8) {
                this.provider8 = providers[8];
                this.keyId8 = providers[8].key.id;
            }
            if (length > 9) {
                this.provider9 = providers[9];
                this.keyId9 = providers[9].key.id;
            }
        }
        /**
         * @param {?} index
         * @return {?}
         */
        ReflectiveProtoInjectorInlineStrategy.prototype.getProviderAtIndex = function (index) {
            if (index == 0)
                return this.provider0;
            if (index == 1)
                return this.provider1;
            if (index == 2)
                return this.provider2;
            if (index == 3)
                return this.provider3;
            if (index == 4)
                return this.provider4;
            if (index == 5)
                return this.provider5;
            if (index == 6)
                return this.provider6;
            if (index == 7)
                return this.provider7;
            if (index == 8)
                return this.provider8;
            if (index == 9)
                return this.provider9;
            throw new OutOfBoundsError(index);
        };
        /**
         * @param {?} injector
         * @return {?}
         */
        ReflectiveProtoInjectorInlineStrategy.prototype.createInjectorStrategy = function (injector) {
            return new ReflectiveInjectorInlineStrategy(injector, this);
        };
        return ReflectiveProtoInjectorInlineStrategy;
    }());
    var ReflectiveProtoInjectorDynamicStrategy = (function () {
        /**
         * @param {?} protoInj
         * @param {?} providers
         */
        function ReflectiveProtoInjectorDynamicStrategy(protoInj, providers) {
            this.providers = providers;
            var len = providers.length;
            this.keyIds = new Array(len);
            for (var i = 0; i < len; i++) {
                this.keyIds[i] = providers[i].key.id;
            }
        }
        /**
         * @param {?} index
         * @return {?}
         */
        ReflectiveProtoInjectorDynamicStrategy.prototype.getProviderAtIndex = function (index) {
            if (index < 0 || index >= this.providers.length) {
                throw new OutOfBoundsError(index);
            }
            return this.providers[index];
        };
        /**
         * @param {?} ei
         * @return {?}
         */
        ReflectiveProtoInjectorDynamicStrategy.prototype.createInjectorStrategy = function (ei) {
            return new ReflectiveInjectorDynamicStrategy(this, ei);
        };
        return ReflectiveProtoInjectorDynamicStrategy;
    }());
    var ReflectiveProtoInjector = (function () {
        /**
         * @param {?} providers
         */
        function ReflectiveProtoInjector(providers) {
            this.numberOfProviders = providers.length;
            this._strategy = providers.length > _MAX_CONSTRUCTION_COUNTER ?
                new ReflectiveProtoInjectorDynamicStrategy(this, providers) :
                new ReflectiveProtoInjectorInlineStrategy(this, providers);
        }
        /**
         * @param {?} providers
         * @return {?}
         */
        ReflectiveProtoInjector.fromResolvedProviders = function (providers) {
            return new ReflectiveProtoInjector(providers);
        };
        /**
         * @param {?} index
         * @return {?}
         */
        ReflectiveProtoInjector.prototype.getProviderAtIndex = function (index) {
            return this._strategy.getProviderAtIndex(index);
        };
        return ReflectiveProtoInjector;
    }());
    var ReflectiveInjectorInlineStrategy = (function () {
        /**
         * @param {?} injector
         * @param {?} protoStrategy
         */
        function ReflectiveInjectorInlineStrategy(injector, protoStrategy) {
            this.injector = injector;
            this.protoStrategy = protoStrategy;
            this.obj0 = UNDEFINED;
            this.obj1 = UNDEFINED;
            this.obj2 = UNDEFINED;
            this.obj3 = UNDEFINED;
            this.obj4 = UNDEFINED;
            this.obj5 = UNDEFINED;
            this.obj6 = UNDEFINED;
            this.obj7 = UNDEFINED;
            this.obj8 = UNDEFINED;
            this.obj9 = UNDEFINED;
        }
        /**
         * @return {?}
         */
        ReflectiveInjectorInlineStrategy.prototype.resetConstructionCounter = function () { this.injector._constructionCounter = 0; };
        /**
         * @param {?} provider
         * @return {?}
         */
        ReflectiveInjectorInlineStrategy.prototype.instantiateProvider = function (provider) {
            return this.injector._new(provider);
        };
        /**
         * @param {?} keyId
         * @return {?}
         */
        ReflectiveInjectorInlineStrategy.prototype.getObjByKeyId = function (keyId) {
            var /** @type {?} */ p = this.protoStrategy;
            var /** @type {?} */ inj = this.injector;
            if (p.keyId0 === keyId) {
                if (this.obj0 === UNDEFINED) {
                    this.obj0 = inj._new(p.provider0);
                }
                return this.obj0;
            }
            if (p.keyId1 === keyId) {
                if (this.obj1 === UNDEFINED) {
                    this.obj1 = inj._new(p.provider1);
                }
                return this.obj1;
            }
            if (p.keyId2 === keyId) {
                if (this.obj2 === UNDEFINED) {
                    this.obj2 = inj._new(p.provider2);
                }
                return this.obj2;
            }
            if (p.keyId3 === keyId) {
                if (this.obj3 === UNDEFINED) {
                    this.obj3 = inj._new(p.provider3);
                }
                return this.obj3;
            }
            if (p.keyId4 === keyId) {
                if (this.obj4 === UNDEFINED) {
                    this.obj4 = inj._new(p.provider4);
                }
                return this.obj4;
            }
            if (p.keyId5 === keyId) {
                if (this.obj5 === UNDEFINED) {
                    this.obj5 = inj._new(p.provider5);
                }
                return this.obj5;
            }
            if (p.keyId6 === keyId) {
                if (this.obj6 === UNDEFINED) {
                    this.obj6 = inj._new(p.provider6);
                }
                return this.obj6;
            }
            if (p.keyId7 === keyId) {
                if (this.obj7 === UNDEFINED) {
                    this.obj7 = inj._new(p.provider7);
                }
                return this.obj7;
            }
            if (p.keyId8 === keyId) {
                if (this.obj8 === UNDEFINED) {
                    this.obj8 = inj._new(p.provider8);
                }
                return this.obj8;
            }
            if (p.keyId9 === keyId) {
                if (this.obj9 === UNDEFINED) {
                    this.obj9 = inj._new(p.provider9);
                }
                return this.obj9;
            }
            return UNDEFINED;
        };
        /**
         * @param {?} index
         * @return {?}
         */
        ReflectiveInjectorInlineStrategy.prototype.getObjAtIndex = function (index) {
            if (index == 0)
                return this.obj0;
            if (index == 1)
                return this.obj1;
            if (index == 2)
                return this.obj2;
            if (index == 3)
                return this.obj3;
            if (index == 4)
                return this.obj4;
            if (index == 5)
                return this.obj5;
            if (index == 6)
                return this.obj6;
            if (index == 7)
                return this.obj7;
            if (index == 8)
                return this.obj8;
            if (index == 9)
                return this.obj9;
            throw new OutOfBoundsError(index);
        };
        /**
         * @return {?}
         */
        ReflectiveInjectorInlineStrategy.prototype.getMaxNumberOfObjects = function () { return _MAX_CONSTRUCTION_COUNTER; };
        return ReflectiveInjectorInlineStrategy;
    }());
    var ReflectiveInjectorDynamicStrategy = (function () {
        /**
         * @param {?} protoStrategy
         * @param {?} injector
         */
        function ReflectiveInjectorDynamicStrategy(protoStrategy, injector) {
            this.protoStrategy = protoStrategy;
            this.injector = injector;
            this.objs = new Array(protoStrategy.providers.length).fill(UNDEFINED);
        }
        /**
         * @return {?}
         */
        ReflectiveInjectorDynamicStrategy.prototype.resetConstructionCounter = function () { this.injector._constructionCounter = 0; };
        /**
         * @param {?} provider
         * @return {?}
         */
        ReflectiveInjectorDynamicStrategy.prototype.instantiateProvider = function (provider) {
            return this.injector._new(provider);
        };
        /**
         * @param {?} keyId
         * @return {?}
         */
        ReflectiveInjectorDynamicStrategy.prototype.getObjByKeyId = function (keyId) {
            var /** @type {?} */ p = this.protoStrategy;
            for (var /** @type {?} */ i = 0; i < p.keyIds.length; i++) {
                if (p.keyIds[i] === keyId) {
                    if (this.objs[i] === UNDEFINED) {
                        this.objs[i] = this.injector._new(p.providers[i]);
                    }
                    return this.objs[i];
                }
            }
            return UNDEFINED;
        };
        /**
         * @param {?} index
         * @return {?}
         */
        ReflectiveInjectorDynamicStrategy.prototype.getObjAtIndex = function (index) {
            if (index < 0 || index >= this.objs.length) {
                throw new OutOfBoundsError(index);
            }
            return this.objs[index];
        };
        /**
         * @return {?}
         */
        ReflectiveInjectorDynamicStrategy.prototype.getMaxNumberOfObjects = function () { return this.objs.length; };
        return ReflectiveInjectorDynamicStrategy;
    }());
    /**
     * A ReflectiveDependency injection container used for instantiating objects and resolving
     * dependencies.
     *
     * An `Injector` is a replacement for a `new` operator, which can automatically resolve the
     * constructor dependencies.
     *
     * In typical use, application code asks for the dependencies in the constructor and they are
     * resolved by the `Injector`.
     *
     * ### Example ([live demo](http://plnkr.co/edit/jzjec0?p=preview))
     *
     * The following example creates an `Injector` configured to create `Engine` and `Car`.
     *
     * ```typescript
     * \@Injectable()
     * class Engine {
     * }
     *
     * \@Injectable()
     * class Car {
     *   constructor(public engine:Engine) {}
     * }
     *
     * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);
     * var car = injector.get(Car);
     * expect(car instanceof Car).toBe(true);
     * expect(car.engine instanceof Engine).toBe(true);
     * ```
     *
     * Notice, we don't use the `new` operator because we explicitly want to have the `Injector`
     * resolve all of the object's dependencies automatically.
     *
     * \@stable
     * @abstract
     */
    var ReflectiveInjector = (function () {
        function ReflectiveInjector() {
        }
        /**
         * Turns an array of provider definitions into an array of resolved providers.
         *
         * A resolution is a process of flattening multiple nested arrays and converting individual
         * providers into an array of {\@link ResolvedReflectiveProvider}s.
         *
         * ### Example ([live demo](http://plnkr.co/edit/AiXTHi?p=preview))
         *
         * ```typescript
         * \@Injectable()
         * class Engine {
         * }
         *
         * \@Injectable()
         * class Car {
         *   constructor(public engine:Engine) {}
         * }
         *
         * var providers = ReflectiveInjector.resolve([Car, [[Engine]]]);
         *
         * expect(providers.length).toEqual(2);
         *
         * expect(providers[0] instanceof ResolvedReflectiveProvider).toBe(true);
         * expect(providers[0].key.displayName).toBe("Car");
         * expect(providers[0].dependencies.length).toEqual(1);
         * expect(providers[0].factory).toBeDefined();
         *
         * expect(providers[1].key.displayName).toBe("Engine");
         * });
         * ```
         *
         * See {\@link ReflectiveInjector#fromResolvedProviders} for more info.
         * @param {?} providers
         * @return {?}
         */
        ReflectiveInjector.resolve = function (providers) {
            return resolveReflectiveProviders(providers);
        };
        /**
         * Resolves an array of providers and creates an injector from those providers.
         *
         * The passed-in providers can be an array of `Type`, {\@link Provider},
         * or a recursive array of more providers.
         *
         * ### Example ([live demo](http://plnkr.co/edit/ePOccA?p=preview))
         *
         * ```typescript
         * \@Injectable()
         * class Engine {
         * }
         *
         * \@Injectable()
         * class Car {
         *   constructor(public engine:Engine) {}
         * }
         *
         * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);
         * expect(injector.get(Car) instanceof Car).toBe(true);
         * ```
         *
         * This function is slower than the corresponding `fromResolvedProviders`
         * because it needs to resolve the passed-in providers first.
         * See {\@link Injector#resolve} and {\@link Injector#fromResolvedProviders}.
         * @param {?} providers
         * @param {?=} parent
         * @return {?}
         */
        ReflectiveInjector.resolveAndCreate = function (providers, parent) {
            if (parent === void 0) { parent = null; }
            var /** @type {?} */ ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);
            return ReflectiveInjector.fromResolvedProviders(ResolvedReflectiveProviders, parent);
        };
        /**
         * Creates an injector from previously resolved providers.
         *
         * This API is the recommended way to construct injectors in performance-sensitive parts.
         *
         * ### Example ([live demo](http://plnkr.co/edit/KrSMci?p=preview))
         *
         * ```typescript
         * \@Injectable()
         * class Engine {
         * }
         *
         * \@Injectable()
         * class Car {
         *   constructor(public engine:Engine) {}
         * }
         *
         * var providers = ReflectiveInjector.resolve([Car, Engine]);
         * var injector = ReflectiveInjector.fromResolvedProviders(providers);
         * expect(injector.get(Car) instanceof Car).toBe(true);
         * ```
         * \@experimental
         * @param {?} providers
         * @param {?=} parent
         * @return {?}
         */
        ReflectiveInjector.fromResolvedProviders = function (providers, parent) {
            if (parent === void 0) { parent = null; }
            return new ReflectiveInjector_(ReflectiveProtoInjector.fromResolvedProviders(providers), parent);
        };
        Object.defineProperty(ReflectiveInjector.prototype, "parent", {
            /**
             * Parent of this injector.
             *
             * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.
             * -->
             *
             * ### Example ([live demo](http://plnkr.co/edit/eosMGo?p=preview))
             *
             * ```typescript
             * var parent = ReflectiveInjector.resolveAndCreate([]);
             * var child = parent.resolveAndCreateChild([]);
             * expect(child.parent).toBe(parent);
             * ```
             * @return {?}
             */
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        /**
         * Resolves an array of providers and creates a child injector from those providers.
         *
         * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.
         * -->
         *
         * The passed-in providers can be an array of `Type`, {\@link Provider},
         * or a recursive array of more providers.
         *
         * ### Example ([live demo](http://plnkr.co/edit/opB3T4?p=preview))
         *
         * ```typescript
         * class ParentProvider {}
         * class ChildProvider {}
         *
         * var parent = ReflectiveInjector.resolveAndCreate([ParentProvider]);
         * var child = parent.resolveAndCreateChild([ChildProvider]);
         *
         * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);
         * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);
         * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));
         * ```
         *
         * This function is slower than the corresponding `createChildFromResolved`
         * because it needs to resolve the passed-in providers first.
         * See {\@link Injector#resolve} and {\@link Injector#createChildFromResolved}.
         * @param {?} providers
         * @return {?}
         */
        ReflectiveInjector.prototype.resolveAndCreateChild = function (providers) { return unimplemented(); };
        /**
         * Creates a child injector from previously resolved providers.
         *
         * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.
         * -->
         *
         * This API is the recommended way to construct injectors in performance-sensitive parts.
         *
         * ### Example ([live demo](http://plnkr.co/edit/VhyfjN?p=preview))
         *
         * ```typescript
         * class ParentProvider {}
         * class ChildProvider {}
         *
         * var parentProviders = ReflectiveInjector.resolve([ParentProvider]);
         * var childProviders = ReflectiveInjector.resolve([ChildProvider]);
         *
         * var parent = ReflectiveInjector.fromResolvedProviders(parentProviders);
         * var child = parent.createChildFromResolved(childProviders);
         *
         * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);
         * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);
         * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));
         * ```
         * @param {?} providers
         * @return {?}
         */
        ReflectiveInjector.prototype.createChildFromResolved = function (providers) {
            return unimplemented();
        };
        /**
         * Resolves a provider and instantiates an object in the context of the injector.
         *
         * The created object does not get cached by the injector.
         *
         * ### Example ([live demo](http://plnkr.co/edit/yvVXoB?p=preview))
         *
         * ```typescript
         * \@Injectable()
         * class Engine {
         * }
         *
         * \@Injectable()
         * class Car {
         *   constructor(public engine:Engine) {}
         * }
         *
         * var injector = ReflectiveInjector.resolveAndCreate([Engine]);
         *
         * var car = injector.resolveAndInstantiate(Car);
         * expect(car.engine).toBe(injector.get(Engine));
         * expect(car).not.toBe(injector.resolveAndInstantiate(Car));
         * ```
         * @param {?} provider
         * @return {?}
         */
        ReflectiveInjector.prototype.resolveAndInstantiate = function (provider) { return unimplemented(); };
        /**
         * Instantiates an object using a resolved provider in the context of the injector.
         *
         * The created object does not get cached by the injector.
         *
         * ### Example ([live demo](http://plnkr.co/edit/ptCImQ?p=preview))
         *
         * ```typescript
         * \@Injectable()
         * class Engine {
         * }
         *
         * \@Injectable()
         * class Car {
         *   constructor(public engine:Engine) {}
         * }
         *
         * var injector = ReflectiveInjector.resolveAndCreate([Engine]);
         * var carProvider = ReflectiveInjector.resolve([Car])[0];
         * var car = injector.instantiateResolved(carProvider);
         * expect(car.engine).toBe(injector.get(Engine));
         * expect(car).not.toBe(injector.instantiateResolved(carProvider));
         * ```
         * @param {?} provider
         * @return {?}
         */
        ReflectiveInjector.prototype.instantiateResolved = function (provider) { return unimplemented(); };
        /**
         * @abstract
         * @param {?} token
         * @param {?=} notFoundValue
         * @return {?}
         */
        ReflectiveInjector.prototype.get = function (token, notFoundValue) { };
        return ReflectiveInjector;
    }());
    var ReflectiveInjector_ = (function () {
        /**
         * Private
         * @param {?} _proto
         * @param {?=} _parent
         */
        function ReflectiveInjector_(_proto /* ProtoInjector */, _parent) {
            if (_parent === void 0) { _parent = null; }
            /** @internal */
            this._constructionCounter = 0;
            this._proto = _proto;
            this._parent = _parent;
            this._strategy = _proto._strategy.createInjectorStrategy(this);
        }
        /**
         * @param {?} token
         * @param {?=} notFoundValue
         * @return {?}
         */
        ReflectiveInjector_.prototype.get = function (token, notFoundValue) {
            if (notFoundValue === void 0) { notFoundValue = THROW_IF_NOT_FOUND; }
            return this._getByKey(ReflectiveKey.get(token), null, null, notFoundValue);
        };
        /**
         * @param {?} index
         * @return {?}
         */
        ReflectiveInjector_.prototype.getAt = function (index) { return this._strategy.getObjAtIndex(index); };
        Object.defineProperty(ReflectiveInjector_.prototype, "parent", {
            /**
             * @return {?}
             */
            get: function () { return this._parent; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ReflectiveInjector_.prototype, "internalStrategy", {
            /**
             * \@internal
             * Internal. Do not use.
             * We return `any` not to export the InjectorStrategy type.
             * @return {?}
             */
            get: function () { return this._strategy; },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} providers
         * @return {?}
         */
        ReflectiveInjector_.prototype.resolveAndCreateChild = function (providers) {
            var /** @type {?} */ ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);
            return this.createChildFromResolved(ResolvedReflectiveProviders);
        };
        /**
         * @param {?} providers
         * @return {?}
         */
        ReflectiveInjector_.prototype.createChildFromResolved = function (providers) {
            var /** @type {?} */ proto = new ReflectiveProtoInjector(providers);
            var /** @type {?} */ inj = new ReflectiveInjector_(proto);
            inj._parent = this;
            return inj;
        };
        /**
         * @param {?} provider
         * @return {?}
         */
        ReflectiveInjector_.prototype.resolveAndInstantiate = function (provider) {
            return this.instantiateResolved(ReflectiveInjector.resolve([provider])[0]);
        };
        /**
         * @param {?} provider
         * @return {?}
         */
        ReflectiveInjector_.prototype.instantiateResolved = function (provider) {
            return this._instantiateProvider(provider);
        };
        /**
         * \@internal
         * @param {?} provider
         * @return {?}
         */
        ReflectiveInjector_.prototype._new = function (provider) {
            if (this._constructionCounter++ > this._strategy.getMaxNumberOfObjects()) {
                throw new CyclicDependencyError(this, provider.key);
            }
            return this._instantiateProvider(provider);
        };
        /**
         * @param {?} provider
         * @return {?}
         */
        ReflectiveInjector_.prototype._instantiateProvider = function (provider) {
            if (provider.multiProvider) {
                var /** @type {?} */ res = new Array(provider.resolvedFactories.length);
                for (var /** @type {?} */ i = 0; i < provider.resolvedFactories.length; ++i) {
                    res[i] = this._instantiate(provider, provider.resolvedFactories[i]);
                }
                return res;
            }
            else {
                return this._instantiate(provider, provider.resolvedFactories[0]);
            }
        };
        /**
         * @param {?} provider
         * @param {?} ResolvedReflectiveFactory
         * @return {?}
         */
        ReflectiveInjector_.prototype._instantiate = function (provider, ResolvedReflectiveFactory) {
            var /** @type {?} */ factory = ResolvedReflectiveFactory.factory;
            var /** @type {?} */ deps = ResolvedReflectiveFactory.dependencies;
            var /** @type {?} */ length = deps.length;
            var /** @type {?} */ d0;
            var /** @type {?} */ d1;
            var /** @type {?} */ d2;
            var /** @type {?} */ d3;
            var /** @type {?} */ d4;
            var /** @type {?} */ d5;
            var /** @type {?} */ d6;
            var /** @type {?} */ d7;
            var /** @type {?} */ d8;
            var /** @type {?} */ d9;
            var /** @type {?} */ d10;
            var /** @type {?} */ d11;
            var /** @type {?} */ d12;
            var /** @type {?} */ d13;
            var /** @type {?} */ d14;
            var /** @type {?} */ d15;
            var /** @type {?} */ d16;
            var /** @type {?} */ d17;
            var /** @type {?} */ d18;
            var /** @type {?} */ d19;
            try {
                d0 = length > 0 ? this._getByReflectiveDependency(provider, deps[0]) : null;
                d1 = length > 1 ? this._getByReflectiveDependency(provider, deps[1]) : null;
                d2 = length > 2 ? this._getByReflectiveDependency(provider, deps[2]) : null;
                d3 = length > 3 ? this._getByReflectiveDependency(provider, deps[3]) : null;
                d4 = length > 4 ? this._getByReflectiveDependency(provider, deps[4]) : null;
                d5 = length > 5 ? this._getByReflectiveDependency(provider, deps[5]) : null;
                d6 = length > 6 ? this._getByReflectiveDependency(provider, deps[6]) : null;
                d7 = length > 7 ? this._getByReflectiveDependency(provider, deps[7]) : null;
                d8 = length > 8 ? this._getByReflectiveDependency(provider, deps[8]) : null;
                d9 = length > 9 ? this._getByReflectiveDependency(provider, deps[9]) : null;
                d10 = length > 10 ? this._getByReflectiveDependency(provider, deps[10]) : null;
                d11 = length > 11 ? this._getByReflectiveDependency(provider, deps[11]) : null;
                d12 = length > 12 ? this._getByReflectiveDependency(provider, deps[12]) : null;
                d13 = length > 13 ? this._getByReflectiveDependency(provider, deps[13]) : null;
                d14 = length > 14 ? this._getByReflectiveDependency(provider, deps[14]) : null;
                d15 = length > 15 ? this._getByReflectiveDependency(provider, deps[15]) : null;
                d16 = length > 16 ? this._getByReflectiveDependency(provider, deps[16]) : null;
                d17 = length > 17 ? this._getByReflectiveDependency(provider, deps[17]) : null;
                d18 = length > 18 ? this._getByReflectiveDependency(provider, deps[18]) : null;
                d19 = length > 19 ? this._getByReflectiveDependency(provider, deps[19]) : null;
            }
            catch (e) {
                if (e instanceof AbstractProviderError || e instanceof InstantiationError) {
                    e.addKey(this, provider.key);
                }
                throw e;
            }
            var /** @type {?} */ obj;
            try {
                switch (length) {
                    case 0:
                        obj = factory();
                        break;
                    case 1:
                        obj = factory(d0);
                        break;
                    case 2:
                        obj = factory(d0, d1);
                        break;
                    case 3:
                        obj = factory(d0, d1, d2);
                        break;
                    case 4:
                        obj = factory(d0, d1, d2, d3);
                        break;
                    case 5:
                        obj = factory(d0, d1, d2, d3, d4);
                        break;
                    case 6:
                        obj = factory(d0, d1, d2, d3, d4, d5);
                        break;
                    case 7:
                        obj = factory(d0, d1, d2, d3, d4, d5, d6);
                        break;
                    case 8:
                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7);
                        break;
                    case 9:
                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8);
                        break;
                    case 10:
                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9);
                        break;
                    case 11:
                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10);
                        break;
                    case 12:
                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11);
                        break;
                    case 13:
                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12);
                        break;
                    case 14:
                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13);
                        break;
                    case 15:
                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14);
                        break;
                    case 16:
                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15);
                        break;
                    case 17:
                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16);
                        break;
                    case 18:
                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17);
                        break;
                    case 19:
                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17, d18);
                        break;
                    case 20:
                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17, d18, d19);
                        break;
                    default:
                        throw new Error("Cannot instantiate '" + provider.key.displayName + "' because it has more than 20 dependencies");
                }
            }
            catch (e) {
                throw new InstantiationError(this, e, e.stack, provider.key);
            }
            return obj;
        };
        /**
         * @param {?} provider
         * @param {?} dep
         * @return {?}
         */
        ReflectiveInjector_.prototype._getByReflectiveDependency = function (provider, dep) {
            return this._getByKey(dep.key, dep.lowerBoundVisibility, dep.upperBoundVisibility, dep.optional ? null : THROW_IF_NOT_FOUND);
        };
        /**
         * @param {?} key
         * @param {?} lowerBoundVisibility
         * @param {?} upperBoundVisibility
         * @param {?} notFoundValue
         * @return {?}
         */
        ReflectiveInjector_.prototype._getByKey = function (key, lowerBoundVisibility, upperBoundVisibility, notFoundValue) {
            if (key === INJECTOR_KEY) {
                return this;
            }
            if (upperBoundVisibility instanceof Self) {
                return this._getByKeySelf(key, notFoundValue);
            }
            else {
                return this._getByKeyDefault(key, notFoundValue, lowerBoundVisibility);
            }
        };
        /**
         * \@internal
         * @param {?} key
         * @param {?} notFoundValue
         * @return {?}
         */
        ReflectiveInjector_.prototype._throwOrNull = function (key, notFoundValue) {
            if (notFoundValue !== THROW_IF_NOT_FOUND) {
                return notFoundValue;
            }
            else {
                throw new NoProviderError(this, key);
            }
        };
        /**
         * \@internal
         * @param {?} key
         * @param {?} notFoundValue
         * @return {?}
         */
        ReflectiveInjector_.prototype._getByKeySelf = function (key, notFoundValue) {
            var /** @type {?} */ obj = this._strategy.getObjByKeyId(key.id);
            return (obj !== UNDEFINED) ? obj : this._throwOrNull(key, notFoundValue);
        };
        /**
         * \@internal
         * @param {?} key
         * @param {?} notFoundValue
         * @param {?} lowerBoundVisibility
         * @return {?}
         */
        ReflectiveInjector_.prototype._getByKeyDefault = function (key, notFoundValue, lowerBoundVisibility) {
            var /** @type {?} */ inj;
            if (lowerBoundVisibility instanceof SkipSelf) {
                inj = this._parent;
            }
            else {
                inj = this;
            }
            while (inj instanceof ReflectiveInjector_) {
                var /** @type {?} */ inj_ = (inj);
                var /** @type {?} */ obj = inj_._strategy.getObjByKeyId(key.id);
                if (obj !== UNDEFINED)
                    return obj;
                inj = inj_._parent;
            }
            if (inj !== null) {
                return inj.get(key.token, notFoundValue);
            }
            else {
                return this._throwOrNull(key, notFoundValue);
            }
        };
        Object.defineProperty(ReflectiveInjector_.prototype, "displayName", {
            /**
             * @return {?}
             */
            get: function () {
                var /** @type {?} */ providers = _mapProviders(this, function (b) { return ' "' + b.key.displayName + '" '; })
                    .join(', ');
                return "ReflectiveInjector(providers: [" + providers + "])";
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ReflectiveInjector_.prototype.toString = function () { return this.displayName; };
        return ReflectiveInjector_;
    }());
    var /** @type {?} */ INJECTOR_KEY = ReflectiveKey.get(Injector);
    /**
     * @param {?} injector
     * @param {?} fn
     * @return {?}
     */
    function _mapProviders(injector, fn) {
        var /** @type {?} */ res = new Array(injector._proto.numberOfProviders);
        for (var /** @type {?} */ i = 0; i < injector._proto.numberOfProviders; ++i) {
            res[i] = fn(injector._proto.getProviderAtIndex(i));
        }
        return res;
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * \@whatItDoes Provides a hook for centralized exception handling.
     *
     * \@description
     *
     * The default implementation of `ErrorHandler` prints error messages to the `console`. To
     * intercept error handling, write a custom exception handler that replaces this default as
     * appropriate for your app.
     *
     * ### Example
     *
     * ```
     * class MyErrorHandler implements ErrorHandler {
     *   handleError(error) {
     *     // do something with the exception
     *   }
     * }
     *
     * \@NgModule({
     *   providers: [{provide: ErrorHandler, useClass: MyErrorHandler}]
     * })
     * class MyModule {}
     * ```
     *
     * \@stable
     */
    var ErrorHandler = (function () {
        /**
         * @param {?=} rethrowError
         */
        function ErrorHandler(rethrowError) {
            if (rethrowError === void 0) { rethrowError = true; }
            /**
             * @internal
             */
            this._console = console;
            this.rethrowError = rethrowError;
        }
        /**
         * @param {?} error
         * @return {?}
         */
        ErrorHandler.prototype.handleError = function (error) {
            var /** @type {?} */ originalError = this._findOriginalError(error);
            var /** @type {?} */ originalStack = this._findOriginalStack(error);
            var /** @type {?} */ context = this._findContext(error);
            this._console.error("EXCEPTION: " + this._extractMessage(error));
            if (originalError) {
                this._console.error("ORIGINAL EXCEPTION: " + this._extractMessage(originalError));
            }
            if (originalStack) {
                this._console.error('ORIGINAL STACKTRACE:');
                this._console.error(originalStack);
            }
            if (context) {
                this._console.error('ERROR CONTEXT:');
                this._console.error(context);
            }
            // We rethrow exceptions, so operations like 'bootstrap' will result in an error
            // when an error happens. If we do not rethrow, bootstrap will always succeed.
            if (this.rethrowError)
                throw error;
        };
        /**
         * \@internal
         * @param {?} error
         * @return {?}
         */
        ErrorHandler.prototype._extractMessage = function (error) {
            return error instanceof Error ? error.message : error.toString();
        };
        /**
         * \@internal
         * @param {?} error
         * @return {?}
         */
        ErrorHandler.prototype._findContext = function (error) {
            if (error) {
                return error.context ? error.context :
                    this._findContext(((error)).originalError);
            }
            return null;
        };
        /**
         * \@internal
         * @param {?} error
         * @return {?}
         */
        ErrorHandler.prototype._findOriginalError = function (error) {
            var /** @type {?} */ e = ((error)).originalError;
            while (e && ((e)).originalError) {
                e = ((e)).originalError;
            }
            return e;
        };
        /**
         * \@internal
         * @param {?} error
         * @return {?}
         */
        ErrorHandler.prototype._findOriginalStack = function (error) {
            if (!(error instanceof Error))
                return null;
            var /** @type {?} */ e = error;
            var /** @type {?} */ stack = e.stack;
            while (e instanceof Error && ((e)).originalError) {
                e = ((e)).originalError;
                if (e instanceof Error && e.stack) {
                    stack = e.stack;
                }
            }
            return stack;
        };
        return ErrorHandler;
    }());

    /**
     * Wraps Javascript Objects
     */
    var StringMapWrapper = (function () {
        function StringMapWrapper() {
        }
        /**
         * @param {?} m1
         * @param {?} m2
         * @return {?}
         */
        StringMapWrapper.merge = function (m1, m2) {
            var /** @type {?} */ m = {};
            for (var _i = 0, _a = Object.keys(m1); _i < _a.length; _i++) {
                var k = _a[_i];
                m[k] = m1[k];
            }
            for (var _b = 0, _c = Object.keys(m2); _b < _c.length; _b++) {
                var k = _c[_b];
                m[k] = m2[k];
            }
            return m;
        };
        /**
         * @param {?} m1
         * @param {?} m2
         * @return {?}
         */
        StringMapWrapper.equals = function (m1, m2) {
            var /** @type {?} */ k1 = Object.keys(m1);
            var /** @type {?} */ k2 = Object.keys(m2);
            if (k1.length != k2.length) {
                return false;
            }
            for (var /** @type {?} */ i = 0; i < k1.length; i++) {
                var /** @type {?} */ key = k1[i];
                if (m1[key] !== m2[key]) {
                    return false;
                }
            }
            return true;
        };
        return StringMapWrapper;
    }());
    var ListWrapper = (function () {
        function ListWrapper() {
        }
        /**
         * @param {?} arr
         * @param {?} condition
         * @return {?}
         */
        ListWrapper.findLast = function (arr, condition) {
            for (var /** @type {?} */ i = arr.length - 1; i >= 0; i--) {
                if (condition(arr[i])) {
                    return arr[i];
                }
            }
            return null;
        };
        /**
         * @param {?} list
         * @param {?} items
         * @return {?}
         */
        ListWrapper.removeAll = function (list, items) {
            for (var /** @type {?} */ i = 0; i < items.length; ++i) {
                var /** @type {?} */ index = list.indexOf(items[i]);
                if (index > -1) {
                    list.splice(index, 1);
                }
            }
        };
        /**
         * @param {?} list
         * @param {?} el
         * @return {?}
         */
        ListWrapper.remove = function (list, el) {
            var /** @type {?} */ index = list.indexOf(el);
            if (index > -1) {
                list.splice(index, 1);
                return true;
            }
            return false;
        };
        /**
         * @param {?} a
         * @param {?} b
         * @return {?}
         */
        ListWrapper.equals = function (a, b) {
            if (a.length != b.length)
                return false;
            for (var /** @type {?} */ i = 0; i < a.length; ++i) {
                if (a[i] !== b[i])
                    return false;
            }
            return true;
        };
        /**
         * @param {?} list
         * @return {?}
         */
        ListWrapper.flatten = function (list) {
            return list.reduce(function (flat, item) {
                var /** @type {?} */ flatItem = Array.isArray(item) ? ListWrapper.flatten(item) : item;
                return ((flat)).concat(flatItem);
            }, []);
        };
        return ListWrapper;
    }());
    /**
     * @param {?} obj
     * @return {?}
     */
    function isListLikeIterable(obj) {
        if (!isJsObject(obj))
            return false;
        return Array.isArray(obj) ||
            (!(obj instanceof Map) &&
                getSymbolIterator() in obj); // JS Iterable have a Symbol.iterator prop
    }
    /**
     * @param {?} a
     * @param {?} b
     * @param {?} comparator
     * @return {?}
     */
    function areIterablesEqual(a, b, comparator) {
        var /** @type {?} */ iterator1 = a[getSymbolIterator()]();
        var /** @type {?} */ iterator2 = b[getSymbolIterator()]();
        while (true) {
            var /** @type {?} */ item1 = iterator1.next();
            var /** @type {?} */ item2 = iterator2.next();
            if (item1.done && item2.done)
                return true;
            if (item1.done || item2.done)
                return false;
            if (!comparator(item1.value, item2.value))
                return false;
        }
    }
    /**
     * @param {?} obj
     * @param {?} fn
     * @return {?}
     */
    function iterateListLike(obj, fn) {
        if (Array.isArray(obj)) {
            for (var /** @type {?} */ i = 0; i < obj.length; i++) {
                fn(obj[i]);
            }
        }
        else {
            var /** @type {?} */ iterator = obj[getSymbolIterator()]();
            var /** @type {?} */ item = void 0;
            while (!((item = iterator.next()).done)) {
                fn(item.value);
            }
        }
    }

    /**
     * Determine if the argument is shaped like a Promise
     * @param {?} obj
     * @return {?}
     */
    function isPromise(obj) {
        // allow any Promise/A+ compliant thenable.
        // It's up to the caller to ensure that obj.then conforms to the spec
        return !!obj && typeof obj.then === 'function';
    }

    /**
     * A function that will be executed when an application is initialized.
     * @experimental
     */
    var /** @type {?} */ APP_INITIALIZER = new OpaqueToken('Application Initializer');
    /**
     * A class that reflects the state of running {\@link APP_INITIALIZER}s.
     *
     * \@experimental
     */
    var ApplicationInitStatus = (function () {
        /**
         * @param {?} appInits
         */
        function ApplicationInitStatus(appInits) {
            var _this = this;
            this._done = false;
            var asyncInitPromises = [];
            if (appInits) {
                for (var i = 0; i < appInits.length; i++) {
                    var initResult = appInits[i]();
                    if (isPromise(initResult)) {
                        asyncInitPromises.push(initResult);
                    }
                }
            }
            this._donePromise = Promise.all(asyncInitPromises).then(function () { _this._done = true; });
            if (asyncInitPromises.length === 0) {
                this._done = true;
            }
        }
        Object.defineProperty(ApplicationInitStatus.prototype, "done", {
            /**
             * @return {?}
             */
            get: function () { return this._done; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ApplicationInitStatus.prototype, "donePromise", {
            /**
             * @return {?}
             */
            get: function () { return this._donePromise; },
            enumerable: true,
            configurable: true
        });
        ApplicationInitStatus.decorators = [
            { type: Injectable },
        ];
        /** @nocollapse */
        ApplicationInitStatus.ctorParameters = function () { return [
            { type: Array, decorators: [{ type: Inject, args: [APP_INITIALIZER,] }, { type: Optional },] },
        ]; };
        return ApplicationInitStatus;
    }());

    /**
     * A DI Token representing a unique string id assigned to the application by Angular and used
     * primarily for prefixing application attributes and CSS styles when
     * {@link ViewEncapsulation#Emulated} is being used.
     *
     * If you need to avoid randomly generated value to be used as an application id, you can provide
     * a custom value via a DI provider <!-- TODO: provider --> configuring the root {@link Injector}
     * using this token.
     * @experimental
     */
    var /** @type {?} */ APP_ID = new OpaqueToken('AppId');
    /**
     * @return {?}
     */
    function _appIdRandomProviderFactory() {
        return "" + _randomChar() + _randomChar() + _randomChar();
    }
    /**
     * Providers that will generate a random APP_ID_TOKEN.
     * @experimental
     */
    var /** @type {?} */ APP_ID_RANDOM_PROVIDER = {
        provide: APP_ID,
        useFactory: _appIdRandomProviderFactory,
        deps: /** @type {?} */ ([]),
    };
    /**
     * @return {?}
     */
    function _randomChar() {
        return String.fromCharCode(97 + Math.floor(Math.random() * 25));
    }
    /**
     * A function that will be executed when a platform is initialized.
     * @experimental
     */
    var /** @type {?} */ PLATFORM_INITIALIZER = new OpaqueToken('Platform Initializer');
    /**
     * All callbacks provided via this token will be called for every component that is bootstrapped.
     * Signature of the callback:
     *
     * `(componentRef: ComponentRef) => void`.
     *
     * @experimental
     */
    var /** @type {?} */ APP_BOOTSTRAP_LISTENER = new OpaqueToken('appBootstrapListener');
    /**
     * A token which indicates the root directory of the application
     * @experimental
     */
    var /** @type {?} */ PACKAGE_ROOT_URL = new OpaqueToken('Application Packages Root URL');

    var Console = (function () {
        function Console() {
        }
        /**
         * @param {?} message
         * @return {?}
         */
        Console.prototype.log = function (message) { print(message); };
        /**
         * @param {?} message
         * @return {?}
         */
        Console.prototype.warn = function (message) { warn(message); };
        Console.decorators = [
            { type: Injectable },
        ];
        /** @nocollapse */
        Console.ctorParameters = function () { return []; };
        return Console;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$4 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * Indicates that a component is still being loaded in a synchronous compile.
     *
     * \@stable
     */
    var ComponentStillLoadingError = (function (_super) {
        __extends$4(ComponentStillLoadingError, _super);
        /**
         * @param {?} compType
         */
        function ComponentStillLoadingError(compType) {
            _super.call(this, "Can't compile synchronously as " + stringify(compType) + " is still being loaded!");
            this.compType = compType;
        }
        return ComponentStillLoadingError;
    }(BaseError));
    /**
     * Combination of NgModuleFactory and ComponentFactorys.
     *
     * \@experimental
     */
    var ModuleWithComponentFactories = (function () {
        /**
         * @param {?} ngModuleFactory
         * @param {?} componentFactories
         */
        function ModuleWithComponentFactories(ngModuleFactory, componentFactories) {
            this.ngModuleFactory = ngModuleFactory;
            this.componentFactories = componentFactories;
        }
        return ModuleWithComponentFactories;
    }());
    /**
     * @return {?}
     */
    function _throwError() {
        throw new Error("Runtime compiler is not loaded");
    }
    /**
     * Low-level service for running the angular compiler during runtime
     * to create {\@link ComponentFactory}s, which
     * can later be used to create and render a Component instance.
     *
     * Each `\@NgModule` provides an own `Compiler` to its injector,
     * that will use the directives/pipes of the ng module for compilation
     * of components.
     * \@stable
     */
    var Compiler = (function () {
        function Compiler() {
        }
        /**
         * Compiles the given NgModule and all of its components. All templates of the components listed
         * in `entryComponents`
         * have to be inlined. Otherwise throws a {\@link ComponentStillLoadingError}.
         * @param {?} moduleType
         * @return {?}
         */
        Compiler.prototype.compileModuleSync = function (moduleType) { throw _throwError(); };
        /**
         * Compiles the given NgModule and all of its components
         * @param {?} moduleType
         * @return {?}
         */
        Compiler.prototype.compileModuleAsync = function (moduleType) { throw _throwError(); };
        /**
         * Same as {\@link compileModuleSync} but also creates ComponentFactories for all components.
         * @param {?} moduleType
         * @return {?}
         */
        Compiler.prototype.compileModuleAndAllComponentsSync = function (moduleType) {
            throw _throwError();
        };
        /**
         * Same as {\@link compileModuleAsync} but also creates ComponentFactories for all components.
         * @param {?} moduleType
         * @return {?}
         */
        Compiler.prototype.compileModuleAndAllComponentsAsync = function (moduleType) {
            throw _throwError();
        };
        /**
         * Exposes the CSS-style selectors that have been used in `ngContent` directives within
         * the template of the given component.
         * This is used by the `upgrade` library to compile the appropriate transclude content
         * in the Angular 1 wrapper component.
         * @param {?} component
         * @return {?}
         */
        Compiler.prototype.getNgContentSelectors = function (component) { throw _throwError(); };
        /**
         * Clears all caches.
         * @return {?}
         */
        Compiler.prototype.clearCache = function () { };
        /**
         * Clears the cache for the given component/ngModule.
         * @param {?} type
         * @return {?}
         */
        Compiler.prototype.clearCacheFor = function (type) { };
        Compiler.decorators = [
            { type: Injectable },
        ];
        /** @nocollapse */
        Compiler.ctorParameters = function () { return []; };
        return Compiler;
    }());
    /**
     * Token to provide CompilerOptions in the platform injector.
     *
     * @experimental
     */
    var /** @type {?} */ COMPILER_OPTIONS = new OpaqueToken('compilerOptions');
    /**
     * A factory for creating a Compiler
     *
     * \@experimental
     * @abstract
     */
    var CompilerFactory = (function () {
        function CompilerFactory() {
        }
        /**
         * @abstract
         * @param {?=} options
         * @return {?}
         */
        CompilerFactory.prototype.createCompiler = function (options) { };
        return CompilerFactory;
    }());

    var ElementRef = (function () {
        /**
         * @param {?} nativeElement
         */
        function ElementRef(nativeElement) {
            this.nativeElement = nativeElement;
        }
        return ElementRef;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$6 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * Use by directives and components to emit custom Events.
     *
     * ### Examples
     *
     * In the following example, `Zippy` alternatively emits `open` and `close` events when its
     * title gets clicked:
     *
     * ```
     * \@Component({
     *   selector: 'zippy',
     *   template: `
     *   <div class="zippy">
     *     <div (click)="toggle()">Toggle</div>
     *     <div [hidden]="!visible">
     *       <ng-content></ng-content>
     *     </div>
     *  </div>`})
     * export class Zippy {
     *   visible: boolean = true;
     *   \@Output() open: EventEmitter<any> = new EventEmitter();
     *   \@Output() close: EventEmitter<any> = new EventEmitter();
     *
     *   toggle() {
     *     this.visible = !this.visible;
     *     if (this.visible) {
     *       this.open.emit(null);
     *     } else {
     *       this.close.emit(null);
     *     }
     *   }
     * }
     * ```
     *
     * The events payload can be accessed by the parameter `$event` on the components output event
     * handler:
     *
     * ```
     * <zippy (open)="onOpen($event)" (close)="onClose($event)"></zippy>
     * ```
     *
     * Uses Rx.Observable but provides an adapter to make it work as specified here:
     * https://github.com/jhusain/observable-spec
     *
     * Once a reference implementation of the spec is available, switch to it.
     * \@stable
     */
    var EventEmitter = (function (_super) {
        __extends$6(EventEmitter, _super);
        /**
         * Creates an instance of [EventEmitter], which depending on [isAsync],
         * delivers events synchronously or asynchronously.
         * @param {?=} isAsync
         */
        function EventEmitter(isAsync) {
            if (isAsync === void 0) { isAsync = false; }
            _super.call(this);
            this.__isAsync = isAsync;
        }
        /**
         * @param {?=} value
         * @return {?}
         */
        EventEmitter.prototype.emit = function (value) { _super.prototype.next.call(this, value); };
        /**
         * @param {?=} generatorOrNext
         * @param {?=} error
         * @param {?=} complete
         * @return {?}
         */
        EventEmitter.prototype.subscribe = function (generatorOrNext, error, complete) {
            var /** @type {?} */ schedulerFn;
            var /** @type {?} */ errorFn = function (err) { return null; };
            var /** @type {?} */ completeFn = function () { return null; };
            if (generatorOrNext && typeof generatorOrNext === 'object') {
                schedulerFn = this.__isAsync ? function (value) {
                    setTimeout(function () { return generatorOrNext.next(value); });
                } : function (value) { generatorOrNext.next(value); };
                if (generatorOrNext.error) {
                    errorFn = this.__isAsync ? function (err) { setTimeout(function () { return generatorOrNext.error(err); }); } :
                        function (err) { generatorOrNext.error(err); };
                }
                if (generatorOrNext.complete) {
                    completeFn = this.__isAsync ? function () { setTimeout(function () { return generatorOrNext.complete(); }); } :
                        function () { generatorOrNext.complete(); };
                }
            }
            else {
                schedulerFn = this.__isAsync ? function (value) { setTimeout(function () { return generatorOrNext(value); }); } :
                    function (value) { generatorOrNext(value); };
                if (error) {
                    errorFn =
                        this.__isAsync ? function (err) { setTimeout(function () { return error(err); }); } : function (err) { error(err); };
                }
                if (complete) {
                    completeFn =
                        this.__isAsync ? function () { setTimeout(function () { return complete(); }); } : function () { complete(); };
                }
            }
            return _super.prototype.subscribe.call(this, schedulerFn, errorFn, completeFn);
        };
        return EventEmitter;
    }(rxjs_Subject.Subject));

    /**
     * An injectable service for executing work inside or outside of the Angular zone.
     *
     * The most common use of this service is to optimize performance when starting a work consisting of
     * one or more asynchronous tasks that don't require UI updates or error handling to be handled by
     * Angular. Such tasks can be kicked off via {\@link runOutsideAngular} and if needed, these tasks
     * can reenter the Angular zone via {\@link run}.
     *
     * <!-- TODO: add/fix links to:
     *   - docs explaining zones and the use of zones in Angular and change-detection
     *   - link to runOutsideAngular/run (throughout this file!)
     *   -->
     *
     * ### Example
     * ```
     * import {Component, NgZone} from '\@angular/core';
     * import {NgIf} from '\@angular/common';
     *
     * \@Component({
     *   selector: 'ng-zone-demo'.
     *   template: `
     *     <h2>Demo: NgZone</h2>
     *
     *     <p>Progress: {{progress}}%</p>
     *     <p *ngIf="progress >= 100">Done processing {{label}} of Angular zone!</p>
     *
     *     <button (click)="processWithinAngularZone()">Process within Angular zone</button>
     *     <button (click)="processOutsideOfAngularZone()">Process outside of Angular zone</button>
     *   `,
     * })
     * export class NgZoneDemo {
     *   progress: number = 0;
     *   label: string;
     *
     *   constructor(private _ngZone: NgZone) {}
     *
     *   // Loop inside the Angular zone
     *   // so the UI DOES refresh after each setTimeout cycle
     *   processWithinAngularZone() {
     *     this.label = 'inside';
     *     this.progress = 0;
     *     this._increaseProgress(() => console.log('Inside Done!'));
     *   }
     *
     *   // Loop outside of the Angular zone
     *   // so the UI DOES NOT refresh after each setTimeout cycle
     *   processOutsideOfAngularZone() {
     *     this.label = 'outside';
     *     this.progress = 0;
     *     this._ngZone.runOutsideAngular(() => {
     *       this._increaseProgress(() => {
     *       // reenter the Angular zone and display done
     *       this._ngZone.run(() => {console.log('Outside Done!') });
     *     }}));
     *   }
     *
     *   _increaseProgress(doneCallback: () => void) {
     *     this.progress += 1;
     *     console.log(`Current progress: ${this.progress}%`);
     *
     *     if (this.progress < 100) {
     *       window.setTimeout(() => this._increaseProgress(doneCallback)), 10)
     *     } else {
     *       doneCallback();
     *     }
     *   }
     * }
     * ```
     * \@experimental
     */
    var NgZone = (function () {
        /**
         * @param {?} __0
         */
        function NgZone(_a) {
            var _b = _a.enableLongStackTrace, enableLongStackTrace = _b === void 0 ? false : _b;
            this._hasPendingMicrotasks = false;
            this._hasPendingMacrotasks = false;
            this._isStable = true;
            this._nesting = 0;
            this._onUnstable = new EventEmitter(false);
            this._onMicrotaskEmpty = new EventEmitter(false);
            this._onStable = new EventEmitter(false);
            this._onErrorEvents = new EventEmitter(false);
            if (typeof Zone == 'undefined') {
                throw new Error('Angular requires Zone.js prolyfill.');
            }
            Zone.assertZonePatched();
            this.outer = this.inner = Zone.current;
            if (Zone['wtfZoneSpec']) {
                this.inner = this.inner.fork(Zone['wtfZoneSpec']);
            }
            if (enableLongStackTrace && Zone['longStackTraceZoneSpec']) {
                this.inner = this.inner.fork(Zone['longStackTraceZoneSpec']);
            }
            this.forkInnerZoneWithAngularBehavior();
        }
        /**
         * @return {?}
         */
        NgZone.isInAngularZone = function () { return Zone.current.get('isAngularZone') === true; };
        /**
         * @return {?}
         */
        NgZone.assertInAngularZone = function () {
            if (!NgZone.isInAngularZone()) {
                throw new Error('Expected to be in Angular Zone, but it is not!');
            }
        };
        /**
         * @return {?}
         */
        NgZone.assertNotInAngularZone = function () {
            if (NgZone.isInAngularZone()) {
                throw new Error('Expected to not be in Angular Zone, but it is!');
            }
        };
        /**
         * Executes the `fn` function synchronously within the Angular zone and returns value returned by
         * the function.
         *
         * Running functions via `run` allows you to reenter Angular zone from a task that was executed
         * outside of the Angular zone (typically started via {\@link runOutsideAngular}).
         *
         * Any future tasks or microtasks scheduled from within this function will continue executing from
         * within the Angular zone.
         *
         * If a synchronous error happens it will be rethrown and not reported via `onError`.
         * @param {?} fn
         * @return {?}
         */
        NgZone.prototype.run = function (fn) { return this.inner.run(fn); };
        /**
         * Same as `run`, except that synchronous errors are caught and forwarded via `onError` and not
         * rethrown.
         * @param {?} fn
         * @return {?}
         */
        NgZone.prototype.runGuarded = function (fn) { return this.inner.runGuarded(fn); };
        /**
         * Executes the `fn` function synchronously in Angular's parent zone and returns value returned by
         * the function.
         *
         * Running functions via `runOutsideAngular` allows you to escape Angular's zone and do work that
         * doesn't trigger Angular change-detection or is subject to Angular's error handling.
         *
         * Any future tasks or microtasks scheduled from within this function will continue executing from
         * outside of the Angular zone.
         *
         * Use {\@link run} to reenter the Angular zone and do work that updates the application model.
         * @param {?} fn
         * @return {?}
         */
        NgZone.prototype.runOutsideAngular = function (fn) { return this.outer.run(fn); };
        Object.defineProperty(NgZone.prototype, "onUnstable", {
            /**
             * Notifies when code enters Angular Zone. This gets fired first on VM Turn.
             * @return {?}
             */
            get: function () { return this._onUnstable; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgZone.prototype, "onMicrotaskEmpty", {
            /**
             * Notifies when there is no more microtasks enqueue in the current VM Turn.
             * This is a hint for Angular to do change detection, which may enqueue more microtasks.
             * For this reason this event can fire multiple times per VM Turn.
             * @return {?}
             */
            get: function () { return this._onMicrotaskEmpty; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgZone.prototype, "onStable", {
            /**
             * Notifies when the last `onMicrotaskEmpty` has run and there are no more microtasks, which
             * implies we are about to relinquish VM turn.
             * This event gets called just once.
             * @return {?}
             */
            get: function () { return this._onStable; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgZone.prototype, "onError", {
            /**
             * Notify that an error has been delivered.
             * @return {?}
             */
            get: function () { return this._onErrorEvents; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgZone.prototype, "isStable", {
            /**
             * Whether there are no outstanding microtasks or macrotasks.
             * @return {?}
             */
            get: function () { return this._isStable; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgZone.prototype, "hasPendingMicrotasks", {
            /**
             * @return {?}
             */
            get: function () { return this._hasPendingMicrotasks; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgZone.prototype, "hasPendingMacrotasks", {
            /**
             * @return {?}
             */
            get: function () { return this._hasPendingMacrotasks; },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NgZone.prototype.checkStable = function () {
            var _this = this;
            if (this._nesting == 0 && !this._hasPendingMicrotasks && !this._isStable) {
                try {
                    this._nesting++;
                    this._onMicrotaskEmpty.emit(null);
                }
                finally {
                    this._nesting--;
                    if (!this._hasPendingMicrotasks) {
                        try {
                            this.runOutsideAngular(function () { return _this._onStable.emit(null); });
                        }
                        finally {
                            this._isStable = true;
                        }
                    }
                }
            }
        };
        /**
         * @return {?}
         */
        NgZone.prototype.forkInnerZoneWithAngularBehavior = function () {
            var _this = this;
            this.inner = this.inner.fork({
                name: 'angular',
                properties: /** @type {?} */ ({ 'isAngularZone': true }),
                onInvokeTask: function (delegate, current, target, task, applyThis, applyArgs) {
                    try {
                        _this.onEnter();
                        return delegate.invokeTask(target, task, applyThis, applyArgs);
                    }
                    finally {
                        _this.onLeave();
                    }
                },
                onInvoke: function (delegate, current, target, callback, applyThis, applyArgs, source) {
                    try {
                        _this.onEnter();
                        return delegate.invoke(target, callback, applyThis, applyArgs, source);
                    }
                    finally {
                        _this.onLeave();
                    }
                },
                onHasTask: function (delegate, current, target, hasTaskState) {
                    delegate.hasTask(target, hasTaskState);
                    if (current === target) {
                        // We are only interested in hasTask events which originate from our zone
                        // (A child hasTask event is not interesting to us)
                        if (hasTaskState.change == 'microTask') {
                            _this.setHasMicrotask(hasTaskState.microTask);
                        }
                        else if (hasTaskState.change == 'macroTask') {
                            _this.setHasMacrotask(hasTaskState.macroTask);
                        }
                    }
                },
                onHandleError: function (delegate, current, target, error) {
                    delegate.handleError(target, error);
                    _this.triggerError(error);
                    return false;
                }
            });
        };
        /**
         * @return {?}
         */
        NgZone.prototype.onEnter = function () {
            this._nesting++;
            if (this._isStable) {
                this._isStable = false;
                this._onUnstable.emit(null);
            }
        };
        /**
         * @return {?}
         */
        NgZone.prototype.onLeave = function () {
            this._nesting--;
            this.checkStable();
        };
        /**
         * @param {?} hasMicrotasks
         * @return {?}
         */
        NgZone.prototype.setHasMicrotask = function (hasMicrotasks) {
            this._hasPendingMicrotasks = hasMicrotasks;
            this.checkStable();
        };
        /**
         * @param {?} hasMacrotasks
         * @return {?}
         */
        NgZone.prototype.setHasMacrotask = function (hasMacrotasks) { this._hasPendingMacrotasks = hasMacrotasks; };
        /**
         * @param {?} error
         * @return {?}
         */
        NgZone.prototype.triggerError = function (error) { this._onErrorEvents.emit(error); };
        return NgZone;
    }());

    var AnimationQueue = (function () {
        /**
         * @param {?} _zone
         */
        function AnimationQueue(_zone) {
            this._zone = _zone;
            this.entries = [];
        }
        /**
         * @param {?} player
         * @return {?}
         */
        AnimationQueue.prototype.enqueue = function (player) { this.entries.push(player); };
        /**
         * @return {?}
         */
        AnimationQueue.prototype.flush = function () {
            var _this = this;
            // given that each animation player may set aside
            // microtasks and rely on DOM-based events, this
            // will cause Angular to run change detection after
            // each request. This sidesteps the issue. If a user
            // hooks into an animation via (@anim.start) or (@anim.done)
            // then those methods will automatically trigger change
            // detection by wrapping themselves inside of a zone
            if (this.entries.length) {
                this._zone.runOutsideAngular(function () {
                    // this code is wrapped into a single promise such that the
                    // onStart and onDone player callbacks are triggered outside
                    // of the digest cycle of animations
                    Promise.resolve(null).then(function () { return _this._triggerAnimations(); });
                });
            }
        };
        /**
         * @return {?}
         */
        AnimationQueue.prototype._triggerAnimations = function () {
            NgZone.assertNotInAngularZone();
            while (this.entries.length) {
                var /** @type {?} */ player = this.entries.shift();
                // in the event that an animation throws an error then we do
                // not want to re-run animations on any previous animations
                // if they have already been kicked off beforehand
                if (!player.hasStarted()) {
                    player.play();
                }
            }
        };
        AnimationQueue.decorators = [
            { type: Injectable },
        ];
        /** @nocollapse */
        AnimationQueue.ctorParameters = function () { return [
            { type: NgZone, },
        ]; };
        return AnimationQueue;
    }());

    var DefaultIterableDifferFactory = (function () {
        function DefaultIterableDifferFactory() {
        }
        /**
         * @param {?} obj
         * @return {?}
         */
        DefaultIterableDifferFactory.prototype.supports = function (obj) { return isListLikeIterable(obj); };
        /**
         * @param {?} cdRef
         * @param {?=} trackByFn
         * @return {?}
         */
        DefaultIterableDifferFactory.prototype.create = function (cdRef, trackByFn) {
            return new DefaultIterableDiffer(trackByFn);
        };
        return DefaultIterableDifferFactory;
    }());
    var /** @type {?} */ trackByIdentity = function (index, item) { return item; };
    /**
     * \@stable
     */
    var DefaultIterableDiffer = (function () {
        /**
         * @param {?=} _trackByFn
         */
        function DefaultIterableDiffer(_trackByFn) {
            this._trackByFn = _trackByFn;
            this._length = null;
            this._collection = null;
            this._linkedRecords = null;
            this._unlinkedRecords = null;
            this._previousItHead = null;
            this._itHead = null;
            this._itTail = null;
            this._additionsHead = null;
            this._additionsTail = null;
            this._movesHead = null;
            this._movesTail = null;
            this._removalsHead = null;
            this._removalsTail = null;
            this._identityChangesHead = null;
            this._identityChangesTail = null;
            this._trackByFn = this._trackByFn || trackByIdentity;
        }
        Object.defineProperty(DefaultIterableDiffer.prototype, "collection", {
            /**
             * @return {?}
             */
            get: function () { return this._collection; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DefaultIterableDiffer.prototype, "length", {
            /**
             * @return {?}
             */
            get: function () { return this._length; },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} fn
         * @return {?}
         */
        DefaultIterableDiffer.prototype.forEachItem = function (fn) {
            var /** @type {?} */ record;
            for (record = this._itHead; record !== null; record = record._next) {
                fn(record);
            }
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        DefaultIterableDiffer.prototype.forEachOperation = function (fn) {
            var /** @type {?} */ nextIt = this._itHead;
            var /** @type {?} */ nextRemove = this._removalsHead;
            var /** @type {?} */ addRemoveOffset = 0;
            var /** @type {?} */ moveOffsets = null;
            while (nextIt || nextRemove) {
                // Figure out which is the next record to process
                // Order: remove, add, move
                var /** @type {?} */ record = !nextRemove ||
                    nextIt &&
                        nextIt.currentIndex < getPreviousIndex(nextRemove, addRemoveOffset, moveOffsets) ?
                    nextIt :
                    nextRemove;
                var /** @type {?} */ adjPreviousIndex = getPreviousIndex(record, addRemoveOffset, moveOffsets);
                var /** @type {?} */ currentIndex = record.currentIndex;
                // consume the item, and adjust the addRemoveOffset and update moveDistance if necessary
                if (record === nextRemove) {
                    addRemoveOffset--;
                    nextRemove = nextRemove._nextRemoved;
                }
                else {
                    nextIt = nextIt._next;
                    if (record.previousIndex == null) {
                        addRemoveOffset++;
                    }
                    else {
                        // INVARIANT:  currentIndex < previousIndex
                        if (!moveOffsets)
                            moveOffsets = [];
                        var /** @type {?} */ localMovePreviousIndex = adjPreviousIndex - addRemoveOffset;
                        var /** @type {?} */ localCurrentIndex = currentIndex - addRemoveOffset;
                        if (localMovePreviousIndex != localCurrentIndex) {
                            for (var /** @type {?} */ i = 0; i < localMovePreviousIndex; i++) {
                                var /** @type {?} */ offset = i < moveOffsets.length ? moveOffsets[i] : (moveOffsets[i] = 0);
                                var /** @type {?} */ index = offset + i;
                                if (localCurrentIndex <= index && index < localMovePreviousIndex) {
                                    moveOffsets[i] = offset + 1;
                                }
                            }
                            var /** @type {?} */ previousIndex = record.previousIndex;
                            moveOffsets[previousIndex] = localCurrentIndex - localMovePreviousIndex;
                        }
                    }
                }
                if (adjPreviousIndex !== currentIndex) {
                    fn(record, adjPreviousIndex, currentIndex);
                }
            }
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        DefaultIterableDiffer.prototype.forEachPreviousItem = function (fn) {
            var /** @type {?} */ record;
            for (record = this._previousItHead; record !== null; record = record._nextPrevious) {
                fn(record);
            }
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        DefaultIterableDiffer.prototype.forEachAddedItem = function (fn) {
            var /** @type {?} */ record;
            for (record = this._additionsHead; record !== null; record = record._nextAdded) {
                fn(record);
            }
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        DefaultIterableDiffer.prototype.forEachMovedItem = function (fn) {
            var /** @type {?} */ record;
            for (record = this._movesHead; record !== null; record = record._nextMoved) {
                fn(record);
            }
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        DefaultIterableDiffer.prototype.forEachRemovedItem = function (fn) {
            var /** @type {?} */ record;
            for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
                fn(record);
            }
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        DefaultIterableDiffer.prototype.forEachIdentityChange = function (fn) {
            var /** @type {?} */ record;
            for (record = this._identityChangesHead; record !== null; record = record._nextIdentityChange) {
                fn(record);
            }
        };
        /**
         * @param {?} collection
         * @return {?}
         */
        DefaultIterableDiffer.prototype.diff = function (collection) {
            if (isBlank(collection))
                collection = [];
            if (!isListLikeIterable(collection)) {
                throw new Error("Error trying to diff '" + collection + "'");
            }
            if (this.check(collection)) {
                return this;
            }
            else {
                return null;
            }
        };
        /**
         * @return {?}
         */
        DefaultIterableDiffer.prototype.onDestroy = function () { };
        /**
         * @param {?} collection
         * @return {?}
         */
        DefaultIterableDiffer.prototype.check = function (collection) {
            var _this = this;
            this._reset();
            var /** @type {?} */ record = this._itHead;
            var /** @type {?} */ mayBeDirty = false;
            var /** @type {?} */ index;
            var /** @type {?} */ item;
            var /** @type {?} */ itemTrackBy;
            if (Array.isArray(collection)) {
                var /** @type {?} */ list = collection;
                this._length = collection.length;
                for (var /** @type {?} */ index_1 = 0; index_1 < this._length; index_1++) {
                    item = list[index_1];
                    itemTrackBy = this._trackByFn(index_1, item);
                    if (record === null || !looseIdentical(record.trackById, itemTrackBy)) {
                        record = this._mismatch(record, item, itemTrackBy, index_1);
                        mayBeDirty = true;
                    }
                    else {
                        if (mayBeDirty) {
                            // TODO(misko): can we limit this to duplicates only?
                            record = this._verifyReinsertion(record, item, itemTrackBy, index_1);
                        }
                        if (!looseIdentical(record.item, item))
                            this._addIdentityChange(record, item);
                    }
                    record = record._next;
                }
            }
            else {
                index = 0;
                iterateListLike(collection, function (item /** TODO #9100 */) {
                    itemTrackBy = _this._trackByFn(index, item);
                    if (record === null || !looseIdentical(record.trackById, itemTrackBy)) {
                        record = _this._mismatch(record, item, itemTrackBy, index);
                        mayBeDirty = true;
                    }
                    else {
                        if (mayBeDirty) {
                            // TODO(misko): can we limit this to duplicates only?
                            record = _this._verifyReinsertion(record, item, itemTrackBy, index);
                        }
                        if (!looseIdentical(record.item, item))
                            _this._addIdentityChange(record, item);
                    }
                    record = record._next;
                    index++;
                });
                this._length = index;
            }
            this._truncate(record);
            this._collection = collection;
            return this.isDirty;
        };
        Object.defineProperty(DefaultIterableDiffer.prototype, "isDirty", {
            /**
             * @return {?}
             */
            get: function () {
                return this._additionsHead !== null || this._movesHead !== null ||
                    this._removalsHead !== null || this._identityChangesHead !== null;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Reset the state of the change objects to show no changes. This means set previousKey to
         * currentKey, and clear all of the queues (additions, moves, removals).
         * Set the previousIndexes of moved and added items to their currentIndexes
         * Reset the list of additions, moves and removals
         *
         * \@internal
         * @return {?}
         */
        DefaultIterableDiffer.prototype._reset = function () {
            if (this.isDirty) {
                var /** @type {?} */ record = void 0;
                var /** @type {?} */ nextRecord = void 0;
                for (record = this._previousItHead = this._itHead; record !== null; record = record._next) {
                    record._nextPrevious = record._next;
                }
                for (record = this._additionsHead; record !== null; record = record._nextAdded) {
                    record.previousIndex = record.currentIndex;
                }
                this._additionsHead = this._additionsTail = null;
                for (record = this._movesHead; record !== null; record = nextRecord) {
                    record.previousIndex = record.currentIndex;
                    nextRecord = record._nextMoved;
                }
                this._movesHead = this._movesTail = null;
                this._removalsHead = this._removalsTail = null;
                this._identityChangesHead = this._identityChangesTail = null;
            }
        };
        /**
         * This is the core function which handles differences between collections.
         *
         * - `record` is the record which we saw at this position last time. If null then it is a new
         *   item.
         * - `item` is the current item in the collection
         * - `index` is the position of the item in the collection
         *
         * \@internal
         * @param {?} record
         * @param {?} item
         * @param {?} itemTrackBy
         * @param {?} index
         * @return {?}
         */
        DefaultIterableDiffer.prototype._mismatch = function (record, item, itemTrackBy, index) {
            // The previous record after which we will append the current one.
            var /** @type {?} */ previousRecord;
            if (record === null) {
                previousRecord = this._itTail;
            }
            else {
                previousRecord = record._prev;
                // Remove the record from the collection since we know it does not match the item.
                this._remove(record);
            }
            // Attempt to see if we have seen the item before.
            record = this._linkedRecords === null ? null : this._linkedRecords.get(itemTrackBy, index);
            if (record !== null) {
                // We have seen this before, we need to move it forward in the collection.
                // But first we need to check if identity changed, so we can update in view if necessary
                if (!looseIdentical(record.item, item))
                    this._addIdentityChange(record, item);
                this._moveAfter(record, previousRecord, index);
            }
            else {
                // Never seen it, check evicted list.
                record = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy);
                if (record !== null) {
                    // It is an item which we have evicted earlier: reinsert it back into the list.
                    // But first we need to check if identity changed, so we can update in view if necessary
                    if (!looseIdentical(record.item, item))
                        this._addIdentityChange(record, item);
                    this._reinsertAfter(record, previousRecord, index);
                }
                else {
                    // It is a new item: add it.
                    record =
                        this._addAfter(new CollectionChangeRecord(item, itemTrackBy), previousRecord, index);
                }
            }
            return record;
        };
        /**
         * This check is only needed if an array contains duplicates. (Short circuit of nothing dirty)
         *
         * Use case: `[a, a]` => `[b, a, a]`
         *
         * If we did not have this check then the insertion of `b` would:
         *   1) evict first `a`
         *   2) insert `b` at `0` index.
         *   3) leave `a` at index `1` as is. <-- this is wrong!
         *   3) reinsert `a` at index 2. <-- this is wrong!
         *
         * The correct behavior is:
         *   1) evict first `a`
         *   2) insert `b` at `0` index.
         *   3) reinsert `a` at index 1.
         *   3) move `a` at from `1` to `2`.
         *
         *
         * Double check that we have not evicted a duplicate item. We need to check if the item type may
         * have already been removed:
         * The insertion of b will evict the first 'a'. If we don't reinsert it now it will be reinserted
         * at the end. Which will show up as the two 'a's switching position. This is incorrect, since a
         * better way to think of it is as insert of 'b' rather then switch 'a' with 'b' and then add 'a'
         * at the end.
         *
         * \@internal
         * @param {?} record
         * @param {?} item
         * @param {?} itemTrackBy
         * @param {?} index
         * @return {?}
         */
        DefaultIterableDiffer.prototype._verifyReinsertion = function (record, item, itemTrackBy, index) {
            var /** @type {?} */ reinsertRecord = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy);
            if (reinsertRecord !== null) {
                record = this._reinsertAfter(reinsertRecord, record._prev, index);
            }
            else if (record.currentIndex != index) {
                record.currentIndex = index;
                this._addToMoves(record, index);
            }
            return record;
        };
        /**
         * Get rid of any excess {\@link CollectionChangeRecord}s from the previous collection
         *
         * - `record` The first excess {\@link CollectionChangeRecord}.
         *
         * \@internal
         * @param {?} record
         * @return {?}
         */
        DefaultIterableDiffer.prototype._truncate = function (record) {
            // Anything after that needs to be removed;
            while (record !== null) {
                var /** @type {?} */ nextRecord = record._next;
                this._addToRemovals(this._unlink(record));
                record = nextRecord;
            }
            if (this._unlinkedRecords !== null) {
                this._unlinkedRecords.clear();
            }
            if (this._additionsTail !== null) {
                this._additionsTail._nextAdded = null;
            }
            if (this._movesTail !== null) {
                this._movesTail._nextMoved = null;
            }
            if (this._itTail !== null) {
                this._itTail._next = null;
            }
            if (this._removalsTail !== null) {
                this._removalsTail._nextRemoved = null;
            }
            if (this._identityChangesTail !== null) {
                this._identityChangesTail._nextIdentityChange = null;
            }
        };
        /**
         * \@internal
         * @param {?} record
         * @param {?} prevRecord
         * @param {?} index
         * @return {?}
         */
        DefaultIterableDiffer.prototype._reinsertAfter = function (record, prevRecord, index) {
            if (this._unlinkedRecords !== null) {
                this._unlinkedRecords.remove(record);
            }
            var /** @type {?} */ prev = record._prevRemoved;
            var /** @type {?} */ next = record._nextRemoved;
            if (prev === null) {
                this._removalsHead = next;
            }
            else {
                prev._nextRemoved = next;
            }
            if (next === null) {
                this._removalsTail = prev;
            }
            else {
                next._prevRemoved = prev;
            }
            this._insertAfter(record, prevRecord, index);
            this._addToMoves(record, index);
            return record;
        };
        /**
         * \@internal
         * @param {?} record
         * @param {?} prevRecord
         * @param {?} index
         * @return {?}
         */
        DefaultIterableDiffer.prototype._moveAfter = function (record, prevRecord, index) {
            this._unlink(record);
            this._insertAfter(record, prevRecord, index);
            this._addToMoves(record, index);
            return record;
        };
        /**
         * \@internal
         * @param {?} record
         * @param {?} prevRecord
         * @param {?} index
         * @return {?}
         */
        DefaultIterableDiffer.prototype._addAfter = function (record, prevRecord, index) {
            this._insertAfter(record, prevRecord, index);
            if (this._additionsTail === null) {
                // todo(vicb)
                // assert(this._additionsHead === null);
                this._additionsTail = this._additionsHead = record;
            }
            else {
                // todo(vicb)
                // assert(_additionsTail._nextAdded === null);
                // assert(record._nextAdded === null);
                this._additionsTail = this._additionsTail._nextAdded = record;
            }
            return record;
        };
        /**
         * \@internal
         * @param {?} record
         * @param {?} prevRecord
         * @param {?} index
         * @return {?}
         */
        DefaultIterableDiffer.prototype._insertAfter = function (record, prevRecord, index) {
            // todo(vicb)
            // assert(record != prevRecord);
            // assert(record._next === null);
            // assert(record._prev === null);
            var /** @type {?} */ next = prevRecord === null ? this._itHead : prevRecord._next;
            // todo(vicb)
            // assert(next != record);
            // assert(prevRecord != record);
            record._next = next;
            record._prev = prevRecord;
            if (next === null) {
                this._itTail = record;
            }
            else {
                next._prev = record;
            }
            if (prevRecord === null) {
                this._itHead = record;
            }
            else {
                prevRecord._next = record;
            }
            if (this._linkedRecords === null) {
                this._linkedRecords = new _DuplicateMap();
            }
            this._linkedRecords.put(record);
            record.currentIndex = index;
            return record;
        };
        /**
         * \@internal
         * @param {?} record
         * @return {?}
         */
        DefaultIterableDiffer.prototype._remove = function (record) {
            return this._addToRemovals(this._unlink(record));
        };
        /**
         * \@internal
         * @param {?} record
         * @return {?}
         */
        DefaultIterableDiffer.prototype._unlink = function (record) {
            if (this._linkedRecords !== null) {
                this._linkedRecords.remove(record);
            }
            var /** @type {?} */ prev = record._prev;
            var /** @type {?} */ next = record._next;
            // todo(vicb)
            // assert((record._prev = null) === null);
            // assert((record._next = null) === null);
            if (prev === null) {
                this._itHead = next;
            }
            else {
                prev._next = next;
            }
            if (next === null) {
                this._itTail = prev;
            }
            else {
                next._prev = prev;
            }
            return record;
        };
        /**
         * \@internal
         * @param {?} record
         * @param {?} toIndex
         * @return {?}
         */
        DefaultIterableDiffer.prototype._addToMoves = function (record, toIndex) {
            // todo(vicb)
            // assert(record._nextMoved === null);
            if (record.previousIndex === toIndex) {
                return record;
            }
            if (this._movesTail === null) {
                // todo(vicb)
                // assert(_movesHead === null);
                this._movesTail = this._movesHead = record;
            }
            else {
                // todo(vicb)
                // assert(_movesTail._nextMoved === null);
                this._movesTail = this._movesTail._nextMoved = record;
            }
            return record;
        };
        /**
         * \@internal
         * @param {?} record
         * @return {?}
         */
        DefaultIterableDiffer.prototype._addToRemovals = function (record) {
            if (this._unlinkedRecords === null) {
                this._unlinkedRecords = new _DuplicateMap();
            }
            this._unlinkedRecords.put(record);
            record.currentIndex = null;
            record._nextRemoved = null;
            if (this._removalsTail === null) {
                // todo(vicb)
                // assert(_removalsHead === null);
                this._removalsTail = this._removalsHead = record;
                record._prevRemoved = null;
            }
            else {
                // todo(vicb)
                // assert(_removalsTail._nextRemoved === null);
                // assert(record._nextRemoved === null);
                record._prevRemoved = this._removalsTail;
                this._removalsTail = this._removalsTail._nextRemoved = record;
            }
            return record;
        };
        /**
         * \@internal
         * @param {?} record
         * @param {?} item
         * @return {?}
         */
        DefaultIterableDiffer.prototype._addIdentityChange = function (record, item) {
            record.item = item;
            if (this._identityChangesTail === null) {
                this._identityChangesTail = this._identityChangesHead = record;
            }
            else {
                this._identityChangesTail = this._identityChangesTail._nextIdentityChange = record;
            }
            return record;
        };
        /**
         * @return {?}
         */
        DefaultIterableDiffer.prototype.toString = function () {
            var /** @type {?} */ list = [];
            this.forEachItem(function (record /** TODO #9100 */) { return list.push(record); });
            var /** @type {?} */ previous = [];
            this.forEachPreviousItem(function (record /** TODO #9100 */) { return previous.push(record); });
            var /** @type {?} */ additions = [];
            this.forEachAddedItem(function (record /** TODO #9100 */) { return additions.push(record); });
            var /** @type {?} */ moves = [];
            this.forEachMovedItem(function (record /** TODO #9100 */) { return moves.push(record); });
            var /** @type {?} */ removals = [];
            this.forEachRemovedItem(function (record /** TODO #9100 */) { return removals.push(record); });
            var /** @type {?} */ identityChanges = [];
            this.forEachIdentityChange(function (record /** TODO #9100 */) { return identityChanges.push(record); });
            return 'collection: ' + list.join(', ') + '\n' +
                'previous: ' + previous.join(', ') + '\n' +
                'additions: ' + additions.join(', ') + '\n' +
                'moves: ' + moves.join(', ') + '\n' +
                'removals: ' + removals.join(', ') + '\n' +
                'identityChanges: ' + identityChanges.join(', ') + '\n';
        };
        return DefaultIterableDiffer;
    }());
    /**
     * \@stable
     */
    var CollectionChangeRecord = (function () {
        /**
         * @param {?} item
         * @param {?} trackById
         */
        function CollectionChangeRecord(item, trackById) {
            this.item = item;
            this.trackById = trackById;
            this.currentIndex = null;
            this.previousIndex = null;
            /** @internal */
            this._nextPrevious = null;
            /** @internal */
            this._prev = null;
            /** @internal */
            this._next = null;
            /** @internal */
            this._prevDup = null;
            /** @internal */
            this._nextDup = null;
            /** @internal */
            this._prevRemoved = null;
            /** @internal */
            this._nextRemoved = null;
            /** @internal */
            this._nextAdded = null;
            /** @internal */
            this._nextMoved = null;
            /** @internal */
            this._nextIdentityChange = null;
        }
        /**
         * @return {?}
         */
        CollectionChangeRecord.prototype.toString = function () {
            return this.previousIndex === this.currentIndex ? stringify(this.item) :
                stringify(this.item) + '[' +
                    stringify(this.previousIndex) + '->' + stringify(this.currentIndex) + ']';
        };
        return CollectionChangeRecord;
    }());
    var _DuplicateItemRecordList = (function () {
        function _DuplicateItemRecordList() {
            /** @internal */
            this._head = null;
            /** @internal */
            this._tail = null;
        }
        /**
         * Append the record to the list of duplicates.
         *
         * Note: by design all records in the list of duplicates hold the same value in record.item.
         * @param {?} record
         * @return {?}
         */
        _DuplicateItemRecordList.prototype.add = function (record) {
            if (this._head === null) {
                this._head = this._tail = record;
                record._nextDup = null;
                record._prevDup = null;
            }
            else {
                // todo(vicb)
                // assert(record.item ==  _head.item ||
                //       record.item is num && record.item.isNaN && _head.item is num && _head.item.isNaN);
                this._tail._nextDup = record;
                record._prevDup = this._tail;
                record._nextDup = null;
                this._tail = record;
            }
        };
        /**
         * @param {?} trackById
         * @param {?} afterIndex
         * @return {?}
         */
        _DuplicateItemRecordList.prototype.get = function (trackById, afterIndex) {
            var /** @type {?} */ record;
            for (record = this._head; record !== null; record = record._nextDup) {
                if ((afterIndex === null || afterIndex < record.currentIndex) &&
                    looseIdentical(record.trackById, trackById)) {
                    return record;
                }
            }
            return null;
        };
        /**
         * Remove one {\@link CollectionChangeRecord} from the list of duplicates.
         *
         * Returns whether the list of duplicates is empty.
         * @param {?} record
         * @return {?}
         */
        _DuplicateItemRecordList.prototype.remove = function (record) {
            // todo(vicb)
            // assert(() {
            //  // verify that the record being removed is in the list.
            //  for (CollectionChangeRecord cursor = _head; cursor != null; cursor = cursor._nextDup) {
            //    if (identical(cursor, record)) return true;
            //  }
            //  return false;
            //});
            var /** @type {?} */ prev = record._prevDup;
            var /** @type {?} */ next = record._nextDup;
            if (prev === null) {
                this._head = next;
            }
            else {
                prev._nextDup = next;
            }
            if (next === null) {
                this._tail = prev;
            }
            else {
                next._prevDup = prev;
            }
            return this._head === null;
        };
        return _DuplicateItemRecordList;
    }());
    var _DuplicateMap = (function () {
        function _DuplicateMap() {
            this.map = new Map();
        }
        /**
         * @param {?} record
         * @return {?}
         */
        _DuplicateMap.prototype.put = function (record) {
            var /** @type {?} */ key = record.trackById;
            var /** @type {?} */ duplicates = this.map.get(key);
            if (!duplicates) {
                duplicates = new _DuplicateItemRecordList();
                this.map.set(key, duplicates);
            }
            duplicates.add(record);
        };
        /**
         * Retrieve the `value` using key. Because the CollectionChangeRecord value may be one which we
         * have already iterated over, we use the afterIndex to pretend it is not there.
         *
         * Use case: `[a, b, c, a, a]` if we are at index `3` which is the second `a` then asking if we
         * have any more `a`s needs to return the last `a` not the first or second.
         * @param {?} trackById
         * @param {?=} afterIndex
         * @return {?}
         */
        _DuplicateMap.prototype.get = function (trackById, afterIndex) {
            if (afterIndex === void 0) { afterIndex = null; }
            var /** @type {?} */ key = trackById;
            var /** @type {?} */ recordList = this.map.get(key);
            return recordList ? recordList.get(trackById, afterIndex) : null;
        };
        /**
         * Removes a {\@link CollectionChangeRecord} from the list of duplicates.
         *
         * The list of duplicates also is removed from the map if it gets empty.
         * @param {?} record
         * @return {?}
         */
        _DuplicateMap.prototype.remove = function (record) {
            var /** @type {?} */ key = record.trackById;
            var /** @type {?} */ recordList = this.map.get(key);
            // Remove the list of duplicates when it gets empty
            if (recordList.remove(record)) {
                this.map.delete(key);
            }
            return record;
        };
        Object.defineProperty(_DuplicateMap.prototype, "isEmpty", {
            /**
             * @return {?}
             */
            get: function () { return this.map.size === 0; },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        _DuplicateMap.prototype.clear = function () { this.map.clear(); };
        /**
         * @return {?}
         */
        _DuplicateMap.prototype.toString = function () { return '_DuplicateMap(' + stringify(this.map) + ')'; };
        return _DuplicateMap;
    }());
    /**
     * @param {?} item
     * @param {?} addRemoveOffset
     * @param {?} moveOffsets
     * @return {?}
     */
    function getPreviousIndex(item, addRemoveOffset, moveOffsets) {
        var /** @type {?} */ previousIndex = item.previousIndex;
        if (previousIndex === null)
            return previousIndex;
        var /** @type {?} */ moveOffset = 0;
        if (moveOffsets && previousIndex < moveOffsets.length) {
            moveOffset = moveOffsets[previousIndex];
        }
        return previousIndex + addRemoveOffset + moveOffset;
    }

    var DefaultKeyValueDifferFactory = (function () {
        function DefaultKeyValueDifferFactory() {
        }
        /**
         * @param {?} obj
         * @return {?}
         */
        DefaultKeyValueDifferFactory.prototype.supports = function (obj) { return obj instanceof Map || isJsObject(obj); };
        /**
         * @param {?} cdRef
         * @return {?}
         */
        DefaultKeyValueDifferFactory.prototype.create = function (cdRef) { return new DefaultKeyValueDiffer(); };
        return DefaultKeyValueDifferFactory;
    }());
    var DefaultKeyValueDiffer = (function () {
        function DefaultKeyValueDiffer() {
            this._records = new Map();
            this._mapHead = null;
            this._previousMapHead = null;
            this._changesHead = null;
            this._changesTail = null;
            this._additionsHead = null;
            this._additionsTail = null;
            this._removalsHead = null;
            this._removalsTail = null;
        }
        Object.defineProperty(DefaultKeyValueDiffer.prototype, "isDirty", {
            /**
             * @return {?}
             */
            get: function () {
                return this._additionsHead !== null || this._changesHead !== null ||
                    this._removalsHead !== null;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} fn
         * @return {?}
         */
        DefaultKeyValueDiffer.prototype.forEachItem = function (fn) {
            var /** @type {?} */ record;
            for (record = this._mapHead; record !== null; record = record._next) {
                fn(record);
            }
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        DefaultKeyValueDiffer.prototype.forEachPreviousItem = function (fn) {
            var /** @type {?} */ record;
            for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {
                fn(record);
            }
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        DefaultKeyValueDiffer.prototype.forEachChangedItem = function (fn) {
            var /** @type {?} */ record;
            for (record = this._changesHead; record !== null; record = record._nextChanged) {
                fn(record);
            }
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        DefaultKeyValueDiffer.prototype.forEachAddedItem = function (fn) {
            var /** @type {?} */ record;
            for (record = this._additionsHead; record !== null; record = record._nextAdded) {
                fn(record);
            }
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        DefaultKeyValueDiffer.prototype.forEachRemovedItem = function (fn) {
            var /** @type {?} */ record;
            for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
                fn(record);
            }
        };
        /**
         * @param {?} map
         * @return {?}
         */
        DefaultKeyValueDiffer.prototype.diff = function (map) {
            if (!map) {
                map = new Map();
            }
            else if (!(map instanceof Map || isJsObject(map))) {
                throw new Error("Error trying to diff '" + map + "'");
            }
            return this.check(map) ? this : null;
        };
        /**
         * @return {?}
         */
        DefaultKeyValueDiffer.prototype.onDestroy = function () { };
        /**
         * @param {?} map
         * @return {?}
         */
        DefaultKeyValueDiffer.prototype.check = function (map) {
            var _this = this;
            this._reset();
            var /** @type {?} */ records = this._records;
            var /** @type {?} */ oldSeqRecord = this._mapHead;
            var /** @type {?} */ lastOldSeqRecord = null;
            var /** @type {?} */ lastNewSeqRecord = null;
            var /** @type {?} */ seqChanged = false;
            this._forEach(map, function (value, key) {
                var /** @type {?} */ newSeqRecord;
                if (oldSeqRecord && key === oldSeqRecord.key) {
                    newSeqRecord = oldSeqRecord;
                    _this._maybeAddToChanges(newSeqRecord, value);
                }
                else {
                    seqChanged = true;
                    if (oldSeqRecord !== null) {
                        _this._removeFromSeq(lastOldSeqRecord, oldSeqRecord);
                        _this._addToRemovals(oldSeqRecord);
                    }
                    if (records.has(key)) {
                        newSeqRecord = records.get(key);
                        _this._maybeAddToChanges(newSeqRecord, value);
                    }
                    else {
                        newSeqRecord = new KeyValueChangeRecord(key);
                        records.set(key, newSeqRecord);
                        newSeqRecord.currentValue = value;
                        _this._addToAdditions(newSeqRecord);
                    }
                }
                if (seqChanged) {
                    if (_this._isInRemovals(newSeqRecord)) {
                        _this._removeFromRemovals(newSeqRecord);
                    }
                    if (lastNewSeqRecord == null) {
                        _this._mapHead = newSeqRecord;
                    }
                    else {
                        lastNewSeqRecord._next = newSeqRecord;
                    }
                }
                lastOldSeqRecord = oldSeqRecord;
                lastNewSeqRecord = newSeqRecord;
                oldSeqRecord = oldSeqRecord && oldSeqRecord._next;
            });
            this._truncate(lastOldSeqRecord, oldSeqRecord);
            return this.isDirty;
        };
        /**
         * \@internal
         * @return {?}
         */
        DefaultKeyValueDiffer.prototype._reset = function () {
            if (this.isDirty) {
                var /** @type {?} */ record = void 0;
                // Record the state of the mapping
                for (record = this._previousMapHead = this._mapHead; record !== null; record = record._next) {
                    record._nextPrevious = record._next;
                }
                for (record = this._changesHead; record !== null; record = record._nextChanged) {
                    record.previousValue = record.currentValue;
                }
                for (record = this._additionsHead; record != null; record = record._nextAdded) {
                    record.previousValue = record.currentValue;
                }
                this._changesHead = this._changesTail = null;
                this._additionsHead = this._additionsTail = null;
                this._removalsHead = this._removalsTail = null;
            }
        };
        /**
         * \@internal
         * @param {?} lastRecord
         * @param {?} record
         * @return {?}
         */
        DefaultKeyValueDiffer.prototype._truncate = function (lastRecord, record) {
            while (record !== null) {
                if (lastRecord === null) {
                    this._mapHead = null;
                }
                else {
                    lastRecord._next = null;
                }
                var /** @type {?} */ nextRecord = record._next;
                this._addToRemovals(record);
                lastRecord = record;
                record = nextRecord;
            }
            for (var /** @type {?} */ rec = this._removalsHead; rec !== null; rec = rec._nextRemoved) {
                rec.previousValue = rec.currentValue;
                rec.currentValue = null;
                this._records.delete(rec.key);
            }
        };
        /**
         * @param {?} record
         * @param {?} newValue
         * @return {?}
         */
        DefaultKeyValueDiffer.prototype._maybeAddToChanges = function (record, newValue) {
            if (!looseIdentical(newValue, record.currentValue)) {
                record.previousValue = record.currentValue;
                record.currentValue = newValue;
                this._addToChanges(record);
            }
        };
        /**
         * \@internal
         * @param {?} record
         * @return {?}
         */
        DefaultKeyValueDiffer.prototype._isInRemovals = function (record) {
            return record === this._removalsHead || record._nextRemoved !== null ||
                record._prevRemoved !== null;
        };
        /**
         * \@internal
         * @param {?} record
         * @return {?}
         */
        DefaultKeyValueDiffer.prototype._addToRemovals = function (record) {
            if (this._removalsHead === null) {
                this._removalsHead = this._removalsTail = record;
            }
            else {
                this._removalsTail._nextRemoved = record;
                record._prevRemoved = this._removalsTail;
                this._removalsTail = record;
            }
        };
        /**
         * \@internal
         * @param {?} prev
         * @param {?} record
         * @return {?}
         */
        DefaultKeyValueDiffer.prototype._removeFromSeq = function (prev, record) {
            var /** @type {?} */ next = record._next;
            if (prev === null) {
                this._mapHead = next;
            }
            else {
                prev._next = next;
            }
            record._next = null;
        };
        /**
         * \@internal
         * @param {?} record
         * @return {?}
         */
        DefaultKeyValueDiffer.prototype._removeFromRemovals = function (record) {
            var /** @type {?} */ prev = record._prevRemoved;
            var /** @type {?} */ next = record._nextRemoved;
            if (prev === null) {
                this._removalsHead = next;
            }
            else {
                prev._nextRemoved = next;
            }
            if (next === null) {
                this._removalsTail = prev;
            }
            else {
                next._prevRemoved = prev;
            }
            record._prevRemoved = record._nextRemoved = null;
        };
        /**
         * \@internal
         * @param {?} record
         * @return {?}
         */
        DefaultKeyValueDiffer.prototype._addToAdditions = function (record) {
            if (this._additionsHead === null) {
                this._additionsHead = this._additionsTail = record;
            }
            else {
                this._additionsTail._nextAdded = record;
                this._additionsTail = record;
            }
        };
        /**
         * \@internal
         * @param {?} record
         * @return {?}
         */
        DefaultKeyValueDiffer.prototype._addToChanges = function (record) {
            if (this._changesHead === null) {
                this._changesHead = this._changesTail = record;
            }
            else {
                this._changesTail._nextChanged = record;
                this._changesTail = record;
            }
        };
        /**
         * @return {?}
         */
        DefaultKeyValueDiffer.prototype.toString = function () {
            var /** @type {?} */ items = [];
            var /** @type {?} */ previous = [];
            var /** @type {?} */ changes = [];
            var /** @type {?} */ additions = [];
            var /** @type {?} */ removals = [];
            var /** @type {?} */ record;
            for (record = this._mapHead; record !== null; record = record._next) {
                items.push(stringify(record));
            }
            for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {
                previous.push(stringify(record));
            }
            for (record = this._changesHead; record !== null; record = record._nextChanged) {
                changes.push(stringify(record));
            }
            for (record = this._additionsHead; record !== null; record = record._nextAdded) {
                additions.push(stringify(record));
            }
            for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
                removals.push(stringify(record));
            }
            return 'map: ' + items.join(', ') + '\n' +
                'previous: ' + previous.join(', ') + '\n' +
                'additions: ' + additions.join(', ') + '\n' +
                'changes: ' + changes.join(', ') + '\n' +
                'removals: ' + removals.join(', ') + '\n';
        };
        /**
         * \@internal
         * @param {?} obj
         * @param {?} fn
         * @return {?}
         */
        DefaultKeyValueDiffer.prototype._forEach = function (obj, fn) {
            if (obj instanceof Map) {
                obj.forEach(fn);
            }
            else {
                Object.keys(obj).forEach(function (k) { return fn(obj[k], k); });
            }
        };
        return DefaultKeyValueDiffer;
    }());
    /**
     * \@stable
     */
    var KeyValueChangeRecord = (function () {
        /**
         * @param {?} key
         */
        function KeyValueChangeRecord(key) {
            this.key = key;
            this.previousValue = null;
            this.currentValue = null;
            /** @internal */
            this._nextPrevious = null;
            /** @internal */
            this._next = null;
            /** @internal */
            this._nextAdded = null;
            /** @internal */
            this._nextRemoved = null;
            /** @internal */
            this._prevRemoved = null;
            /** @internal */
            this._nextChanged = null;
        }
        /**
         * @return {?}
         */
        KeyValueChangeRecord.prototype.toString = function () {
            return looseIdentical(this.previousValue, this.currentValue) ?
                stringify(this.key) :
                (stringify(this.key) + '[' + stringify(this.previousValue) + '->' +
                    stringify(this.currentValue) + ']');
        };
        return KeyValueChangeRecord;
    }());

    /**
     * A repository of different iterable diffing strategies used by NgFor, NgClass, and others.
     * \@stable
     */
    var IterableDiffers = (function () {
        /**
         * @param {?} factories
         */
        function IterableDiffers(factories) {
            this.factories = factories;
        }
        /**
         * @param {?} factories
         * @param {?=} parent
         * @return {?}
         */
        IterableDiffers.create = function (factories, parent) {
            if (isPresent(parent)) {
                var /** @type {?} */ copied = parent.factories.slice();
                factories = factories.concat(copied);
                return new IterableDiffers(factories);
            }
            else {
                return new IterableDiffers(factories);
            }
        };
        /**
         * Takes an array of {\@link IterableDifferFactory} and returns a provider used to extend the
         * inherited {\@link IterableDiffers} instance with the provided factories and return a new
         * {\@link IterableDiffers} instance.
         *
         * The following example shows how to extend an existing list of factories,
         * which will only be applied to the injector for this component and its children.
         * This step is all that's required to make a new {\@link IterableDiffer} available.
         *
         * ### Example
         *
         * ```
         * \@Component({
         *   viewProviders: [
         *     IterableDiffers.extend([new ImmutableListDiffer()])
         *   ]
         * })
         * ```
         * @param {?} factories
         * @return {?}
         */
        IterableDiffers.extend = function (factories) {
            return {
                provide: IterableDiffers,
                useFactory: function (parent) {
                    if (!parent) {
                        // Typically would occur when calling IterableDiffers.extend inside of dependencies passed
                        // to
                        // bootstrap(), which would override default pipes instead of extending them.
                        throw new Error('Cannot extend IterableDiffers without a parent injector');
                    }
                    return IterableDiffers.create(factories, parent);
                },
                // Dependency technically isn't optional, but we can provide a better error message this way.
                deps: [[IterableDiffers, new SkipSelf(), new Optional()]]
            };
        };
        /**
         * @param {?} iterable
         * @return {?}
         */
        IterableDiffers.prototype.find = function (iterable) {
            var /** @type {?} */ factory = this.factories.find(function (f) { return f.supports(iterable); });
            if (isPresent(factory)) {
                return factory;
            }
            else {
                throw new Error("Cannot find a differ supporting object '" + iterable + "' of type '" + getTypeNameForDebugging(iterable) + "'");
            }
        };
        return IterableDiffers;
    }());

    /**
     * A repository of different Map diffing strategies used by NgClass, NgStyle, and others.
     * \@stable
     */
    var KeyValueDiffers = (function () {
        /**
         * @param {?} factories
         */
        function KeyValueDiffers(factories) {
            this.factories = factories;
        }
        /**
         * @param {?} factories
         * @param {?=} parent
         * @return {?}
         */
        KeyValueDiffers.create = function (factories, parent) {
            if (isPresent(parent)) {
                var /** @type {?} */ copied = parent.factories.slice();
                factories = factories.concat(copied);
                return new KeyValueDiffers(factories);
            }
            else {
                return new KeyValueDiffers(factories);
            }
        };
        /**
         * Takes an array of {\@link KeyValueDifferFactory} and returns a provider used to extend the
         * inherited {\@link KeyValueDiffers} instance with the provided factories and return a new
         * {\@link KeyValueDiffers} instance.
         *
         * The following example shows how to extend an existing list of factories,
         * which will only be applied to the injector for this component and its children.
         * This step is all that's required to make a new {\@link KeyValueDiffer} available.
         *
         * ### Example
         *
         * ```
         * \@Component({
         *   viewProviders: [
         *     KeyValueDiffers.extend([new ImmutableMapDiffer()])
         *   ]
         * })
         * ```
         * @param {?} factories
         * @return {?}
         */
        KeyValueDiffers.extend = function (factories) {
            return {
                provide: KeyValueDiffers,
                useFactory: function (parent) {
                    if (!parent) {
                        // Typically would occur when calling KeyValueDiffers.extend inside of dependencies passed
                        // to
                        // bootstrap(), which would override default pipes instead of extending them.
                        throw new Error('Cannot extend KeyValueDiffers without a parent injector');
                    }
                    return KeyValueDiffers.create(factories, parent);
                },
                // Dependency technically isn't optional, but we can provide a better error message this way.
                deps: [[KeyValueDiffers, new SkipSelf(), new Optional()]]
            };
        };
        /**
         * @param {?} kv
         * @return {?}
         */
        KeyValueDiffers.prototype.find = function (kv) {
            var /** @type {?} */ factory = this.factories.find(function (f) { return f.supports(kv); });
            if (isPresent(factory)) {
                return factory;
            }
            else {
                throw new Error("Cannot find a differ supporting object '" + kv + "'");
            }
        };
        return KeyValueDiffers;
    }());

    var /** @type {?} */ UNINITIALIZED = {
        toString: function () { return 'CD_INIT_VALUE'; }
    };
    /**
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    function devModeEqual(a, b) {
        if (isListLikeIterable(a) && isListLikeIterable(b)) {
            return areIterablesEqual(a, b, devModeEqual);
        }
        else if (!isListLikeIterable(a) && !isPrimitive(a) && !isListLikeIterable(b) && !isPrimitive(b)) {
            return true;
        }
        else {
            return looseIdentical(a, b);
        }
    }
    /**
     * Indicates that the result of a {\@link Pipe} transformation has changed even though the
     * reference
     * has not changed.
     *
     * The wrapped value will be unwrapped by change detection, and the unwrapped value will be stored.
     *
     * Example:
     *
     * ```
     * if (this._latestValue === this._latestReturnedValue) {
     *    return this._latestReturnedValue;
     *  } else {
     *    this._latestReturnedValue = this._latestValue;
     *    return WrappedValue.wrap(this._latestValue); // this will force update
     *  }
     * ```
     * \@stable
     */
    var WrappedValue = (function () {
        /**
         * @param {?} wrapped
         */
        function WrappedValue(wrapped) {
            this.wrapped = wrapped;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        WrappedValue.wrap = function (value) { return new WrappedValue(value); };
        return WrappedValue;
    }());
    /**
     * Helper class for unwrapping WrappedValue s
     */
    var ValueUnwrapper = (function () {
        function ValueUnwrapper() {
            this.hasWrappedValue = false;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ValueUnwrapper.prototype.unwrap = function (value) {
            if (value instanceof WrappedValue) {
                this.hasWrappedValue = true;
                return value.wrapped;
            }
            return value;
        };
        /**
         * @return {?}
         */
        ValueUnwrapper.prototype.reset = function () { this.hasWrappedValue = false; };
        return ValueUnwrapper;
    }());
    /**
     * Represents a basic change from a previous to a new value.
     * \@stable
     */
    var SimpleChange = (function () {
        /**
         * @param {?} previousValue
         * @param {?} currentValue
         */
        function SimpleChange(previousValue, currentValue) {
            this.previousValue = previousValue;
            this.currentValue = currentValue;
        }
        /**
         * Check whether the new value is the first value assigned.
         * @return {?}
         */
        SimpleChange.prototype.isFirstChange = function () { return this.previousValue === UNINITIALIZED; };
        return SimpleChange;
    }());

    /**
     * \@stable
     * @abstract
     */
    var ChangeDetectorRef = (function () {
        function ChangeDetectorRef() {
        }
        /**
         * Marks all {\@link ChangeDetectionStrategy#OnPush} ancestors as to be checked.
         *
         * <!-- TODO: Add a link to a chapter on OnPush components -->
         *
         * ### Example ([live demo](http://plnkr.co/edit/GC512b?p=preview))
         *
         * ```typescript
         * \@Component({
         *   selector: 'cmp',
         *   changeDetection: ChangeDetectionStrategy.OnPush,
         *   template: `Number of ticks: {{numberOfTicks}}`
         * })
         * class Cmp {
         *   numberOfTicks = 0;
         *
         *   constructor(ref: ChangeDetectorRef) {
         *     setInterval(() => {
         *       this.numberOfTicks ++
         *       // the following is required, otherwise the view will not be updated
         *       this.ref.markForCheck();
         *     }, 1000);
         *   }
         * }
         *
         * \@Component({
         *   selector: 'app',
         *   changeDetection: ChangeDetectionStrategy.OnPush,
         *   template: `
         *     <cmp><cmp>
         *   `,
         * })
         * class App {
         * }
         * ```
         * @abstract
         * @return {?}
         */
        ChangeDetectorRef.prototype.markForCheck = function () { };
        /**
         * Detaches the change detector from the change detector tree.
         *
         * The detached change detector will not be checked until it is reattached.
         *
         * This can also be used in combination with {\@link ChangeDetectorRef#detectChanges} to implement
         * local change
         * detection checks.
         *
         * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
         * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->
         *
         * ### Example
         *
         * The following example defines a component with a large list of readonly data.
         * Imagine the data changes constantly, many times per second. For performance reasons,
         * we want to check and update the list every five seconds. We can do that by detaching
         * the component's change detector and doing a local check every five seconds.
         *
         * ```typescript
         * class DataProvider {
         *   // in a real application the returned data will be different every time
         *   get data() {
         *     return [1,2,3,4,5];
         *   }
         * }
         *
         * \@Component({
         *   selector: 'giant-list',
         *   template: `
         *     <li *ngFor="let d of dataProvider.data">Data {{d}}</lig>
         *   `,
         * })
         * class GiantList {
         *   constructor(private ref: ChangeDetectorRef, private dataProvider:DataProvider) {
         *     ref.detach();
         *     setInterval(() => {
         *       this.ref.detectChanges();
         *     }, 5000);
         *   }
         * }
         *
         * \@Component({
         *   selector: 'app',
         *   providers: [DataProvider],
         *   template: `
         *     <giant-list><giant-list>
         *   `,
         * })
         * class App {
         * }
         * ```
         * @abstract
         * @return {?}
         */
        ChangeDetectorRef.prototype.detach = function () { };
        /**
         * Checks the change detector and its children.
         *
         * This can also be used in combination with {\@link ChangeDetectorRef#detach} to implement local
         * change detection
         * checks.
         *
         * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
         * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->
         *
         * ### Example
         *
         * The following example defines a component with a large list of readonly data.
         * Imagine, the data changes constantly, many times per second. For performance reasons,
         * we want to check and update the list every five seconds.
         *
         * We can do that by detaching the component's change detector and doing a local change detection
         * check
         * every five seconds.
         *
         * See {\@link ChangeDetectorRef#detach} for more information.
         * @abstract
         * @return {?}
         */
        ChangeDetectorRef.prototype.detectChanges = function () { };
        /**
         * Checks the change detector and its children, and throws if any changes are detected.
         *
         * This is used in development mode to verify that running change detection doesn't introduce
         * other changes.
         * @abstract
         * @return {?}
         */
        ChangeDetectorRef.prototype.checkNoChanges = function () { };
        /**
         * Reattach the change detector to the change detector tree.
         *
         * This also marks OnPush ancestors as to be checked. This reattached change detector will be
         * checked during the next change detection run.
         *
         * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
         *
         * ### Example ([live demo](http://plnkr.co/edit/aUhZha?p=preview))
         *
         * The following example creates a component displaying `live` data. The component will detach
         * its change detector from the main change detector tree when the component's live property
         * is set to false.
         *
         * ```typescript
         * class DataProvider {
         *   data = 1;
         *
         *   constructor() {
         *     setInterval(() => {
         *       this.data = this.data * 2;
         *     }, 500);
         *   }
         * }
         *
         * \@Component({
         *   selector: 'live-data',
         *   inputs: ['live'],
         *   template: 'Data: {{dataProvider.data}}'
         * })
         * class LiveData {
         *   constructor(private ref: ChangeDetectorRef, private dataProvider:DataProvider) {}
         *
         *   set live(value) {
         *     if (value)
         *       this.ref.reattach();
         *     else
         *       this.ref.detach();
         *   }
         * }
         *
         * \@Component({
         *   selector: 'app',
         *   providers: [DataProvider],
         *   template: `
         *     Live Update: <input type="checkbox" [(ngModel)]="live">
         *     <live-data [live]="live"><live-data>
         *   `,
         * })
         * class App {
         *   live = true;
         * }
         * ```
         * @abstract
         * @return {?}
         */
        ChangeDetectorRef.prototype.reattach = function () { };
        return ChangeDetectorRef;
    }());

    /**
     * Structural diffing for `Object`s and `Map`s.
     */
    var /** @type {?} */ keyValDiff = [new DefaultKeyValueDifferFactory()];
    /**
     * Structural diffing for `Iterable` types such as `Array`s.
     */
    var /** @type {?} */ iterableDiff = [new DefaultIterableDifferFactory()];
    var /** @type {?} */ defaultIterableDiffers = new IterableDiffers(iterableDiff);
    var /** @type {?} */ defaultKeyValueDiffers = new KeyValueDiffers(keyValDiff);

    var RenderComponentType = (function () {
        /**
         * @param {?} id
         * @param {?} templateUrl
         * @param {?} slotCount
         * @param {?} encapsulation
         * @param {?} styles
         * @param {?} animations
         */
        function RenderComponentType(id, templateUrl, slotCount, encapsulation, styles, animations) {
            this.id = id;
            this.templateUrl = templateUrl;
            this.slotCount = slotCount;
            this.encapsulation = encapsulation;
            this.styles = styles;
            this.animations = animations;
        }
        return RenderComponentType;
    }());
    /**
     * @abstract
     */
    var RenderDebugInfo = (function () {
        function RenderDebugInfo() {
        }
        Object.defineProperty(RenderDebugInfo.prototype, "injector", {
            /**
             * @return {?}
             */
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RenderDebugInfo.prototype, "component", {
            /**
             * @return {?}
             */
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RenderDebugInfo.prototype, "providerTokens", {
            /**
             * @return {?}
             */
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RenderDebugInfo.prototype, "references", {
            /**
             * @return {?}
             */
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RenderDebugInfo.prototype, "context", {
            /**
             * @return {?}
             */
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RenderDebugInfo.prototype, "source", {
            /**
             * @return {?}
             */
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        return RenderDebugInfo;
    }());
    /**
     * \@experimental
     * @abstract
     */
    var Renderer = (function () {
        function Renderer() {
        }
        /**
         * @abstract
         * @param {?} selectorOrNode
         * @param {?=} debugInfo
         * @return {?}
         */
        Renderer.prototype.selectRootElement = function (selectorOrNode, debugInfo) { };
        /**
         * @abstract
         * @param {?} parentElement
         * @param {?} name
         * @param {?=} debugInfo
         * @return {?}
         */
        Renderer.prototype.createElement = function (parentElement, name, debugInfo) { };
        /**
         * @abstract
         * @param {?} hostElement
         * @return {?}
         */
        Renderer.prototype.createViewRoot = function (hostElement) { };
        /**
         * @abstract
         * @param {?} parentElement
         * @param {?=} debugInfo
         * @return {?}
         */
        Renderer.prototype.createTemplateAnchor = function (parentElement, debugInfo) { };
        /**
         * @abstract
         * @param {?} parentElement
         * @param {?} value
         * @param {?=} debugInfo
         * @return {?}
         */
        Renderer.prototype.createText = function (parentElement, value, debugInfo) { };
        /**
         * @abstract
         * @param {?} parentElement
         * @param {?} nodes
         * @return {?}
         */
        Renderer.prototype.projectNodes = function (parentElement, nodes) { };
        /**
         * @abstract
         * @param {?} node
         * @param {?} viewRootNodes
         * @return {?}
         */
        Renderer.prototype.attachViewAfter = function (node, viewRootNodes) { };
        /**
         * @abstract
         * @param {?} viewRootNodes
         * @return {?}
         */
        Renderer.prototype.detachView = function (viewRootNodes) { };
        /**
         * @abstract
         * @param {?} hostElement
         * @param {?} viewAllNodes
         * @return {?}
         */
        Renderer.prototype.destroyView = function (hostElement, viewAllNodes) { };
        /**
         * @abstract
         * @param {?} renderElement
         * @param {?} name
         * @param {?} callback
         * @return {?}
         */
        Renderer.prototype.listen = function (renderElement, name, callback) { };
        /**
         * @abstract
         * @param {?} target
         * @param {?} name
         * @param {?} callback
         * @return {?}
         */
        Renderer.prototype.listenGlobal = function (target, name, callback) { };
        /**
         * @abstract
         * @param {?} renderElement
         * @param {?} propertyName
         * @param {?} propertyValue
         * @return {?}
         */
        Renderer.prototype.setElementProperty = function (renderElement, propertyName, propertyValue) { };
        /**
         * @abstract
         * @param {?} renderElement
         * @param {?} attributeName
         * @param {?} attributeValue
         * @return {?}
         */
        Renderer.prototype.setElementAttribute = function (renderElement, attributeName, attributeValue) { };
        /**
         * Used only in debug mode to serialize property changes to dom nodes as attributes.
         * @abstract
         * @param {?} renderElement
         * @param {?} propertyName
         * @param {?} propertyValue
         * @return {?}
         */
        Renderer.prototype.setBindingDebugInfo = function (renderElement, propertyName, propertyValue) { };
        /**
         * @abstract
         * @param {?} renderElement
         * @param {?} className
         * @param {?} isAdd
         * @return {?}
         */
        Renderer.prototype.setElementClass = function (renderElement, className, isAdd) { };
        /**
         * @abstract
         * @param {?} renderElement
         * @param {?} styleName
         * @param {?} styleValue
         * @return {?}
         */
        Renderer.prototype.setElementStyle = function (renderElement, styleName, styleValue) { };
        /**
         * @abstract
         * @param {?} renderElement
         * @param {?} methodName
         * @param {?=} args
         * @return {?}
         */
        Renderer.prototype.invokeElementMethod = function (renderElement, methodName, args) { };
        /**
         * @abstract
         * @param {?} renderNode
         * @param {?} text
         * @return {?}
         */
        Renderer.prototype.setText = function (renderNode, text) { };
        /**
         * @abstract
         * @param {?} element
         * @param {?} startingStyles
         * @param {?} keyframes
         * @param {?} duration
         * @param {?} delay
         * @param {?} easing
         * @param {?=} previousPlayers
         * @return {?}
         */
        Renderer.prototype.animate = function (element, startingStyles, keyframes, duration, delay, easing, previousPlayers) { };
        return Renderer;
    }());
    /**
     * Injectable service that provides a low-level interface for modifying the UI.
     *
     * Use this service to bypass Angular's templating and make custom UI changes that can't be
     * expressed declaratively. For example if you need to set a property or an attribute whose name is
     * not statically known, use {\@link #setElementProperty} or {\@link #setElementAttribute}
     * respectively.
     *
     * If you are implementing a custom renderer, you must implement this interface.
     *
     * The default Renderer implementation is `DomRenderer`. Also available is `WebWorkerRenderer`.
     * \@experimental
     * @abstract
     */
    var RootRenderer = (function () {
        function RootRenderer() {
        }
        /**
         * @abstract
         * @param {?} componentType
         * @return {?}
         */
        RootRenderer.prototype.renderComponent = function (componentType) { };
        return RootRenderer;
    }());

    var SecurityContext = {};
    SecurityContext.NONE = 0;
    SecurityContext.HTML = 1;
    SecurityContext.STYLE = 2;
    SecurityContext.SCRIPT = 3;
    SecurityContext.URL = 4;
    SecurityContext.RESOURCE_URL = 5;
    SecurityContext[SecurityContext.NONE] = "NONE";
    SecurityContext[SecurityContext.HTML] = "HTML";
    SecurityContext[SecurityContext.STYLE] = "STYLE";
    SecurityContext[SecurityContext.SCRIPT] = "SCRIPT";
    SecurityContext[SecurityContext.URL] = "URL";
    SecurityContext[SecurityContext.RESOURCE_URL] = "RESOURCE_URL";
    /**
     * Sanitizer is used by the views to sanitize potentially dangerous values.
     *
     * \@stable
     * @abstract
     */
    var Sanitizer = (function () {
        function Sanitizer() {
        }
        /**
         * @abstract
         * @param {?} context
         * @param {?} value
         * @return {?}
         */
        Sanitizer.prototype.sanitize = function (context, value) { };
        return Sanitizer;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$7 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * An error thrown if application changes model breaking the top-down data flow.
     *
     * This exception is only thrown in dev mode.
     *
     * <!-- TODO: Add a link once the dev mode option is configurable -->
     *
     * ### Example
     *
     * ```typescript
     * \@Component({
     *   selector: 'parent',
     *   template: '<child [prop]="parentProp"></child>',
     * })
     * class Parent {
     *   parentProp = 'init';
     * }
     *
     * \@Directive({selector: 'child', inputs: ['prop']})
     * class Child {
     *   constructor(public parent: Parent) {}
     *
     *   set prop(v) {
     *     // this updates the parent property, which is disallowed during change detection
     *     // this will result in ExpressionChangedAfterItHasBeenCheckedError
     *     this.parent.parentProp = 'updated';
     *   }
     * }
     * ```
     * \@stable
     */
    var ExpressionChangedAfterItHasBeenCheckedError = (function (_super) {
        __extends$7(ExpressionChangedAfterItHasBeenCheckedError, _super);
        /**
         * @param {?} oldValue
         * @param {?} currValue
         */
        function ExpressionChangedAfterItHasBeenCheckedError(oldValue, currValue) {
            var msg = "Expression has changed after it was checked. Previous value: '" + oldValue + "'. Current value: '" + currValue + "'.";
            if (oldValue === UNINITIALIZED) {
                msg +=
                    " It seems like the view has been created after its parent and its children have been dirty checked." +
                        " Has it been created in a change detection hook ?";
            }
            _super.call(this, msg);
        }
        return ExpressionChangedAfterItHasBeenCheckedError;
    }(BaseError));
    /**
     * Thrown when an exception was raised during view creation, change detection or destruction.
     *
     * This error wraps the original exception to attach additional contextual information that can
     * be useful for debugging.
     * \@stable
     */
    var ViewWrappedError = (function (_super) {
        __extends$7(ViewWrappedError, _super);
        /**
         * @param {?} originalError
         * @param {?} context
         */
        function ViewWrappedError(originalError, context) {
            _super.call(this, "Error in " + context.source, originalError);
            this.context = context;
        }
        return ViewWrappedError;
    }(WrappedError));
    /**
     * Thrown when a destroyed view is used.
     *
     * This error indicates a bug in the framework.
     *
     * This is an internal Angular error.
     * \@stable
     */
    var ViewDestroyedError = (function (_super) {
        __extends$7(ViewDestroyedError, _super);
        /**
         * @param {?} details
         */
        function ViewDestroyedError(details) {
            _super.call(this, "Attempt to use a destroyed view: " + details);
        }
        return ViewDestroyedError;
    }(BaseError));

    var ViewUtils = (function () {
        /**
         * @param {?} _renderer
         * @param {?} sanitizer
         * @param {?} animationQueue
         */
        function ViewUtils(_renderer, sanitizer, animationQueue) {
            this._renderer = _renderer;
            this.animationQueue = animationQueue;
            this.sanitizer = sanitizer;
        }
        /**
         * \@internal
         * @param {?} renderComponentType
         * @return {?}
         */
        ViewUtils.prototype.renderComponent = function (renderComponentType) {
            return this._renderer.renderComponent(renderComponentType);
        };
        ViewUtils.decorators = [
            { type: Injectable },
        ];
        /** @nocollapse */
        ViewUtils.ctorParameters = function () { return [
            { type: RootRenderer, },
            { type: Sanitizer, },
            { type: AnimationQueue, },
        ]; };
        return ViewUtils;
    }());
    var /** @type {?} */ nextRenderComponentTypeId = 0;
    /**
     * @param {?} templateUrl
     * @param {?} slotCount
     * @param {?} encapsulation
     * @param {?} styles
     * @param {?} animations
     * @return {?}
     */
    function createRenderComponentType(templateUrl, slotCount, encapsulation, styles, animations) {
        return new RenderComponentType("" + nextRenderComponentTypeId++, templateUrl, slotCount, encapsulation, styles, animations);
    }
    /**
     * @param {?} e
     * @param {?} array
     * @return {?}
     */
    function addToArray(e, array) {
        array.push(e);
    }
    /**
     * @param {?} valueCount
     * @param {?} constAndInterp
     * @return {?}
     */
    function interpolate(valueCount, constAndInterp) {
        var /** @type {?} */ result = '';
        for (var /** @type {?} */ i = 0; i < valueCount * 2; i = i + 2) {
            result = result + constAndInterp[i] + _toStringWithNull(constAndInterp[i + 1]);
        }
        return result + constAndInterp[valueCount * 2];
    }
    /**
     * @param {?} valueCount
     * @param {?} c0
     * @param {?} a1
     * @param {?} c1
     * @param {?=} a2
     * @param {?=} c2
     * @param {?=} a3
     * @param {?=} c3
     * @param {?=} a4
     * @param {?=} c4
     * @param {?=} a5
     * @param {?=} c5
     * @param {?=} a6
     * @param {?=} c6
     * @param {?=} a7
     * @param {?=} c7
     * @param {?=} a8
     * @param {?=} c8
     * @param {?=} a9
     * @param {?=} c9
     * @return {?}
     */
    function inlineInterpolate(valueCount, c0, a1, c1, a2, c2, a3, c3, a4, c4, a5, c5, a6, c6, a7, c7, a8, c8, a9, c9) {
        switch (valueCount) {
            case 1:
                return c0 + _toStringWithNull(a1) + c1;
            case 2:
                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2;
            case 3:
                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
                    c3;
            case 4:
                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
                    c3 + _toStringWithNull(a4) + c4;
            case 5:
                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
                    c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5;
            case 6:
                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
                    c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) + c6;
            case 7:
                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
                    c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) +
                    c6 + _toStringWithNull(a7) + c7;
            case 8:
                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
                    c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) +
                    c6 + _toStringWithNull(a7) + c7 + _toStringWithNull(a8) + c8;
            case 9:
                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
                    c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) +
                    c6 + _toStringWithNull(a7) + c7 + _toStringWithNull(a8) + c8 + _toStringWithNull(a9) + c9;
            default:
                throw new Error("Does not support more than 9 expressions");
        }
    }
    /**
     * @param {?} v
     * @return {?}
     */
    function _toStringWithNull(v) {
        return v != null ? v.toString() : '';
    }
    /**
     * @param {?} throwOnChange
     * @param {?} oldValue
     * @param {?} newValue
     * @return {?}
     */
    function checkBinding(throwOnChange, oldValue, newValue) {
        if (throwOnChange) {
            if (!devModeEqual(oldValue, newValue)) {
                throw new ExpressionChangedAfterItHasBeenCheckedError(oldValue, newValue);
            }
            return false;
        }
        else {
            return !looseIdentical(oldValue, newValue);
        }
    }
    /**
     * @param {?} input
     * @param {?} value
     * @return {?}
     */
    function castByValue(input, value) {
        return (input);
    }
    var /** @type {?} */ EMPTY_ARRAY = [];
    var /** @type {?} */ EMPTY_MAP = {};
    /**
     * @param {?} fn
     * @return {?}
     */
    function pureProxy1(fn) {
        var /** @type {?} */ result;
        var /** @type {?} */ v0 = UNINITIALIZED;
        return function (p0) {
            if (!looseIdentical(v0, p0)) {
                v0 = p0;
                result = fn(p0);
            }
            return result;
        };
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    function pureProxy2(fn) {
        var /** @type {?} */ result;
        var /** @type {?} */ v0 = UNINITIALIZED;
        var /** @type {?} */ v1 = UNINITIALIZED;
        return function (p0, p1) {
            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1)) {
                v0 = p0;
                v1 = p1;
                result = fn(p0, p1);
            }
            return result;
        };
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    function pureProxy3(fn) {
        var /** @type {?} */ result;
        var /** @type {?} */ v0 = UNINITIALIZED;
        var /** @type {?} */ v1 = UNINITIALIZED;
        var /** @type {?} */ v2 = UNINITIALIZED;
        return function (p0, p1, p2) {
            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2)) {
                v0 = p0;
                v1 = p1;
                v2 = p2;
                result = fn(p0, p1, p2);
            }
            return result;
        };
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    function pureProxy4(fn) {
        var /** @type {?} */ result;
        var /** @type {?} */ v0, /** @type {?} */ v1, /** @type {?} */ v2, /** @type {?} */ v3;
        v0 = v1 = v2 = v3 = UNINITIALIZED;
        return function (p0, p1, p2, p3) {
            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) ||
                !looseIdentical(v3, p3)) {
                v0 = p0;
                v1 = p1;
                v2 = p2;
                v3 = p3;
                result = fn(p0, p1, p2, p3);
            }
            return result;
        };
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    function pureProxy5(fn) {
        var /** @type {?} */ result;
        var /** @type {?} */ v0, /** @type {?} */ v1, /** @type {?} */ v2, /** @type {?} */ v3, /** @type {?} */ v4;
        v0 = v1 = v2 = v3 = v4 = UNINITIALIZED;
        return function (p0, p1, p2, p3, p4) {
            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) ||
                !looseIdentical(v3, p3) || !looseIdentical(v4, p4)) {
                v0 = p0;
                v1 = p1;
                v2 = p2;
                v3 = p3;
                v4 = p4;
                result = fn(p0, p1, p2, p3, p4);
            }
            return result;
        };
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    function pureProxy6(fn) {
        var /** @type {?} */ result;
        var /** @type {?} */ v0, /** @type {?} */ v1, /** @type {?} */ v2, /** @type {?} */ v3, /** @type {?} */ v4, /** @type {?} */ v5;
        v0 = v1 = v2 = v3 = v4 = v5 = UNINITIALIZED;
        return function (p0, p1, p2, p3, p4, p5) {
            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) ||
                !looseIdentical(v3, p3) || !looseIdentical(v4, p4) || !looseIdentical(v5, p5)) {
                v0 = p0;
                v1 = p1;
                v2 = p2;
                v3 = p3;
                v4 = p4;
                v5 = p5;
                result = fn(p0, p1, p2, p3, p4, p5);
            }
            return result;
        };
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    function pureProxy7(fn) {
        var /** @type {?} */ result;
        var /** @type {?} */ v0, /** @type {?} */ v1, /** @type {?} */ v2, /** @type {?} */ v3, /** @type {?} */ v4, /** @type {?} */ v5, /** @type {?} */ v6;
        v0 = v1 = v2 = v3 = v4 = v5 = v6 = UNINITIALIZED;
        return function (p0, p1, p2, p3, p4, p5, p6) {
            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) ||
                !looseIdentical(v3, p3) || !looseIdentical(v4, p4) || !looseIdentical(v5, p5) ||
                !looseIdentical(v6, p6)) {
                v0 = p0;
                v1 = p1;
                v2 = p2;
                v3 = p3;
                v4 = p4;
                v5 = p5;
                v6 = p6;
                result = fn(p0, p1, p2, p3, p4, p5, p6);
            }
            return result;
        };
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    function pureProxy8(fn) {
        var /** @type {?} */ result;
        var /** @type {?} */ v0, /** @type {?} */ v1, /** @type {?} */ v2, /** @type {?} */ v3, /** @type {?} */ v4, /** @type {?} */ v5, /** @type {?} */ v6, /** @type {?} */ v7;
        v0 = v1 = v2 = v3 = v4 = v5 = v6 = v7 = UNINITIALIZED;
        return function (p0, p1, p2, p3, p4, p5, p6, p7) {
            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) ||
                !looseIdentical(v3, p3) || !looseIdentical(v4, p4) || !looseIdentical(v5, p5) ||
                !looseIdentical(v6, p6) || !looseIdentical(v7, p7)) {
                v0 = p0;
                v1 = p1;
                v2 = p2;
                v3 = p3;
                v4 = p4;
                v5 = p5;
                v6 = p6;
                v7 = p7;
                result = fn(p0, p1, p2, p3, p4, p5, p6, p7);
            }
            return result;
        };
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    function pureProxy9(fn) {
        var /** @type {?} */ result;
        var /** @type {?} */ v0, /** @type {?} */ v1, /** @type {?} */ v2, /** @type {?} */ v3, /** @type {?} */ v4, /** @type {?} */ v5, /** @type {?} */ v6, /** @type {?} */ v7, /** @type {?} */ v8;
        v0 = v1 = v2 = v3 = v4 = v5 = v6 = v7 = v8 = UNINITIALIZED;
        return function (p0, p1, p2, p3, p4, p5, p6, p7, p8) {
            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) ||
                !looseIdentical(v3, p3) || !looseIdentical(v4, p4) || !looseIdentical(v5, p5) ||
                !looseIdentical(v6, p6) || !looseIdentical(v7, p7) || !looseIdentical(v8, p8)) {
                v0 = p0;
                v1 = p1;
                v2 = p2;
                v3 = p3;
                v4 = p4;
                v5 = p5;
                v6 = p6;
                v7 = p7;
                v8 = p8;
                result = fn(p0, p1, p2, p3, p4, p5, p6, p7, p8);
            }
            return result;
        };
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    function pureProxy10(fn) {
        var /** @type {?} */ result;
        var /** @type {?} */ v0, /** @type {?} */ v1, /** @type {?} */ v2, /** @type {?} */ v3, /** @type {?} */ v4, /** @type {?} */ v5, /** @type {?} */ v6, /** @type {?} */ v7, /** @type {?} */ v8, /** @type {?} */ v9;
        v0 = v1 = v2 = v3 = v4 = v5 = v6 = v7 = v8 = v9 = UNINITIALIZED;
        return function (p0, p1, p2, p3, p4, p5, p6, p7, p8, p9) {
            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) ||
                !looseIdentical(v3, p3) || !looseIdentical(v4, p4) || !looseIdentical(v5, p5) ||
                !looseIdentical(v6, p6) || !looseIdentical(v7, p7) || !looseIdentical(v8, p8) ||
                !looseIdentical(v9, p9)) {
                v0 = p0;
                v1 = p1;
                v2 = p2;
                v3 = p3;
                v4 = p4;
                v5 = p5;
                v6 = p6;
                v7 = p7;
                v8 = p8;
                v9 = p9;
                result = fn(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
            }
            return result;
        };
    }
    /**
     * @param {?} renderer
     * @param {?} el
     * @param {?} changes
     * @return {?}
     */
    function setBindingDebugInfoForChanges(renderer, el, changes) {
        Object.keys(changes).forEach(function (propName) {
            setBindingDebugInfo(renderer, el, propName, changes[propName].currentValue);
        });
    }
    /**
     * @param {?} renderer
     * @param {?} el
     * @param {?} propName
     * @param {?} value
     * @return {?}
     */
    function setBindingDebugInfo(renderer, el, propName, value) {
        try {
            renderer.setBindingDebugInfo(el, "ng-reflect-" + camelCaseToDashCase(propName), value ? value.toString() : null);
        }
        catch (e) {
            renderer.setBindingDebugInfo(el, "ng-reflect-" + camelCaseToDashCase(propName), '[ERROR] Exception while trying to serialize the value');
        }
    }
    var /** @type {?} */ CAMEL_CASE_REGEXP = /([A-Z])/g;
    /**
     * @param {?} input
     * @return {?}
     */
    function camelCaseToDashCase(input) {
        return input.replace(CAMEL_CASE_REGEXP, function () {
            var m = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                m[_i - 0] = arguments[_i];
            }
            return '-' + m[1].toLowerCase();
        });
    }
    /**
     * @param {?} renderer
     * @param {?} parentElement
     * @param {?} name
     * @param {?} attrs
     * @param {?=} debugInfo
     * @return {?}
     */
    function createRenderElement(renderer, parentElement, name, attrs, debugInfo) {
        var /** @type {?} */ el = renderer.createElement(parentElement, name, debugInfo);
        for (var /** @type {?} */ i = 0; i < attrs.length; i += 2) {
            renderer.setElementAttribute(el, attrs.get(i), attrs.get(i + 1));
        }
        return el;
    }
    /**
     * @param {?} renderer
     * @param {?} elementName
     * @param {?} attrs
     * @param {?} rootSelectorOrNode
     * @param {?=} debugInfo
     * @return {?}
     */
    function selectOrCreateRenderHostElement(renderer, elementName, attrs, rootSelectorOrNode, debugInfo) {
        var /** @type {?} */ hostElement;
        if (isPresent(rootSelectorOrNode)) {
            hostElement = renderer.selectRootElement(rootSelectorOrNode, debugInfo);
            for (var /** @type {?} */ i = 0; i < attrs.length; i += 2) {
                renderer.setElementAttribute(hostElement, attrs.get(i), attrs.get(i + 1));
            }
            renderer.setElementAttribute(hostElement, 'ng-version', VERSION.full);
        }
        else {
            hostElement = createRenderElement(renderer, null, elementName, attrs, debugInfo);
        }
        return hostElement;
    }
    /**
     * @param {?} view
     * @param {?} element
     * @param {?} eventNamesAndTargets
     * @param {?} listener
     * @return {?}
     */
    function subscribeToRenderElement(view, element, eventNamesAndTargets, listener) {
        var /** @type {?} */ disposables = createEmptyInlineArray(eventNamesAndTargets.length / 2);
        for (var /** @type {?} */ i = 0; i < eventNamesAndTargets.length; i += 2) {
            var /** @type {?} */ eventName = eventNamesAndTargets.get(i);
            var /** @type {?} */ eventTarget = eventNamesAndTargets.get(i + 1);
            var /** @type {?} */ disposable = void 0;
            if (eventTarget) {
                disposable = view.renderer.listenGlobal(eventTarget, eventName, listener.bind(view, eventTarget + ":" + eventName));
            }
            else {
                disposable = view.renderer.listen(element, eventName, listener.bind(view, eventName));
            }
            disposables.set(i / 2, disposable);
        }
        return disposeInlineArray.bind(null, disposables);
    }
    /**
     * @param {?} disposables
     * @return {?}
     */
    function disposeInlineArray(disposables) {
        for (var /** @type {?} */ i = 0; i < disposables.length; i++) {
            disposables.get(i)();
        }
    }
    /**
     * @return {?}
     */
    function noop() { }
    /**
     * @param {?} length
     * @return {?}
     */
    function createEmptyInlineArray(length) {
        var /** @type {?} */ ctor;
        if (length <= 2) {
            ctor = InlineArray2;
        }
        else if (length <= 4) {
            ctor = InlineArray4;
        }
        else if (length <= 8) {
            ctor = InlineArray8;
        }
        else if (length <= 16) {
            ctor = InlineArray16;
        }
        else {
            ctor = InlineArrayDynamic;
        }
        return new ctor(length);
    }
    var InlineArray0 = (function () {
        function InlineArray0() {
            this.length = 0;
        }
        /**
         * @param {?} index
         * @return {?}
         */
        InlineArray0.prototype.get = function (index) { return undefined; };
        /**
         * @param {?} index
         * @param {?} value
         * @return {?}
         */
        InlineArray0.prototype.set = function (index, value) { };
        return InlineArray0;
    }());
    var InlineArray2 = (function () {
        /**
         * @param {?} length
         * @param {?=} _v0
         * @param {?=} _v1
         */
        function InlineArray2(length, _v0, _v1) {
            this.length = length;
            this._v0 = _v0;
            this._v1 = _v1;
        }
        /**
         * @param {?} index
         * @return {?}
         */
        InlineArray2.prototype.get = function (index) {
            switch (index) {
                case 0:
                    return this._v0;
                case 1:
                    return this._v1;
                default:
                    return undefined;
            }
        };
        /**
         * @param {?} index
         * @param {?} value
         * @return {?}
         */
        InlineArray2.prototype.set = function (index, value) {
            switch (index) {
                case 0:
                    this._v0 = value;
                    break;
                case 1:
                    this._v1 = value;
                    break;
            }
        };
        return InlineArray2;
    }());
    var InlineArray4 = (function () {
        /**
         * @param {?} length
         * @param {?=} _v0
         * @param {?=} _v1
         * @param {?=} _v2
         * @param {?=} _v3
         */
        function InlineArray4(length, _v0, _v1, _v2, _v3) {
            this.length = length;
            this._v0 = _v0;
            this._v1 = _v1;
            this._v2 = _v2;
            this._v3 = _v3;
        }
        /**
         * @param {?} index
         * @return {?}
         */
        InlineArray4.prototype.get = function (index) {
            switch (index) {
                case 0:
                    return this._v0;
                case 1:
                    return this._v1;
                case 2:
                    return this._v2;
                case 3:
                    return this._v3;
                default:
                    return undefined;
            }
        };
        /**
         * @param {?} index
         * @param {?} value
         * @return {?}
         */
        InlineArray4.prototype.set = function (index, value) {
            switch (index) {
                case 0:
                    this._v0 = value;
                    break;
                case 1:
                    this._v1 = value;
                    break;
                case 2:
                    this._v2 = value;
                    break;
                case 3:
                    this._v3 = value;
                    break;
            }
        };
        return InlineArray4;
    }());
    var InlineArray8 = (function () {
        /**
         * @param {?} length
         * @param {?=} _v0
         * @param {?=} _v1
         * @param {?=} _v2
         * @param {?=} _v3
         * @param {?=} _v4
         * @param {?=} _v5
         * @param {?=} _v6
         * @param {?=} _v7
         */
        function InlineArray8(length, _v0, _v1, _v2, _v3, _v4, _v5, _v6, _v7) {
            this.length = length;
            this._v0 = _v0;
            this._v1 = _v1;
            this._v2 = _v2;
            this._v3 = _v3;
            this._v4 = _v4;
            this._v5 = _v5;
            this._v6 = _v6;
            this._v7 = _v7;
        }
        /**
         * @param {?} index
         * @return {?}
         */
        InlineArray8.prototype.get = function (index) {
            switch (index) {
                case 0:
                    return this._v0;
                case 1:
                    return this._v1;
                case 2:
                    return this._v2;
                case 3:
                    return this._v3;
                case 4:
                    return this._v4;
                case 5:
                    return this._v5;
                case 6:
                    return this._v6;
                case 7:
                    return this._v7;
                default:
                    return undefined;
            }
        };
        /**
         * @param {?} index
         * @param {?} value
         * @return {?}
         */
        InlineArray8.prototype.set = function (index, value) {
            switch (index) {
                case 0:
                    this._v0 = value;
                    break;
                case 1:
                    this._v1 = value;
                    break;
                case 2:
                    this._v2 = value;
                    break;
                case 3:
                    this._v3 = value;
                    break;
                case 4:
                    this._v4 = value;
                    break;
                case 5:
                    this._v5 = value;
                    break;
                case 6:
                    this._v6 = value;
                    break;
                case 7:
                    this._v7 = value;
                    break;
            }
        };
        return InlineArray8;
    }());
    var InlineArray16 = (function () {
        /**
         * @param {?} length
         * @param {?=} _v0
         * @param {?=} _v1
         * @param {?=} _v2
         * @param {?=} _v3
         * @param {?=} _v4
         * @param {?=} _v5
         * @param {?=} _v6
         * @param {?=} _v7
         * @param {?=} _v8
         * @param {?=} _v9
         * @param {?=} _v10
         * @param {?=} _v11
         * @param {?=} _v12
         * @param {?=} _v13
         * @param {?=} _v14
         * @param {?=} _v15
         */
        function InlineArray16(length, _v0, _v1, _v2, _v3, _v4, _v5, _v6, _v7, _v8, _v9, _v10, _v11, _v12, _v13, _v14, _v15) {
            this.length = length;
            this._v0 = _v0;
            this._v1 = _v1;
            this._v2 = _v2;
            this._v3 = _v3;
            this._v4 = _v4;
            this._v5 = _v5;
            this._v6 = _v6;
            this._v7 = _v7;
            this._v8 = _v8;
            this._v9 = _v9;
            this._v10 = _v10;
            this._v11 = _v11;
            this._v12 = _v12;
            this._v13 = _v13;
            this._v14 = _v14;
            this._v15 = _v15;
        }
        /**
         * @param {?} index
         * @return {?}
         */
        InlineArray16.prototype.get = function (index) {
            switch (index) {
                case 0:
                    return this._v0;
                case 1:
                    return this._v1;
                case 2:
                    return this._v2;
                case 3:
                    return this._v3;
                case 4:
                    return this._v4;
                case 5:
                    return this._v5;
                case 6:
                    return this._v6;
                case 7:
                    return this._v7;
                case 8:
                    return this._v8;
                case 9:
                    return this._v9;
                case 10:
                    return this._v10;
                case 11:
                    return this._v11;
                case 12:
                    return this._v12;
                case 13:
                    return this._v13;
                case 14:
                    return this._v14;
                case 15:
                    return this._v15;
                default:
                    return undefined;
            }
        };
        /**
         * @param {?} index
         * @param {?} value
         * @return {?}
         */
        InlineArray16.prototype.set = function (index, value) {
            switch (index) {
                case 0:
                    this._v0 = value;
                    break;
                case 1:
                    this._v1 = value;
                    break;
                case 2:
                    this._v2 = value;
                    break;
                case 3:
                    this._v3 = value;
                    break;
                case 4:
                    this._v4 = value;
                    break;
                case 5:
                    this._v5 = value;
                    break;
                case 6:
                    this._v6 = value;
                    break;
                case 7:
                    this._v7 = value;
                    break;
                case 8:
                    this._v8 = value;
                    break;
                case 9:
                    this._v9 = value;
                    break;
                case 10:
                    this._v10 = value;
                    break;
                case 11:
                    this._v11 = value;
                    break;
                case 12:
                    this._v12 = value;
                    break;
                case 13:
                    this._v13 = value;
                    break;
                case 14:
                    this._v14 = value;
                    break;
                case 15:
                    this._v15 = value;
                    break;
            }
        };
        return InlineArray16;
    }());
    var InlineArrayDynamic = (function () {
        /**
         * @param {?} length
         * @param {...?} values
         */
        function InlineArrayDynamic(length) {
            var values = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                values[_i - 1] = arguments[_i];
            }
            this.length = length;
            this._values = values;
        }
        /**
         * @param {?} index
         * @return {?}
         */
        InlineArrayDynamic.prototype.get = function (index) { return this._values[index]; };
        /**
         * @param {?} index
         * @param {?} value
         * @return {?}
         */
        InlineArrayDynamic.prototype.set = function (index, value) { this._values[index] = value; };
        return InlineArrayDynamic;
    }());
    var /** @type {?} */ EMPTY_INLINE_ARRAY = new InlineArray0();


    var view_utils = Object.freeze({
        ViewUtils: ViewUtils,
        createRenderComponentType: createRenderComponentType,
        addToArray: addToArray,
        interpolate: interpolate,
        inlineInterpolate: inlineInterpolate,
        checkBinding: checkBinding,
        castByValue: castByValue,
        EMPTY_ARRAY: EMPTY_ARRAY,
        EMPTY_MAP: EMPTY_MAP,
        pureProxy1: pureProxy1,
        pureProxy2: pureProxy2,
        pureProxy3: pureProxy3,
        pureProxy4: pureProxy4,
        pureProxy5: pureProxy5,
        pureProxy6: pureProxy6,
        pureProxy7: pureProxy7,
        pureProxy8: pureProxy8,
        pureProxy9: pureProxy9,
        pureProxy10: pureProxy10,
        setBindingDebugInfoForChanges: setBindingDebugInfoForChanges,
        setBindingDebugInfo: setBindingDebugInfo,
        createRenderElement: createRenderElement,
        selectOrCreateRenderHostElement: selectOrCreateRenderHostElement,
        subscribeToRenderElement: subscribeToRenderElement,
        noop: noop,
        InlineArray2: InlineArray2,
        InlineArray4: InlineArray4,
        InlineArray8: InlineArray8,
        InlineArray16: InlineArray16,
        InlineArrayDynamic: InlineArrayDynamic,
        EMPTY_INLINE_ARRAY: EMPTY_INLINE_ARRAY
    });

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$5 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * Represents an instance of a Component created via a {\@link ComponentFactory}.
     *
     * `ComponentRef` provides access to the Component Instance as well other objects related to this
     * Component Instance and allows you to destroy the Component Instance via the {\@link #destroy}
     * method.
     * \@stable
     * @abstract
     */
    var ComponentRef = (function () {
        function ComponentRef() {
        }
        Object.defineProperty(ComponentRef.prototype, "location", {
            /**
             * Location of the Host Element of this Component Instance.
             * @return {?}
             */
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ComponentRef.prototype, "injector", {
            /**
             * The injector on which the component instance exists.
             * @return {?}
             */
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ComponentRef.prototype, "instance", {
            /**
             * The instance of the Component.
             * @return {?}
             */
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        ;
        Object.defineProperty(ComponentRef.prototype, "hostView", {
            /**
             * The {\@link ViewRef} of the Host View of this Component instance.
             * @return {?}
             */
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        ;
        Object.defineProperty(ComponentRef.prototype, "changeDetectorRef", {
            /**
             * The {\@link ChangeDetectorRef} of the Component instance.
             * @return {?}
             */
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ComponentRef.prototype, "componentType", {
            /**
             * The component type.
             * @return {?}
             */
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        /**
         * Destroys the component instance and all of the data structures associated with it.
         * @abstract
         * @return {?}
         */
        ComponentRef.prototype.destroy = function () { };
        /**
         * Allows to register a callback that will be called when the component is destroyed.
         * @abstract
         * @param {?} callback
         * @return {?}
         */
        ComponentRef.prototype.onDestroy = function (callback) { };
        return ComponentRef;
    }());
    var ComponentRef_ = (function (_super) {
        __extends$5(ComponentRef_, _super);
        /**
         * @param {?} _index
         * @param {?} _parentView
         * @param {?} _nativeElement
         * @param {?} _component
         */
        function ComponentRef_(_index, _parentView, _nativeElement, _component) {
            _super.call(this);
            this._index = _index;
            this._parentView = _parentView;
            this._nativeElement = _nativeElement;
            this._component = _component;
        }
        Object.defineProperty(ComponentRef_.prototype, "location", {
            /**
             * @return {?}
             */
            get: function () { return new ElementRef(this._nativeElement); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ComponentRef_.prototype, "injector", {
            /**
             * @return {?}
             */
            get: function () { return this._parentView.injector(this._index); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ComponentRef_.prototype, "instance", {
            /**
             * @return {?}
             */
            get: function () { return this._component; },
            enumerable: true,
            configurable: true
        });
        ;
        Object.defineProperty(ComponentRef_.prototype, "hostView", {
            /**
             * @return {?}
             */
            get: function () { return this._parentView.ref; },
            enumerable: true,
            configurable: true
        });
        ;
        Object.defineProperty(ComponentRef_.prototype, "changeDetectorRef", {
            /**
             * @return {?}
             */
            get: function () { return this._parentView.ref; },
            enumerable: true,
            configurable: true
        });
        ;
        Object.defineProperty(ComponentRef_.prototype, "componentType", {
            /**
             * @return {?}
             */
            get: function () { return (this._component.constructor); },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ComponentRef_.prototype.destroy = function () { this._parentView.detachAndDestroy(); };
        /**
         * @param {?} callback
         * @return {?}
         */
        ComponentRef_.prototype.onDestroy = function (callback) { this.hostView.onDestroy(callback); };
        return ComponentRef_;
    }(ComponentRef));
    /**
     * \@stable
     */
    var ComponentFactory = (function () {
        /**
         * @param {?} selector
         * @param {?} _viewClass
         * @param {?} _componentType
         */
        function ComponentFactory(selector, _viewClass, _componentType) {
            this.selector = selector;
            this._viewClass = _viewClass;
            this._componentType = _componentType;
        }
        Object.defineProperty(ComponentFactory.prototype, "componentType", {
            /**
             * @return {?}
             */
            get: function () { return this._componentType; },
            enumerable: true,
            configurable: true
        });
        /**
         * Creates a new component.
         * @param {?} injector
         * @param {?=} projectableNodes
         * @param {?=} rootSelectorOrNode
         * @return {?}
         */
        ComponentFactory.prototype.create = function (injector, projectableNodes, rootSelectorOrNode) {
            if (projectableNodes === void 0) { projectableNodes = null; }
            if (rootSelectorOrNode === void 0) { rootSelectorOrNode = null; }
            var /** @type {?} */ vu = injector.get(ViewUtils);
            if (!projectableNodes) {
                projectableNodes = [];
            }
            var /** @type {?} */ hostView = new this._viewClass(vu, null, null, null);
            return hostView.createHostView(rootSelectorOrNode, injector, projectableNodes);
        };
        return ComponentFactory;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$8 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * \@stable
     */
    var NoComponentFactoryError = (function (_super) {
        __extends$8(NoComponentFactoryError, _super);
        /**
         * @param {?} component
         */
        function NoComponentFactoryError(component) {
            _super.call(this, "No component factory found for " + stringify(component) + ". Did you add it to @NgModule.entryComponents?");
            this.component = component;
        }
        return NoComponentFactoryError;
    }(BaseError));
    var _NullComponentFactoryResolver = (function () {
        function _NullComponentFactoryResolver() {
        }
        /**
         * @param {?} component
         * @return {?}
         */
        _NullComponentFactoryResolver.prototype.resolveComponentFactory = function (component) {
            throw new NoComponentFactoryError(component);
        };
        return _NullComponentFactoryResolver;
    }());
    /**
     * \@stable
     * @abstract
     */
    var ComponentFactoryResolver = (function () {
        function ComponentFactoryResolver() {
        }
        /**
         * @abstract
         * @param {?} component
         * @return {?}
         */
        ComponentFactoryResolver.prototype.resolveComponentFactory = function (component) { };
        ComponentFactoryResolver.NULL = new _NullComponentFactoryResolver();
        return ComponentFactoryResolver;
    }());
    var CodegenComponentFactoryResolver = (function () {
        /**
         * @param {?} factories
         * @param {?} _parent
         */
        function CodegenComponentFactoryResolver(factories, _parent) {
            this._parent = _parent;
            this._factories = new Map();
            for (var i = 0; i < factories.length; i++) {
                var factory = factories[i];
                this._factories.set(factory.componentType, factory);
            }
        }
        /**
         * @param {?} component
         * @return {?}
         */
        CodegenComponentFactoryResolver.prototype.resolveComponentFactory = function (component) {
            var /** @type {?} */ result = this._factories.get(component);
            if (!result) {
                result = this._parent.resolveComponentFactory(component);
            }
            return result;
        };
        return CodegenComponentFactoryResolver;
    }());

    var /** @type {?} */ trace;
    var /** @type {?} */ events;
    /**
     * @return {?}
     */
    function detectWTF() {
        var /** @type {?} */ wtf = ((global$1) /** TODO #9100 */)['wtf'];
        if (wtf) {
            trace = wtf['trace'];
            if (trace) {
                events = trace['events'];
                return true;
            }
        }
        return false;
    }
    /**
     * @param {?} signature
     * @param {?=} flags
     * @return {?}
     */
    function createScope(signature, flags) {
        if (flags === void 0) { flags = null; }
        return events.createScope(signature, flags);
    }
    /**
     * @param {?} scope
     * @param {?=} returnValue
     * @return {?}
     */
    function leave(scope, returnValue) {
        trace.leaveScope(scope, returnValue);
        return returnValue;
    }
    /**
     * @param {?} rangeType
     * @param {?} action
     * @return {?}
     */
    function startTimeRange(rangeType, action) {
        return trace.beginTimeRange(rangeType, action);
    }
    /**
     * @param {?} range
     * @return {?}
     */
    function endTimeRange(range) {
        trace.endTimeRange(range);
    }

    /**
     * True if WTF is enabled.
     */
    var /** @type {?} */ wtfEnabled = detectWTF();
    /**
     * @param {?=} arg0
     * @param {?=} arg1
     * @return {?}
     */
    function noopScope(arg0, arg1) {
        return null;
    }
    /**
     * Create trace scope.
     *
     * Scopes must be strictly nested and are analogous to stack frames, but
     * do not have to follow the stack frames. Instead it is recommended that they follow logical
     * nesting. You may want to use
     * [Event
     * Signatures](http://google.github.io/tracing-framework/instrumenting-code.html#custom-events)
     * as they are defined in WTF.
     *
     * Used to mark scope entry. The return value is used to leave the scope.
     *
     *     var myScope = wtfCreateScope('MyClass#myMethod(ascii someVal)');
     *
     *     someMethod() {
     *        var s = myScope('Foo'); // 'Foo' gets stored in tracing UI
     *        // DO SOME WORK HERE
     *        return wtfLeave(s, 123); // Return value 123
     *     }
     *
     * Note, adding try-finally block around the work to ensure that `wtfLeave` gets called can
     * negatively impact the performance of your application. For this reason we recommend that
     * you don't add them to ensure that `wtfLeave` gets called. In production `wtfLeave` is a noop and
     * so try-finally block has no value. When debugging perf issues, skipping `wtfLeave`, do to
     * exception, will produce incorrect trace, but presence of exception signifies logic error which
     * needs to be fixed before the app should be profiled. Add try-finally only when you expect that
     * an exception is expected during normal execution while profiling.
     *
     * @experimental
     */
    var /** @type {?} */ wtfCreateScope = wtfEnabled ? createScope : function (signature, flags) { return noopScope; };
    /**
     * Used to mark end of Scope.
     *
     * - `scope` to end.
     * - `returnValue` (optional) to be passed to the WTF.
     *
     * Returns the `returnValue for easy chaining.
     * @experimental
     */
    var /** @type {?} */ wtfLeave = wtfEnabled ? leave : function (s, r) { return r; };
    /**
     * Used to mark Async start. Async are similar to scope but they don't have to be strictly nested.
     * The return value is used in the call to [endAsync]. Async ranges only work if WTF has been
     * enabled.
     *
     *     someMethod() {
     *        var s = wtfStartTimeRange('HTTP:GET', 'some.url');
     *        var future = new Future.delay(5).then((_) {
     *          wtfEndTimeRange(s);
     *        });
     *     }
     * @experimental
     */
    var /** @type {?} */ wtfStartTimeRange = wtfEnabled ? startTimeRange : function (rangeType, action) { return null; };
    /**
     * Ends a async time range operation.
     * [range] is the return value from [wtfStartTimeRange] Async ranges only work if WTF has been
     * enabled.
     * @experimental
     */
    var /** @type {?} */ wtfEndTimeRange = wtfEnabled ? endTimeRange : function (r) { return null; };

    /**
     * The Testability service provides testing hooks that can be accessed from
     * the browser and by services such as Protractor. Each bootstrapped Angular
     * application on the page will have an instance of Testability.
     * \@experimental
     */
    var Testability = (function () {
        /**
         * @param {?} _ngZone
         */
        function Testability(_ngZone) {
            this._ngZone = _ngZone;
            /** @internal */
            this._pendingCount = 0;
            /** @internal */
            this._isZoneStable = true;
            /**
             * Whether any work was done since the last 'whenStable' callback. This is
             * useful to detect if this could have potentially destabilized another
             * component while it is stabilizing.
             * @internal
             */
            this._didWork = false;
            /** @internal */
            this._callbacks = [];
            this._watchAngularEvents();
        }
        /**
         * \@internal
         * @return {?}
         */
        Testability.prototype._watchAngularEvents = function () {
            var _this = this;
            this._ngZone.onUnstable.subscribe({
                next: function () {
                    _this._didWork = true;
                    _this._isZoneStable = false;
                }
            });
            this._ngZone.runOutsideAngular(function () {
                _this._ngZone.onStable.subscribe({
                    next: function () {
                        NgZone.assertNotInAngularZone();
                        scheduleMicroTask(function () {
                            _this._isZoneStable = true;
                            _this._runCallbacksIfReady();
                        });
                    }
                });
            });
        };
        /**
         * @return {?}
         */
        Testability.prototype.increasePendingRequestCount = function () {
            this._pendingCount += 1;
            this._didWork = true;
            return this._pendingCount;
        };
        /**
         * @return {?}
         */
        Testability.prototype.decreasePendingRequestCount = function () {
            this._pendingCount -= 1;
            if (this._pendingCount < 0) {
                throw new Error('pending async requests below zero');
            }
            this._runCallbacksIfReady();
            return this._pendingCount;
        };
        /**
         * @return {?}
         */
        Testability.prototype.isStable = function () {
            return this._isZoneStable && this._pendingCount == 0 && !this._ngZone.hasPendingMacrotasks;
        };
        /**
         * \@internal
         * @return {?}
         */
        Testability.prototype._runCallbacksIfReady = function () {
            var _this = this;
            if (this.isStable()) {
                // Schedules the call backs in a new frame so that it is always async.
                scheduleMicroTask(function () {
                    while (_this._callbacks.length !== 0) {
                        (_this._callbacks.pop())(_this._didWork);
                    }
                    _this._didWork = false;
                });
            }
            else {
                // Not Ready
                this._didWork = true;
            }
        };
        /**
         * @param {?} callback
         * @return {?}
         */
        Testability.prototype.whenStable = function (callback) {
            this._callbacks.push(callback);
            this._runCallbacksIfReady();
        };
        /**
         * @return {?}
         */
        Testability.prototype.getPendingRequestCount = function () { return this._pendingCount; };
        /**
         * @deprecated use findProviders
         * @param {?} using
         * @param {?} provider
         * @param {?} exactMatch
         * @return {?}
         */
        Testability.prototype.findBindings = function (using, provider, exactMatch) {
            // TODO(juliemr): implement.
            return [];
        };
        /**
         * @param {?} using
         * @param {?} provider
         * @param {?} exactMatch
         * @return {?}
         */
        Testability.prototype.findProviders = function (using, provider, exactMatch) {
            // TODO(juliemr): implement.
            return [];
        };
        Testability.decorators = [
            { type: Injectable },
        ];
        /** @nocollapse */
        Testability.ctorParameters = function () { return [
            { type: NgZone, },
        ]; };
        return Testability;
    }());
    /**
     * A global registry of {\@link Testability} instances for specific elements.
     * \@experimental
     */
    var TestabilityRegistry = (function () {
        function TestabilityRegistry() {
            /** @internal */
            this._applications = new Map();
            _testabilityGetter.addToWindow(this);
        }
        /**
         * @param {?} token
         * @param {?} testability
         * @return {?}
         */
        TestabilityRegistry.prototype.registerApplication = function (token, testability) {
            this._applications.set(token, testability);
        };
        /**
         * @param {?} elem
         * @return {?}
         */
        TestabilityRegistry.prototype.getTestability = function (elem) { return this._applications.get(elem); };
        /**
         * @return {?}
         */
        TestabilityRegistry.prototype.getAllTestabilities = function () { return Array.from(this._applications.values()); };
        /**
         * @return {?}
         */
        TestabilityRegistry.prototype.getAllRootElements = function () { return Array.from(this._applications.keys()); };
        /**
         * @param {?} elem
         * @param {?=} findInAncestors
         * @return {?}
         */
        TestabilityRegistry.prototype.findTestabilityInTree = function (elem, findInAncestors) {
            if (findInAncestors === void 0) { findInAncestors = true; }
            return _testabilityGetter.findTestabilityInTree(this, elem, findInAncestors);
        };
        TestabilityRegistry.decorators = [
            { type: Injectable },
        ];
        /** @nocollapse */
        TestabilityRegistry.ctorParameters = function () { return []; };
        return TestabilityRegistry;
    }());
    var _NoopGetTestability = (function () {
        function _NoopGetTestability() {
        }
        /**
         * @param {?} registry
         * @return {?}
         */
        _NoopGetTestability.prototype.addToWindow = function (registry) { };
        /**
         * @param {?} registry
         * @param {?} elem
         * @param {?} findInAncestors
         * @return {?}
         */
        _NoopGetTestability.prototype.findTestabilityInTree = function (registry, elem, findInAncestors) {
            return null;
        };
        return _NoopGetTestability;
    }());
    /**
     * Set the {\@link GetTestability} implementation used by the Angular testing framework.
     * \@experimental
     * @param {?} getter
     * @return {?}
     */
    function setTestabilityGetter(getter) {
        _testabilityGetter = getter;
    }
    var /** @type {?} */ _testabilityGetter = new _NoopGetTestability();

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$3 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var /** @type {?} */ _devMode = true;
    var /** @type {?} */ _runModeLocked = false;
    var /** @type {?} */ _platform;
    /**
     * Disable Angular's development mode, which turns off assertions and other
     * checks within the framework.
     *
     * One important assertion this disables verifies that a change detection pass
     * does not result in additional changes to any bindings (also known as
     * unidirectional data flow).
     *
     * \@stable
     * @return {?}
     */
    function enableProdMode() {
        if (_runModeLocked) {
            throw new Error('Cannot enable prod mode after platform setup.');
        }
        _devMode = false;
    }
    /**
     * Returns whether Angular is in development mode. After called once,
     * the value is locked and won't change any more.
     *
     * By default, this is true, unless a user calls `enableProdMode` before calling this.
     *
     * \@experimental APIs related to application bootstrap are currently under review.
     * @return {?}
     */
    function isDevMode() {
        _runModeLocked = true;
        return _devMode;
    }
    /**
     * A token for third-party components that can register themselves with NgProbe.
     *
     * \@experimental
     */
    var NgProbeToken = (function () {
        /**
         * @param {?} name
         * @param {?} token
         */
        function NgProbeToken(name, token) {
            this.name = name;
            this.token = token;
        }
        return NgProbeToken;
    }());
    /**
     * Creates a platform.
     * Platforms have to be eagerly created via this function.
     *
     * \@experimental APIs related to application bootstrap are currently under review.
     * @param {?} injector
     * @return {?}
     */
    function createPlatform(injector) {
        if (_platform && !_platform.destroyed) {
            throw new Error('There can be only one platform. Destroy the previous one to create a new one.');
        }
        _platform = injector.get(PlatformRef);
        var /** @type {?} */ inits = (injector.get(PLATFORM_INITIALIZER, null));
        if (inits)
            inits.forEach(function (init) { return init(); });
        return _platform;
    }
    /**
     * Creates a factory for a platform
     *
     * \@experimental APIs related to application bootstrap are currently under review.
     * @param {?} parentPlatformFactory
     * @param {?} name
     * @param {?=} providers
     * @return {?}
     */
    function createPlatformFactory(parentPlatformFactory, name, providers) {
        if (providers === void 0) { providers = []; }
        var /** @type {?} */ marker = new OpaqueToken("Platform: " + name);
        return function (extraProviders) {
            if (extraProviders === void 0) { extraProviders = []; }
            if (!getPlatform()) {
                if (parentPlatformFactory) {
                    parentPlatformFactory(providers.concat(extraProviders).concat({ provide: marker, useValue: true }));
                }
                else {
                    createPlatform(ReflectiveInjector.resolveAndCreate(providers.concat(extraProviders).concat({ provide: marker, useValue: true })));
                }
            }
            return assertPlatform(marker);
        };
    }
    /**
     * Checks that there currently is a platform
     * which contains the given token as a provider.
     *
     * \@experimental APIs related to application bootstrap are currently under review.
     * @param {?} requiredToken
     * @return {?}
     */
    function assertPlatform(requiredToken) {
        var /** @type {?} */ platform = getPlatform();
        if (!platform) {
            throw new Error('No platform exists!');
        }
        if (!platform.injector.get(requiredToken, null)) {
            throw new Error('A platform with a different configuration has been created. Please destroy it first.');
        }
        return platform;
    }
    /**
     * Destroy the existing platform.
     *
     * \@experimental APIs related to application bootstrap are currently under review.
     * @return {?}
     */
    function destroyPlatform() {
        if (_platform && !_platform.destroyed) {
            _platform.destroy();
        }
    }
    /**
     * Returns the current platform.
     *
     * \@experimental APIs related to application bootstrap are currently under review.
     * @return {?}
     */
    function getPlatform() {
        return _platform && !_platform.destroyed ? _platform : null;
    }
    /**
     * The Angular platform is the entry point for Angular on a web page. Each page
     * has exactly one platform, and services (such as reflection) which are common
     * to every Angular application running on the page are bound in its scope.
     *
     * A page's platform is initialized implicitly when {\@link bootstrap}() is called, or
     * explicitly by calling {\@link createPlatform}().
     *
     * \@stable
     * @abstract
     */
    var PlatformRef = (function () {
        function PlatformRef() {
        }
        /**
         * Creates an instance of an `\@NgModule` for the given platform
         * for offline compilation.
         *
         * ## Simple Example
         *
         * ```typescript
         * my_module.ts:
         *
         * \@NgModule({
         *   imports: [BrowserModule]
         * })
         * class MyModule {}
         *
         * main.ts:
         * import {MyModuleNgFactory} from './my_module.ngfactory';
         * import {platformBrowser} from '\@angular/platform-browser';
         *
         * let moduleRef = platformBrowser().bootstrapModuleFactory(MyModuleNgFactory);
         * ```
         *
         * \@experimental APIs related to application bootstrap are currently under review.
         * @param {?} moduleFactory
         * @return {?}
         */
        PlatformRef.prototype.bootstrapModuleFactory = function (moduleFactory) {
            throw unimplemented();
        };
        /**
         * Creates an instance of an `\@NgModule` for a given platform using the given runtime compiler.
         *
         * ## Simple Example
         *
         * ```typescript
         * \@NgModule({
         *   imports: [BrowserModule]
         * })
         * class MyModule {}
         *
         * let moduleRef = platformBrowser().bootstrapModule(MyModule);
         * ```
         * \@stable
         * @param {?} moduleType
         * @param {?=} compilerOptions
         * @return {?}
         */
        PlatformRef.prototype.bootstrapModule = function (moduleType, compilerOptions) {
            if (compilerOptions === void 0) { compilerOptions = []; }
            throw unimplemented();
        };
        /**
         * Register a listener to be called when the platform is disposed.
         * @abstract
         * @param {?} callback
         * @return {?}
         */
        PlatformRef.prototype.onDestroy = function (callback) { };
        Object.defineProperty(PlatformRef.prototype, "injector", {
            /**
             * Retrieve the platform {\@link Injector}, which is the parent injector for
             * every Angular application on the page and provides singleton providers.
             * @return {?}
             */
            get: function () { throw unimplemented(); },
            enumerable: true,
            configurable: true
        });
        ;
        /**
         * Destroy the Angular platform and all Angular applications on the page.
         * @abstract
         * @return {?}
         */
        PlatformRef.prototype.destroy = function () { };
        Object.defineProperty(PlatformRef.prototype, "destroyed", {
            /**
             * @return {?}
             */
            get: function () { throw unimplemented(); },
            enumerable: true,
            configurable: true
        });
        return PlatformRef;
    }());
    /**
     * @param {?} errorHandler
     * @param {?} callback
     * @return {?}
     */
    function _callAndReportToErrorHandler(errorHandler, callback) {
        try {
            var /** @type {?} */ result = callback();
            if (isPromise(result)) {
                return result.catch(function (e) {
                    errorHandler.handleError(e);
                    // rethrow as the exception handler might not do it
                    throw e;
                });
            }
            return result;
        }
        catch (e) {
            errorHandler.handleError(e);
            // rethrow as the exception handler might not do it
            throw e;
        }
    }
    var PlatformRef_ = (function (_super) {
        __extends$3(PlatformRef_, _super);
        /**
         * @param {?} _injector
         */
        function PlatformRef_(_injector) {
            _super.call(this);
            this._injector = _injector;
            this._modules = [];
            this._destroyListeners = [];
            this._destroyed = false;
        }
        /**
         * @param {?} callback
         * @return {?}
         */
        PlatformRef_.prototype.onDestroy = function (callback) { this._destroyListeners.push(callback); };
        Object.defineProperty(PlatformRef_.prototype, "injector", {
            /**
             * @return {?}
             */
            get: function () { return this._injector; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PlatformRef_.prototype, "destroyed", {
            /**
             * @return {?}
             */
            get: function () { return this._destroyed; },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        PlatformRef_.prototype.destroy = function () {
            if (this._destroyed) {
                throw new Error('The platform has already been destroyed!');
            }
            this._modules.slice().forEach(function (module) { return module.destroy(); });
            this._destroyListeners.forEach(function (listener) { return listener(); });
            this._destroyed = true;
        };
        /**
         * @param {?} moduleFactory
         * @return {?}
         */
        PlatformRef_.prototype.bootstrapModuleFactory = function (moduleFactory) {
            return this._bootstrapModuleFactoryWithZone(moduleFactory, null);
        };
        /**
         * @param {?} moduleFactory
         * @param {?} ngZone
         * @return {?}
         */
        PlatformRef_.prototype._bootstrapModuleFactoryWithZone = function (moduleFactory, ngZone) {
            var _this = this;
            // Note: We need to create the NgZone _before_ we instantiate the module,
            // as instantiating the module creates some providers eagerly.
            // So we create a mini parent injector that just contains the new NgZone and
            // pass that as parent to the NgModuleFactory.
            if (!ngZone)
                ngZone = new NgZone({ enableLongStackTrace: isDevMode() });
            // Attention: Don't use ApplicationRef.run here,
            // as we want to be sure that all possible constructor calls are inside `ngZone.run`!
            return ngZone.run(function () {
                var /** @type {?} */ ngZoneInjector = ReflectiveInjector.resolveAndCreate([{ provide: NgZone, useValue: ngZone }], _this.injector);
                var /** @type {?} */ moduleRef = (moduleFactory.create(ngZoneInjector));
                var /** @type {?} */ exceptionHandler = moduleRef.injector.get(ErrorHandler, null);
                if (!exceptionHandler) {
                    throw new Error('No ErrorHandler. Is platform module (BrowserModule) included?');
                }
                moduleRef.onDestroy(function () { return ListWrapper.remove(_this._modules, moduleRef); });
                ngZone.onError.subscribe({ next: function (error) { exceptionHandler.handleError(error); } });
                return _callAndReportToErrorHandler(exceptionHandler, function () {
                    var /** @type {?} */ initStatus = moduleRef.injector.get(ApplicationInitStatus);
                    return initStatus.donePromise.then(function () {
                        _this._moduleDoBootstrap(moduleRef);
                        return moduleRef;
                    });
                });
            });
        };
        /**
         * @param {?} moduleType
         * @param {?=} compilerOptions
         * @return {?}
         */
        PlatformRef_.prototype.bootstrapModule = function (moduleType, compilerOptions) {
            if (compilerOptions === void 0) { compilerOptions = []; }
            return this._bootstrapModuleWithZone(moduleType, compilerOptions, null);
        };
        /**
         * @param {?} moduleType
         * @param {?=} compilerOptions
         * @param {?} ngZone
         * @param {?=} componentFactoryCallback
         * @return {?}
         */
        PlatformRef_.prototype._bootstrapModuleWithZone = function (moduleType, compilerOptions, ngZone, componentFactoryCallback) {
            var _this = this;
            if (compilerOptions === void 0) { compilerOptions = []; }
            var /** @type {?} */ compilerFactory = this.injector.get(CompilerFactory);
            var /** @type {?} */ compiler = compilerFactory.createCompiler(Array.isArray(compilerOptions) ? compilerOptions : [compilerOptions]);
            // ugly internal api hack: generate host component factories for all declared components and
            // pass the factories into the callback - this is used by UpdateAdapter to get hold of all
            // factories.
            if (componentFactoryCallback) {
                return compiler.compileModuleAndAllComponentsAsync(moduleType)
                    .then(function (_a) {
                    var ngModuleFactory = _a.ngModuleFactory, componentFactories = _a.componentFactories;
                    componentFactoryCallback(componentFactories);
                    return _this._bootstrapModuleFactoryWithZone(ngModuleFactory, ngZone);
                });
            }
            return compiler.compileModuleAsync(moduleType)
                .then(function (moduleFactory) { return _this._bootstrapModuleFactoryWithZone(moduleFactory, ngZone); });
        };
        /**
         * @param {?} moduleRef
         * @return {?}
         */
        PlatformRef_.prototype._moduleDoBootstrap = function (moduleRef) {
            var /** @type {?} */ appRef = moduleRef.injector.get(ApplicationRef);
            if (moduleRef.bootstrapFactories.length > 0) {
                moduleRef.bootstrapFactories.forEach(function (compFactory) { return appRef.bootstrap(compFactory); });
            }
            else if (moduleRef.instance.ngDoBootstrap) {
                moduleRef.instance.ngDoBootstrap(appRef);
            }
            else {
                throw new Error(("The module " + stringify(moduleRef.instance.constructor) + " was bootstrapped, but it does not declare \"@NgModule.bootstrap\" components nor a \"ngDoBootstrap\" method. ") +
                    "Please define one of these.");
            }
        };
        PlatformRef_.decorators = [
            { type: Injectable },
        ];
        /** @nocollapse */
        PlatformRef_.ctorParameters = function () { return [
            { type: Injector, },
        ]; };
        return PlatformRef_;
    }(PlatformRef));
    /**
     * A reference to an Angular application running on a page.
     *
     * For more about Angular applications, see the documentation for {\@link bootstrap}.
     *
     * \@stable
     * @abstract
     */
    var ApplicationRef = (function () {
        function ApplicationRef() {
        }
        /**
         * Bootstrap a new component at the root level of the application.
         *
         * ### Bootstrap process
         *
         * When bootstrapping a new root component into an application, Angular mounts the
         * specified application component onto DOM elements identified by the [componentType]'s
         * selector and kicks off automatic change detection to finish initializing the component.
         *
         * ### Example
         * {\@example core/ts/platform/platform.ts region='longform'}
         * @abstract
         * @param {?} componentFactory
         * @return {?}
         */
        ApplicationRef.prototype.bootstrap = function (componentFactory) { };
        /**
         * Invoke this method to explicitly process change detection and its side-effects.
         *
         * In development mode, `tick()` also performs a second change detection cycle to ensure that no
         * further changes are detected. If additional changes are picked up during this second cycle,
         * bindings in the app have side-effects that cannot be resolved in a single change detection
         * pass.
         * In this case, Angular throws an error, since an Angular application can only have one change
         * detection pass during which all change detection must complete.
         * @abstract
         * @return {?}
         */
        ApplicationRef.prototype.tick = function () { };
        Object.defineProperty(ApplicationRef.prototype, "componentTypes", {
            /**
             * Get a list of component types registered to this application.
             * This list is populated even before the component is created.
             * @return {?}
             */
            get: function () { return (unimplemented()); },
            enumerable: true,
            configurable: true
        });
        ;
        Object.defineProperty(ApplicationRef.prototype, "components", {
            /**
             * Get a list of components registered to this application.
             * @return {?}
             */
            get: function () { return (unimplemented()); },
            enumerable: true,
            configurable: true
        });
        ;
        /**
         * Attaches a view so that it will be dirty checked.
         * The view will be automatically detached when it is destroyed.
         * This will throw if the view is already attached to a ViewContainer.
         * @param {?} view
         * @return {?}
         */
        ApplicationRef.prototype.attachView = function (view) { unimplemented(); };
        /**
         * Detaches a view from dirty checking again.
         * @param {?} view
         * @return {?}
         */
        ApplicationRef.prototype.detachView = function (view) { unimplemented(); };
        Object.defineProperty(ApplicationRef.prototype, "viewCount", {
            /**
             * Returns the number of attached views.
             * @return {?}
             */
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        return ApplicationRef;
    }());
    var ApplicationRef_ = (function (_super) {
        __extends$3(ApplicationRef_, _super);
        /**
         * @param {?} _zone
         * @param {?} _console
         * @param {?} _injector
         * @param {?} _exceptionHandler
         * @param {?} _componentFactoryResolver
         * @param {?} _initStatus
         * @param {?} _testabilityRegistry
         * @param {?} _testability
         */
        function ApplicationRef_(_zone, _console, _injector, _exceptionHandler, _componentFactoryResolver, _initStatus, _testabilityRegistry, _testability) {
            var _this = this;
            _super.call(this);
            this._zone = _zone;
            this._console = _console;
            this._injector = _injector;
            this._exceptionHandler = _exceptionHandler;
            this._componentFactoryResolver = _componentFactoryResolver;
            this._initStatus = _initStatus;
            this._testabilityRegistry = _testabilityRegistry;
            this._testability = _testability;
            this._bootstrapListeners = [];
            this._rootComponents = [];
            this._rootComponentTypes = [];
            this._views = [];
            this._runningTick = false;
            this._enforceNoNewChanges = false;
            this._enforceNoNewChanges = isDevMode();
            this._zone.onMicrotaskEmpty.subscribe({ next: function () { _this._zone.run(function () { _this.tick(); }); } });
        }
        /**
         * @param {?} viewRef
         * @return {?}
         */
        ApplicationRef_.prototype.attachView = function (viewRef) {
            var /** @type {?} */ view = ((viewRef)).internalView;
            this._views.push(view);
            view.attachToAppRef(this);
        };
        /**
         * @param {?} viewRef
         * @return {?}
         */
        ApplicationRef_.prototype.detachView = function (viewRef) {
            var /** @type {?} */ view = ((viewRef)).internalView;
            ListWrapper.remove(this._views, view);
            view.detach();
        };
        /**
         * @param {?} componentOrFactory
         * @return {?}
         */
        ApplicationRef_.prototype.bootstrap = function (componentOrFactory) {
            var _this = this;
            if (!this._initStatus.done) {
                throw new Error('Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module.');
            }
            var /** @type {?} */ componentFactory;
            if (componentOrFactory instanceof ComponentFactory) {
                componentFactory = componentOrFactory;
            }
            else {
                componentFactory = this._componentFactoryResolver.resolveComponentFactory(componentOrFactory);
            }
            this._rootComponentTypes.push(componentFactory.componentType);
            var /** @type {?} */ compRef = componentFactory.create(this._injector, [], componentFactory.selector);
            compRef.onDestroy(function () { _this._unloadComponent(compRef); });
            var /** @type {?} */ testability = compRef.injector.get(Testability, null);
            if (testability) {
                compRef.injector.get(TestabilityRegistry)
                    .registerApplication(compRef.location.nativeElement, testability);
            }
            this._loadComponent(compRef);
            if (isDevMode()) {
                this._console.log("Angular is running in the development mode. Call enableProdMode() to enable the production mode.");
            }
            return compRef;
        };
        /**
         * @param {?} componentRef
         * @return {?}
         */
        ApplicationRef_.prototype._loadComponent = function (componentRef) {
            this.attachView(componentRef.hostView);
            this.tick();
            this._rootComponents.push(componentRef);
            // Get the listeners lazily to prevent DI cycles.
            var /** @type {?} */ listeners = (this._injector.get(APP_BOOTSTRAP_LISTENER, [])
                .concat(this._bootstrapListeners));
            listeners.forEach(function (listener) { return listener(componentRef); });
        };
        /**
         * @param {?} componentRef
         * @return {?}
         */
        ApplicationRef_.prototype._unloadComponent = function (componentRef) {
            this.detachView(componentRef.hostView);
            ListWrapper.remove(this._rootComponents, componentRef);
        };
        /**
         * @return {?}
         */
        ApplicationRef_.prototype.tick = function () {
            if (this._runningTick) {
                throw new Error('ApplicationRef.tick is called recursively');
            }
            var /** @type {?} */ scope = ApplicationRef_._tickScope();
            try {
                this._runningTick = true;
                this._views.forEach(function (view) { return view.ref.detectChanges(); });
                if (this._enforceNoNewChanges) {
                    this._views.forEach(function (view) { return view.ref.checkNoChanges(); });
                }
            }
            finally {
                this._runningTick = false;
                wtfLeave(scope);
            }
        };
        /**
         * @return {?}
         */
        ApplicationRef_.prototype.ngOnDestroy = function () {
            // TODO(alxhub): Dispose of the NgZone.
            this._views.slice().forEach(function (view) { return view.destroy(); });
        };
        Object.defineProperty(ApplicationRef_.prototype, "viewCount", {
            /**
             * @return {?}
             */
            get: function () { return this._views.length; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ApplicationRef_.prototype, "componentTypes", {
            /**
             * @return {?}
             */
            get: function () { return this._rootComponentTypes; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ApplicationRef_.prototype, "components", {
            /**
             * @return {?}
             */
            get: function () { return this._rootComponents; },
            enumerable: true,
            configurable: true
        });
        /** @internal */
        ApplicationRef_._tickScope = wtfCreateScope('ApplicationRef#tick()');
        ApplicationRef_.decorators = [
            { type: Injectable },
        ];
        /** @nocollapse */
        ApplicationRef_.ctorParameters = function () { return [
            { type: NgZone, },
            { type: Console, },
            { type: Injector, },
            { type: ErrorHandler, },
            { type: ComponentFactoryResolver, },
            { type: ApplicationInitStatus, },
            { type: TestabilityRegistry, decorators: [{ type: Optional },] },
            { type: Testability, decorators: [{ type: Optional },] },
        ]; };
        return ApplicationRef_;
    }(ApplicationRef));

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$9 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * Represents an instance of an NgModule created via a {\@link NgModuleFactory}.
     *
     * `NgModuleRef` provides access to the NgModule Instance as well other objects related to this
     * NgModule Instance.
     *
     * \@stable
     * @abstract
     */
    var NgModuleRef = (function () {
        function NgModuleRef() {
        }
        Object.defineProperty(NgModuleRef.prototype, "injector", {
            /**
             * The injector that contains all of the providers of the NgModule.
             * @return {?}
             */
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgModuleRef.prototype, "componentFactoryResolver", {
            /**
             * The ComponentFactoryResolver to get hold of the ComponentFactories
             * declared in the `entryComponents` property of the module.
             * @return {?}
             */
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgModuleRef.prototype, "instance", {
            /**
             * The NgModule instance.
             * @return {?}
             */
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        /**
         * Destroys the module instance and all of the data structures associated with it.
         * @abstract
         * @return {?}
         */
        NgModuleRef.prototype.destroy = function () { };
        /**
         * Allows to register a callback that will be called when the module is destroyed.
         * @abstract
         * @param {?} callback
         * @return {?}
         */
        NgModuleRef.prototype.onDestroy = function (callback) { };
        return NgModuleRef;
    }());
    /**
     * \@experimental
     */
    var NgModuleFactory = (function () {
        /**
         * @param {?} _injectorClass
         * @param {?} _moduleType
         */
        function NgModuleFactory(_injectorClass, _moduleType) {
            this._injectorClass = _injectorClass;
            this._moduleType = _moduleType;
        }
        Object.defineProperty(NgModuleFactory.prototype, "moduleType", {
            /**
             * @return {?}
             */
            get: function () { return this._moduleType; },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} parentInjector
         * @return {?}
         */
        NgModuleFactory.prototype.create = function (parentInjector) {
            if (!parentInjector) {
                parentInjector = Injector.NULL;
            }
            var /** @type {?} */ instance = new this._injectorClass(parentInjector);
            instance.create();
            return instance;
        };
        return NgModuleFactory;
    }());
    var /** @type {?} */ _UNDEFINED = new Object();
    /**
     * @abstract
     */
    var NgModuleInjector = (function (_super) {
        __extends$9(NgModuleInjector, _super);
        /**
         * @param {?} parent
         * @param {?} factories
         * @param {?} bootstrapFactories
         */
        function NgModuleInjector(parent, factories, bootstrapFactories) {
            _super.call(this, factories, parent.get(ComponentFactoryResolver, ComponentFactoryResolver.NULL));
            this.parent = parent;
            this.bootstrapFactories = bootstrapFactories;
            this._destroyListeners = [];
            this._destroyed = false;
        }
        /**
         * @return {?}
         */
        NgModuleInjector.prototype.create = function () { this.instance = this.createInternal(); };
        /**
         * @abstract
         * @return {?}
         */
        NgModuleInjector.prototype.createInternal = function () { };
        /**
         * @param {?} token
         * @param {?=} notFoundValue
         * @return {?}
         */
        NgModuleInjector.prototype.get = function (token, notFoundValue) {
            if (notFoundValue === void 0) { notFoundValue = THROW_IF_NOT_FOUND; }
            if (token === Injector || token === ComponentFactoryResolver) {
                return this;
            }
            var /** @type {?} */ result = this.getInternal(token, _UNDEFINED);
            return result === _UNDEFINED ? this.parent.get(token, notFoundValue) : result;
        };
        /**
         * @abstract
         * @param {?} token
         * @param {?} notFoundValue
         * @return {?}
         */
        NgModuleInjector.prototype.getInternal = function (token, notFoundValue) { };
        Object.defineProperty(NgModuleInjector.prototype, "injector", {
            /**
             * @return {?}
             */
            get: function () { return this; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgModuleInjector.prototype, "componentFactoryResolver", {
            /**
             * @return {?}
             */
            get: function () { return this; },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NgModuleInjector.prototype.destroy = function () {
            if (this._destroyed) {
                throw new Error("The ng module " + stringify(this.instance.constructor) + " has already been destroyed.");
            }
            this._destroyed = true;
            this.destroyInternal();
            this._destroyListeners.forEach(function (listener) { return listener(); });
        };
        /**
         * @param {?} callback
         * @return {?}
         */
        NgModuleInjector.prototype.onDestroy = function (callback) { this._destroyListeners.push(callback); };
        /**
         * @abstract
         * @return {?}
         */
        NgModuleInjector.prototype.destroyInternal = function () { };
        return NgModuleInjector;
    }(CodegenComponentFactoryResolver));

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Used to load ng module factories.
     * \@stable
     * @abstract
     */
    var NgModuleFactoryLoader = (function () {
        function NgModuleFactoryLoader() {
        }
        /**
         * @abstract
         * @param {?} path
         * @return {?}
         */
        NgModuleFactoryLoader.prototype.load = function (path) { };
        return NgModuleFactoryLoader;
    }());
    var /** @type {?} */ moduleFactories = new Map();
    /**
     * Registers a loaded module. Should only be called from generated NgModuleFactory code.
     * \@experimental
     * @param {?} id
     * @param {?} factory
     * @return {?}
     */
    function registerModuleFactory(id, factory) {
        var /** @type {?} */ existing = moduleFactories.get(id);
        if (existing) {
            throw new Error("Duplicate module registered for " + id + " - " + existing.moduleType.name + " vs " + factory.moduleType.name);
        }
        moduleFactories.set(id, factory);
    }
    /**
     * Returns the NgModuleFactory with the given id, if it exists and has been loaded.
     * Factories for modules that do not specify an `id` cannot be retrieved. Throws if the module
     * cannot be found.
     * \@experimental
     * @param {?} id
     * @return {?}
     */
    function getModuleFactory(id) {
        var /** @type {?} */ factory = moduleFactories.get(id);
        if (!factory)
            throw new Error("No module with ID " + id + " loaded");
        return factory;
    }

    /**
     * An unmodifiable list of items that Angular keeps up to date when the state
     * of the application changes.
     *
     * The type of object that {\@link Query} and {\@link ViewQueryMetadata} provide.
     *
     * Implements an iterable interface, therefore it can be used in both ES6
     * javascript `for (var i of items)` loops as well as in Angular templates with
     * `*ngFor="let i of myList"`.
     *
     * Changes can be observed by subscribing to the changes `Observable`.
     *
     * NOTE: In the future this class will implement an `Observable` interface.
     *
     * ### Example ([live demo](http://plnkr.co/edit/RX8sJnQYl9FWuSCWme5z?p=preview))
     * ```typescript
     * \@Component({...})
     * class Container {
     *   \@ViewChildren(Item) items:QueryList<Item>;
     * }
     * ```
     * \@stable
     */
    var QueryList = (function () {
        function QueryList() {
            this._dirty = true;
            this._results = [];
            this._emitter = new EventEmitter();
        }
        Object.defineProperty(QueryList.prototype, "changes", {
            /**
             * @return {?}
             */
            get: function () { return this._emitter; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(QueryList.prototype, "length", {
            /**
             * @return {?}
             */
            get: function () { return this._results.length; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(QueryList.prototype, "first", {
            /**
             * @return {?}
             */
            get: function () { return this._results[0]; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(QueryList.prototype, "last", {
            /**
             * @return {?}
             */
            get: function () { return this._results[this.length - 1]; },
            enumerable: true,
            configurable: true
        });
        /**
         * See
         * [Array.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)
         * @param {?} fn
         * @return {?}
         */
        QueryList.prototype.map = function (fn) { return this._results.map(fn); };
        /**
         * See
         * [Array.filter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)
         * @param {?} fn
         * @return {?}
         */
        QueryList.prototype.filter = function (fn) {
            return this._results.filter(fn);
        };
        /**
         * See
         * [Array.find](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find)
         * @param {?} fn
         * @return {?}
         */
        QueryList.prototype.find = function (fn) { return this._results.find(fn); };
        /**
         * See
         * [Array.reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)
         * @param {?} fn
         * @param {?} init
         * @return {?}
         */
        QueryList.prototype.reduce = function (fn, init) {
            return this._results.reduce(fn, init);
        };
        /**
         * See
         * [Array.forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)
         * @param {?} fn
         * @return {?}
         */
        QueryList.prototype.forEach = function (fn) { this._results.forEach(fn); };
        /**
         * See
         * [Array.some](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some)
         * @param {?} fn
         * @return {?}
         */
        QueryList.prototype.some = function (fn) {
            return this._results.some(fn);
        };
        /**
         * @return {?}
         */
        QueryList.prototype.toArray = function () { return this._results.slice(); };
        /**
         * @return {?}
         */
        QueryList.prototype[getSymbolIterator()] = function () { return ((this._results))[getSymbolIterator()](); };
        /**
         * @return {?}
         */
        QueryList.prototype.toString = function () { return this._results.toString(); };
        /**
         * @param {?} res
         * @return {?}
         */
        QueryList.prototype.reset = function (res) {
            this._results = ListWrapper.flatten(res);
            this._dirty = false;
        };
        /**
         * @return {?}
         */
        QueryList.prototype.notifyOnChanges = function () { this._emitter.emit(this); };
        /**
         * internal
         * @return {?}
         */
        QueryList.prototype.setDirty = function () { this._dirty = true; };
        Object.defineProperty(QueryList.prototype, "dirty", {
            /**
             * internal
             * @return {?}
             */
            get: function () { return this._dirty; },
            enumerable: true,
            configurable: true
        });
        return QueryList;
    }());

    var /** @type {?} */ _SEPARATOR = '#';
    var /** @type {?} */ FACTORY_CLASS_SUFFIX = 'NgFactory';
    /**
     * Configuration for SystemJsNgModuleLoader.
     * token.
     *
     * \@experimental
     * @abstract
     */
    var SystemJsNgModuleLoaderConfig = (function () {
        function SystemJsNgModuleLoaderConfig() {
        }
        return SystemJsNgModuleLoaderConfig;
    }());
    var /** @type {?} */ DEFAULT_CONFIG = {
        factoryPathPrefix: '',
        factoryPathSuffix: '.ngfactory',
    };
    /**
     * NgModuleFactoryLoader that uses SystemJS to load NgModuleFactory
     * \@experimental
     */
    var SystemJsNgModuleLoader = (function () {
        /**
         * @param {?} _compiler
         * @param {?=} config
         */
        function SystemJsNgModuleLoader(_compiler, config) {
            this._compiler = _compiler;
            this._config = config || DEFAULT_CONFIG;
        }
        /**
         * @param {?} path
         * @return {?}
         */
        SystemJsNgModuleLoader.prototype.load = function (path) {
            var /** @type {?} */ offlineMode = this._compiler instanceof Compiler;
            return offlineMode ? this.loadFactory(path) : this.loadAndCompile(path);
        };
        /**
         * @param {?} path
         * @return {?}
         */
        SystemJsNgModuleLoader.prototype.loadAndCompile = function (path) {
            var _this = this;
            var _a = path.split(_SEPARATOR), module = _a[0], exportName = _a[1];
            if (exportName === undefined) {
                exportName = 'default';
            }
            return System.import(module)
                .then(function (module) { return module[exportName]; })
                .then(function (type) { return checkNotEmpty(type, module, exportName); })
                .then(function (type) { return _this._compiler.compileModuleAsync(type); });
        };
        /**
         * @param {?} path
         * @return {?}
         */
        SystemJsNgModuleLoader.prototype.loadFactory = function (path) {
            var _a = path.split(_SEPARATOR), module = _a[0], exportName = _a[1];
            var /** @type {?} */ factoryClassSuffix = FACTORY_CLASS_SUFFIX;
            if (exportName === undefined) {
                exportName = 'default';
                factoryClassSuffix = '';
            }
            return System.import(this._config.factoryPathPrefix + module + this._config.factoryPathSuffix)
                .then(function (module) { return module[exportName + factoryClassSuffix]; })
                .then(function (factory) { return checkNotEmpty(factory, module, exportName); });
        };
        SystemJsNgModuleLoader.decorators = [
            { type: Injectable },
        ];
        /** @nocollapse */
        SystemJsNgModuleLoader.ctorParameters = function () { return [
            { type: Compiler, },
            { type: SystemJsNgModuleLoaderConfig, decorators: [{ type: Optional },] },
        ]; };
        return SystemJsNgModuleLoader;
    }());
    /**
     * @param {?} value
     * @param {?} modulePath
     * @param {?} exportName
     * @return {?}
     */
    function checkNotEmpty(value, modulePath, exportName) {
        if (!value) {
            throw new Error("Cannot find '" + exportName + "' in '" + modulePath + "'");
        }
        return value;
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$10 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * Represents an Embedded Template that can be used to instantiate Embedded Views.
     *
     * You can access a `TemplateRef`, in two ways. Via a directive placed on a `<template>` element (or
     * directive prefixed with `*`) and have the `TemplateRef` for this Embedded View injected into the
     * constructor of the directive using the `TemplateRef` Token. Alternatively you can query for the
     * `TemplateRef` from a Component or a Directive via {\@link Query}.
     *
     * To instantiate Embedded Views based on a Template, use
     * {\@link ViewContainerRef#createEmbeddedView}, which will create the View and attach it to the
     * View Container.
     * \@stable
     * @abstract
     */
    var TemplateRef = (function () {
        function TemplateRef() {
        }
        Object.defineProperty(TemplateRef.prototype, "elementRef", {
            /**
             * @return {?}
             */
            get: function () { return null; },
            enumerable: true,
            configurable: true
        });
        /**
         * @abstract
         * @param {?} context
         * @return {?}
         */
        TemplateRef.prototype.createEmbeddedView = function (context) { };
        return TemplateRef;
    }());
    var TemplateRef_ = (function (_super) {
        __extends$10(TemplateRef_, _super);
        /**
         * @param {?} _parentView
         * @param {?} _nodeIndex
         * @param {?} _nativeElement
         */
        function TemplateRef_(_parentView, _nodeIndex, _nativeElement) {
            _super.call(this);
            this._parentView = _parentView;
            this._nodeIndex = _nodeIndex;
            this._nativeElement = _nativeElement;
        }
        /**
         * @param {?} context
         * @return {?}
         */
        TemplateRef_.prototype.createEmbeddedView = function (context) {
            var /** @type {?} */ view = this._parentView.createEmbeddedViewInternal(this._nodeIndex);
            view.create(context || ({}));
            return view.ref;
        };
        Object.defineProperty(TemplateRef_.prototype, "elementRef", {
            /**
             * @return {?}
             */
            get: function () { return new ElementRef(this._nativeElement); },
            enumerable: true,
            configurable: true
        });
        return TemplateRef_;
    }(TemplateRef));

    /**
     * Represents a container where one or more Views can be attached.
     *
     * The container can contain two kinds of Views. Host Views, created by instantiating a
     * {\@link Component} via {\@link #createComponent}, and Embedded Views, created by instantiating an
     * {\@link TemplateRef Embedded Template} via {\@link #createEmbeddedView}.
     *
     * The location of the View Container within the containing View is specified by the Anchor
     * `element`. Each View Container can have only one Anchor Element and each Anchor Element can only
     * have a single View Container.
     *
     * Root elements of Views attached to this container become siblings of the Anchor Element in
     * the Rendered View.
     *
     * To access a `ViewContainerRef` of an Element, you can either place a {\@link Directive} injected
     * with `ViewContainerRef` on the Element, or you obtain it via a {\@link ViewChild} query.
     * \@stable
     * @abstract
     */
    var ViewContainerRef = (function () {
        function ViewContainerRef() {
        }
        Object.defineProperty(ViewContainerRef.prototype, "element", {
            /**
             * Anchor element that specifies the location of this container in the containing View.
             * <!-- TODO: rename to anchorElement -->
             * @return {?}
             */
            get: function () { return (unimplemented()); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ViewContainerRef.prototype, "injector", {
            /**
             * @return {?}
             */
            get: function () { return (unimplemented()); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ViewContainerRef.prototype, "parentInjector", {
            /**
             * @return {?}
             */
            get: function () { return (unimplemented()); },
            enumerable: true,
            configurable: true
        });
        /**
         * Destroys all Views in this container.
         * @abstract
         * @return {?}
         */
        ViewContainerRef.prototype.clear = function () { };
        /**
         * Returns the {\@link ViewRef} for the View located in this container at the specified index.
         * @abstract
         * @param {?} index
         * @return {?}
         */
        ViewContainerRef.prototype.get = function (index) { };
        Object.defineProperty(ViewContainerRef.prototype, "length", {
            /**
             * Returns the number of Views currently attached to this container.
             * @return {?}
             */
            get: function () { return (unimplemented()); },
            enumerable: true,
            configurable: true
        });
        ;
        /**
         * Instantiates an Embedded View based on the {\@link TemplateRef `templateRef`} and inserts it
         * into this container at the specified `index`.
         *
         * If `index` is not specified, the new View will be inserted as the last View in the container.
         *
         * Returns the {\@link ViewRef} for the newly created View.
         * @abstract
         * @param {?} templateRef
         * @param {?=} context
         * @param {?=} index
         * @return {?}
         */
        ViewContainerRef.prototype.createEmbeddedView = function (templateRef, context, index) { };
        /**
         * Instantiates a single {\@link Component} and inserts its Host View into this container at the
         * specified `index`.
         *
         * The component is instantiated using its {\@link ComponentFactory} which can be
         * obtained via {\@link ComponentFactoryResolver#resolveComponentFactory}.
         *
         * If `index` is not specified, the new View will be inserted as the last View in the container.
         *
         * You can optionally specify the {\@link Injector} that will be used as parent for the Component.
         *
         * Returns the {\@link ComponentRef} of the Host View created for the newly instantiated Component.
         * @abstract
         * @param {?} componentFactory
         * @param {?=} index
         * @param {?=} injector
         * @param {?=} projectableNodes
         * @return {?}
         */
        ViewContainerRef.prototype.createComponent = function (componentFactory, index, injector, projectableNodes) { };
        /**
         * Inserts a View identified by a {\@link ViewRef} into the container at the specified `index`.
         *
         * If `index` is not specified, the new View will be inserted as the last View in the container.
         *
         * Returns the inserted {\@link ViewRef}.
         * @abstract
         * @param {?} viewRef
         * @param {?=} index
         * @return {?}
         */
        ViewContainerRef.prototype.insert = function (viewRef, index) { };
        /**
         * Moves a View identified by a {\@link ViewRef} into the container at the specified `index`.
         *
         * Returns the inserted {\@link ViewRef}.
         * @abstract
         * @param {?} viewRef
         * @param {?} currentIndex
         * @return {?}
         */
        ViewContainerRef.prototype.move = function (viewRef, currentIndex) { };
        /**
         * Returns the index of the View, specified via {\@link ViewRef}, within the current container or
         * `-1` if this container doesn't contain the View.
         * @abstract
         * @param {?} viewRef
         * @return {?}
         */
        ViewContainerRef.prototype.indexOf = function (viewRef) { };
        /**
         * Destroys a View attached to this container at the specified `index`.
         *
         * If `index` is not specified, the last View in the container will be removed.
         * @abstract
         * @param {?=} index
         * @return {?}
         */
        ViewContainerRef.prototype.remove = function (index) { };
        /**
         * Use along with {\@link #insert} to move a View within the current container.
         *
         * If the `index` param is omitted, the last {\@link ViewRef} is detached.
         * @abstract
         * @param {?=} index
         * @return {?}
         */
        ViewContainerRef.prototype.detach = function (index) { };
        return ViewContainerRef;
    }());
    var ViewContainerRef_ = (function () {
        /**
         * @param {?} _element
         */
        function ViewContainerRef_(_element) {
            this._element = _element;
            /** @internal */
            this._createComponentInContainerScope = wtfCreateScope('ViewContainerRef#createComponent()');
            /** @internal */
            this._insertScope = wtfCreateScope('ViewContainerRef#insert()');
            /** @internal */
            this._removeScope = wtfCreateScope('ViewContainerRef#remove()');
            /** @internal */
            this._detachScope = wtfCreateScope('ViewContainerRef#detach()');
        }
        /**
         * @param {?} index
         * @return {?}
         */
        ViewContainerRef_.prototype.get = function (index) { return this._element.nestedViews[index].ref; };
        Object.defineProperty(ViewContainerRef_.prototype, "length", {
            /**
             * @return {?}
             */
            get: function () {
                var /** @type {?} */ views = this._element.nestedViews;
                return isPresent(views) ? views.length : 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ViewContainerRef_.prototype, "element", {
            /**
             * @return {?}
             */
            get: function () { return this._element.elementRef; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ViewContainerRef_.prototype, "injector", {
            /**
             * @return {?}
             */
            get: function () { return this._element.injector; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ViewContainerRef_.prototype, "parentInjector", {
            /**
             * @return {?}
             */
            get: function () { return this._element.parentInjector; },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} templateRef
         * @param {?=} context
         * @param {?=} index
         * @return {?}
         */
        ViewContainerRef_.prototype.createEmbeddedView = function (templateRef, context, index) {
            if (context === void 0) { context = null; }
            if (index === void 0) { index = -1; }
            var /** @type {?} */ viewRef = templateRef.createEmbeddedView(context);
            this.insert(viewRef, index);
            return viewRef;
        };
        /**
         * @param {?} componentFactory
         * @param {?=} index
         * @param {?=} injector
         * @param {?=} projectableNodes
         * @return {?}
         */
        ViewContainerRef_.prototype.createComponent = function (componentFactory, index, injector, projectableNodes) {
            if (index === void 0) { index = -1; }
            if (injector === void 0) { injector = null; }
            if (projectableNodes === void 0) { projectableNodes = null; }
            var /** @type {?} */ s = this._createComponentInContainerScope();
            var /** @type {?} */ contextInjector = injector || this._element.parentInjector;
            var /** @type {?} */ componentRef = componentFactory.create(contextInjector, projectableNodes);
            this.insert(componentRef.hostView, index);
            return wtfLeave(s, componentRef);
        };
        /**
         * @param {?} viewRef
         * @param {?=} index
         * @return {?}
         */
        ViewContainerRef_.prototype.insert = function (viewRef, index) {
            if (index === void 0) { index = -1; }
            var /** @type {?} */ s = this._insertScope();
            if (index == -1)
                index = this.length;
            var /** @type {?} */ viewRef_ = (viewRef);
            this._element.attachView(viewRef_.internalView, index);
            return wtfLeave(s, viewRef_);
        };
        /**
         * @param {?} viewRef
         * @param {?} currentIndex
         * @return {?}
         */
        ViewContainerRef_.prototype.move = function (viewRef, currentIndex) {
            var /** @type {?} */ s = this._insertScope();
            if (currentIndex == -1)
                return;
            var /** @type {?} */ viewRef_ = (viewRef);
            this._element.moveView(viewRef_.internalView, currentIndex);
            return wtfLeave(s, viewRef_);
        };
        /**
         * @param {?} viewRef
         * @return {?}
         */
        ViewContainerRef_.prototype.indexOf = function (viewRef) {
            return this._element.nestedViews.indexOf(((viewRef)).internalView);
        };
        /**
         * @param {?=} index
         * @return {?}
         */
        ViewContainerRef_.prototype.remove = function (index) {
            if (index === void 0) { index = -1; }
            var /** @type {?} */ s = this._removeScope();
            if (index == -1)
                index = this.length - 1;
            var /** @type {?} */ view = this._element.detachView(index);
            view.destroy();
            // view is intentionally not returned to the client.
            wtfLeave(s);
        };
        /**
         * @param {?=} index
         * @return {?}
         */
        ViewContainerRef_.prototype.detach = function (index) {
            if (index === void 0) { index = -1; }
            var /** @type {?} */ s = this._detachScope();
            if (index == -1)
                index = this.length - 1;
            var /** @type {?} */ view = this._element.detachView(index);
            return wtfLeave(s, view.ref);
        };
        /**
         * @return {?}
         */
        ViewContainerRef_.prototype.clear = function () {
            for (var /** @type {?} */ i = this.length - 1; i >= 0; i--) {
                this.remove(i);
            }
        };
        return ViewContainerRef_;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$11 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * \@stable
     * @abstract
     */
    var ViewRef = (function (_super) {
        __extends$11(ViewRef, _super);
        function ViewRef() {
            _super.apply(this, arguments);
        }
        /**
         * Destroys the view and all of the data structures associated with it.
         * @abstract
         * @return {?}
         */
        ViewRef.prototype.destroy = function () { };
        Object.defineProperty(ViewRef.prototype, "destroyed", {
            /**
             * @return {?}
             */
            get: function () { return (unimplemented()); },
            enumerable: true,
            configurable: true
        });
        /**
         * @abstract
         * @param {?} callback
         * @return {?}
         */
        ViewRef.prototype.onDestroy = function (callback) { };
        return ViewRef;
    }(ChangeDetectorRef));
    /**
     * Represents an Angular View.
     *
     * <!-- TODO: move the next two paragraphs to the dev guide -->
     * A View is a fundamental building block of the application UI. It is the smallest grouping of
     * Elements which are created and destroyed together.
     *
     * Properties of elements in a View can change, but the structure (number and order) of elements in
     * a View cannot. Changing the structure of Elements can only be done by inserting, moving or
     * removing nested Views via a {\@link ViewContainerRef}. Each View can contain many View Containers.
     * <!-- /TODO -->
     *
     * ### Example
     *
     * Given this template...
     *
     * ```
     * Count: {{items.length}}
     * <ul>
     *   <li *ngFor="let  item of items">{{item}}</li>
     * </ul>
     * ```
     *
     * We have two {\@link TemplateRef}s:
     *
     * Outer {\@link TemplateRef}:
     * ```
     * Count: {{items.length}}
     * <ul>
     *   <template ngFor let-item [ngForOf]="items"></template>
     * </ul>
     * ```
     *
     * Inner {\@link TemplateRef}:
     * ```
     *   <li>{{item}}</li>
     * ```
     *
     * Notice that the original template is broken down into two separate {\@link TemplateRef}s.
     *
     * The outer/inner {\@link TemplateRef}s are then assembled into views like so:
     *
     * ```
     * <!-- ViewRef: outer-0 -->
     * Count: 2
     * <ul>
     *   <template view-container-ref></template>
     *   <!-- ViewRef: inner-1 --><li>first</li><!-- /ViewRef: inner-1 -->
     *   <!-- ViewRef: inner-2 --><li>second</li><!-- /ViewRef: inner-2 -->
     * </ul>
     * <!-- /ViewRef: outer-0 -->
     * ```
     * \@experimental
     * @abstract
     */
    var EmbeddedViewRef = (function (_super) {
        __extends$11(EmbeddedViewRef, _super);
        function EmbeddedViewRef() {
            _super.apply(this, arguments);
        }
        Object.defineProperty(EmbeddedViewRef.prototype, "context", {
            /**
             * @return {?}
             */
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EmbeddedViewRef.prototype, "rootNodes", {
            /**
             * @return {?}
             */
            get: function () { return (unimplemented()); },
            enumerable: true,
            configurable: true
        });
        ;
        return EmbeddedViewRef;
    }(ViewRef));
    var ViewRef_ = (function () {
        /**
         * @param {?} _view
         * @param {?} animationQueue
         */
        function ViewRef_(_view, animationQueue) {
            this._view = _view;
            this.animationQueue = animationQueue;
            this._view = _view;
            this._originalMode = this._view.cdMode;
        }
        Object.defineProperty(ViewRef_.prototype, "internalView", {
            /**
             * @return {?}
             */
            get: function () { return this._view; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ViewRef_.prototype, "rootNodes", {
            /**
             * @return {?}
             */
            get: function () { return this._view.flatRootNodes; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ViewRef_.prototype, "context", {
            /**
             * @return {?}
             */
            get: function () { return this._view.context; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ViewRef_.prototype, "destroyed", {
            /**
             * @return {?}
             */
            get: function () { return this._view.destroyed; },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ViewRef_.prototype.markForCheck = function () { this._view.markPathToRootAsCheckOnce(); };
        /**
         * @return {?}
         */
        ViewRef_.prototype.detach = function () { this._view.cdMode = ChangeDetectorStatus.Detached; };
        /**
         * @return {?}
         */
        ViewRef_.prototype.detectChanges = function () {
            this._view.detectChanges(false);
            this.animationQueue.flush();
        };
        /**
         * @return {?}
         */
        ViewRef_.prototype.checkNoChanges = function () { this._view.detectChanges(true); };
        /**
         * @return {?}
         */
        ViewRef_.prototype.reattach = function () {
            this._view.cdMode = this._originalMode;
            this.markForCheck();
        };
        /**
         * @param {?} callback
         * @return {?}
         */
        ViewRef_.prototype.onDestroy = function (callback) {
            if (!this._view.disposables) {
                this._view.disposables = [];
            }
            this._view.disposables.push(callback);
        };
        /**
         * @return {?}
         */
        ViewRef_.prototype.destroy = function () { this._view.detachAndDestroy(); };
        return ViewRef_;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$12 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var EventListener = (function () {
        /**
         * @param {?} name
         * @param {?} callback
         */
        function EventListener(name, callback) {
            this.name = name;
            this.callback = callback;
        }
        ;
        return EventListener;
    }());
    /**
     * \@experimental All debugging apis are currently experimental.
     */
    var DebugNode = (function () {
        /**
         * @param {?} nativeNode
         * @param {?} parent
         * @param {?} _debugInfo
         */
        function DebugNode(nativeNode, parent, _debugInfo) {
            this._debugInfo = _debugInfo;
            this.nativeNode = nativeNode;
            if (parent && parent instanceof DebugElement) {
                parent.addChild(this);
            }
            else {
                this.parent = null;
            }
            this.listeners = [];
        }
        Object.defineProperty(DebugNode.prototype, "injector", {
            /**
             * @return {?}
             */
            get: function () { return this._debugInfo ? this._debugInfo.injector : null; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DebugNode.prototype, "componentInstance", {
            /**
             * @return {?}
             */
            get: function () { return this._debugInfo ? this._debugInfo.component : null; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DebugNode.prototype, "context", {
            /**
             * @return {?}
             */
            get: function () { return this._debugInfo ? this._debugInfo.context : null; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DebugNode.prototype, "references", {
            /**
             * @return {?}
             */
            get: function () {
                return this._debugInfo ? this._debugInfo.references : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DebugNode.prototype, "providerTokens", {
            /**
             * @return {?}
             */
            get: function () { return this._debugInfo ? this._debugInfo.providerTokens : null; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DebugNode.prototype, "source", {
            /**
             * @return {?}
             */
            get: function () { return this._debugInfo ? this._debugInfo.source : null; },
            enumerable: true,
            configurable: true
        });
        return DebugNode;
    }());
    /**
     * \@experimental All debugging apis are currently experimental.
     */
    var DebugElement = (function (_super) {
        __extends$12(DebugElement, _super);
        /**
         * @param {?} nativeNode
         * @param {?} parent
         * @param {?} _debugInfo
         */
        function DebugElement(nativeNode, parent, _debugInfo) {
            _super.call(this, nativeNode, parent, _debugInfo);
            this.properties = {};
            this.attributes = {};
            this.classes = {};
            this.styles = {};
            this.childNodes = [];
            this.nativeElement = nativeNode;
        }
        /**
         * @param {?} child
         * @return {?}
         */
        DebugElement.prototype.addChild = function (child) {
            if (child) {
                this.childNodes.push(child);
                child.parent = this;
            }
        };
        /**
         * @param {?} child
         * @return {?}
         */
        DebugElement.prototype.removeChild = function (child) {
            var /** @type {?} */ childIndex = this.childNodes.indexOf(child);
            if (childIndex !== -1) {
                child.parent = null;
                this.childNodes.splice(childIndex, 1);
            }
        };
        /**
         * @param {?} child
         * @param {?} newChildren
         * @return {?}
         */
        DebugElement.prototype.insertChildrenAfter = function (child, newChildren) {
            var /** @type {?} */ siblingIndex = this.childNodes.indexOf(child);
            if (siblingIndex !== -1) {
                var /** @type {?} */ previousChildren = this.childNodes.slice(0, siblingIndex + 1);
                var /** @type {?} */ nextChildren = this.childNodes.slice(siblingIndex + 1);
                this.childNodes = previousChildren.concat(newChildren, nextChildren);
                for (var /** @type {?} */ i = 0; i < newChildren.length; ++i) {
                    var /** @type {?} */ newChild = newChildren[i];
                    if (newChild.parent) {
                        newChild.parent.removeChild(newChild);
                    }
                    newChild.parent = this;
                }
            }
        };
        /**
         * @param {?} predicate
         * @return {?}
         */
        DebugElement.prototype.query = function (predicate) {
            var /** @type {?} */ results = this.queryAll(predicate);
            return results[0] || null;
        };
        /**
         * @param {?} predicate
         * @return {?}
         */
        DebugElement.prototype.queryAll = function (predicate) {
            var /** @type {?} */ matches = [];
            _queryElementChildren(this, predicate, matches);
            return matches;
        };
        /**
         * @param {?} predicate
         * @return {?}
         */
        DebugElement.prototype.queryAllNodes = function (predicate) {
            var /** @type {?} */ matches = [];
            _queryNodeChildren(this, predicate, matches);
            return matches;
        };
        Object.defineProperty(DebugElement.prototype, "children", {
            /**
             * @return {?}
             */
            get: function () {
                return (this.childNodes.filter(function (node) { return node instanceof DebugElement; }));
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} eventName
         * @param {?} eventObj
         * @return {?}
         */
        DebugElement.prototype.triggerEventHandler = function (eventName, eventObj) {
            this.listeners.forEach(function (listener) {
                if (listener.name == eventName) {
                    listener.callback(eventObj);
                }
            });
        };
        return DebugElement;
    }(DebugNode));
    /**
     * \@experimental
     * @param {?} debugEls
     * @return {?}
     */
    function asNativeElements(debugEls) {
        return debugEls.map(function (el) { return el.nativeElement; });
    }
    /**
     * @param {?} element
     * @param {?} predicate
     * @param {?} matches
     * @return {?}
     */
    function _queryElementChildren(element, predicate, matches) {
        element.childNodes.forEach(function (node) {
            if (node instanceof DebugElement) {
                if (predicate(node)) {
                    matches.push(node);
                }
                _queryElementChildren(node, predicate, matches);
            }
        });
    }
    /**
     * @param {?} parentNode
     * @param {?} predicate
     * @param {?} matches
     * @return {?}
     */
    function _queryNodeChildren(parentNode, predicate, matches) {
        if (parentNode instanceof DebugElement) {
            parentNode.childNodes.forEach(function (node) {
                if (predicate(node)) {
                    matches.push(node);
                }
                if (node instanceof DebugElement) {
                    _queryNodeChildren(node, predicate, matches);
                }
            });
        }
    }
    // Need to keep the nodes in a global Map so that multiple angular apps are supported.
    var /** @type {?} */ _nativeNodeToDebugNode = new Map();
    /**
     * \@experimental
     * @param {?} nativeNode
     * @return {?}
     */
    function getDebugNode(nativeNode) {
        return _nativeNodeToDebugNode.get(nativeNode);
    }
    /**
     * @param {?} node
     * @return {?}
     */
    function indexDebugNode(node) {
        _nativeNodeToDebugNode.set(node.nativeNode, node);
    }
    /**
     * @param {?} node
     * @return {?}
     */
    function removeDebugNodeFromIndex(node) {
        _nativeNodeToDebugNode.delete(node.nativeNode);
    }

    /**
     * @return {?}
     */
    function _reflector() {
        return reflector;
    }
    var /** @type {?} */ _CORE_PLATFORM_PROVIDERS = [
        PlatformRef_,
        { provide: PlatformRef, useExisting: PlatformRef_ },
        { provide: Reflector, useFactory: _reflector, deps: [] },
        { provide: ReflectorReader, useExisting: Reflector },
        TestabilityRegistry,
        Console,
    ];
    /**
     * This platform has to be included in any other platform
     *
     * @experimental
     */
    var /** @type {?} */ platformCore = createPlatformFactory(null, 'core', _CORE_PLATFORM_PROVIDERS);

    /**
     * @experimental i18n support is experimental.
     */
    var /** @type {?} */ LOCALE_ID = new OpaqueToken('LocaleId');
    /**
     * @experimental i18n support is experimental.
     */
    var /** @type {?} */ TRANSLATIONS = new OpaqueToken('Translations');
    /**
     * @experimental i18n support is experimental.
     */
    var /** @type {?} */ TRANSLATIONS_FORMAT = new OpaqueToken('TranslationsFormat');

    /**
     * @return {?}
     */
    function _iterableDiffersFactory() {
        return defaultIterableDiffers;
    }
    /**
     * @return {?}
     */
    function _keyValueDiffersFactory() {
        return defaultKeyValueDiffers;
    }
    /**
     * @param {?=} locale
     * @return {?}
     */
    function _localeFactory(locale) {
        return locale || 'en-US';
    }
    /**
     * This module includes the providers of \@angular/core that are needed
     * to bootstrap components via `ApplicationRef`.
     *
     * \@experimental
     */
    var ApplicationModule = (function () {
        function ApplicationModule() {
        }
        ApplicationModule.decorators = [
            { type: NgModule, args: [{
                        providers: [
                            ApplicationRef_,
                            { provide: ApplicationRef, useExisting: ApplicationRef_ },
                            ApplicationInitStatus,
                            Compiler,
                            APP_ID_RANDOM_PROVIDER,
                            ViewUtils,
                            AnimationQueue,
                            { provide: IterableDiffers, useFactory: _iterableDiffersFactory },
                            { provide: KeyValueDiffers, useFactory: _keyValueDiffersFactory },
                            {
                                provide: LOCALE_ID,
                                useFactory: _localeFactory,
                                deps: [[new Inject(LOCALE_ID), new Optional(), new SkipSelf()]]
                            },
                        ]
                    },] },
        ];
        /** @nocollapse */
        ApplicationModule.ctorParameters = function () { return []; };
        return ApplicationModule;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var /** @type {?} */ FILL_STYLE_FLAG = 'true'; // TODO (matsko): change to boolean
    var /** @type {?} */ ANY_STATE = '*';
    var /** @type {?} */ DEFAULT_STATE = '*';
    var /** @type {?} */ EMPTY_STATE = 'void';

    var AnimationGroupPlayer = (function () {
        /**
         * @param {?} _players
         */
        function AnimationGroupPlayer(_players) {
            var _this = this;
            this._players = _players;
            this._onDoneFns = [];
            this._onStartFns = [];
            this._finished = false;
            this._started = false;
            this._destroyed = false;
            this.parentPlayer = null;
            var count = 0;
            var total = this._players.length;
            if (total == 0) {
                scheduleMicroTask(function () { return _this._onFinish(); });
            }
            else {
                this._players.forEach(function (player) {
                    player.parentPlayer = _this;
                    player.onDone(function () {
                        if (++count >= total) {
                            _this._onFinish();
                        }
                    });
                });
            }
        }
        /**
         * @return {?}
         */
        AnimationGroupPlayer.prototype._onFinish = function () {
            if (!this._finished) {
                this._finished = true;
                this._onDoneFns.forEach(function (fn) { return fn(); });
                this._onDoneFns = [];
            }
        };
        /**
         * @return {?}
         */
        AnimationGroupPlayer.prototype.init = function () { this._players.forEach(function (player) { return player.init(); }); };
        /**
         * @param {?} fn
         * @return {?}
         */
        AnimationGroupPlayer.prototype.onStart = function (fn) { this._onStartFns.push(fn); };
        /**
         * @param {?} fn
         * @return {?}
         */
        AnimationGroupPlayer.prototype.onDone = function (fn) { this._onDoneFns.push(fn); };
        /**
         * @return {?}
         */
        AnimationGroupPlayer.prototype.hasStarted = function () { return this._started; };
        /**
         * @return {?}
         */
        AnimationGroupPlayer.prototype.play = function () {
            if (!isPresent(this.parentPlayer)) {
                this.init();
            }
            if (!this.hasStarted()) {
                this._onStartFns.forEach(function (fn) { return fn(); });
                this._onStartFns = [];
                this._started = true;
            }
            this._players.forEach(function (player) { return player.play(); });
        };
        /**
         * @return {?}
         */
        AnimationGroupPlayer.prototype.pause = function () { this._players.forEach(function (player) { return player.pause(); }); };
        /**
         * @return {?}
         */
        AnimationGroupPlayer.prototype.restart = function () { this._players.forEach(function (player) { return player.restart(); }); };
        /**
         * @return {?}
         */
        AnimationGroupPlayer.prototype.finish = function () {
            this._onFinish();
            this._players.forEach(function (player) { return player.finish(); });
        };
        /**
         * @return {?}
         */
        AnimationGroupPlayer.prototype.destroy = function () {
            if (!this._destroyed) {
                this._onFinish();
                this._players.forEach(function (player) { return player.destroy(); });
                this._destroyed = true;
            }
        };
        /**
         * @return {?}
         */
        AnimationGroupPlayer.prototype.reset = function () {
            this._players.forEach(function (player) { return player.reset(); });
            this._destroyed = false;
            this._finished = false;
            this._started = false;
        };
        /**
         * @param {?} p
         * @return {?}
         */
        AnimationGroupPlayer.prototype.setPosition = function (p) {
            this._players.forEach(function (player) { player.setPosition(p); });
        };
        /**
         * @return {?}
         */
        AnimationGroupPlayer.prototype.getPosition = function () {
            var /** @type {?} */ min = 0;
            this._players.forEach(function (player) {
                var /** @type {?} */ p = player.getPosition();
                min = Math.min(p, min);
            });
            return min;
        };
        Object.defineProperty(AnimationGroupPlayer.prototype, "players", {
            /**
             * @return {?}
             */
            get: function () { return this._players; },
            enumerable: true,
            configurable: true
        });
        return AnimationGroupPlayer;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * `AnimationKeyframe` consists of a series of styles (contained within {\@link AnimationStyles
     * `AnimationStyles`})
     * and an offset value indicating when those styles are applied within the `duration/delay/easing`
     * timings.
     * `AnimationKeyframe` is mostly an internal class which is designed to be used alongside {\@link
     * Renderer#animate-anchor `Renderer.animate`}.
     *
     * \@experimental Animation support is experimental
     */
    var AnimationKeyframe = (function () {
        /**
         * @param {?} offset
         * @param {?} styles
         */
        function AnimationKeyframe(offset, styles) {
            this.offset = offset;
            this.styles = styles;
        }
        return AnimationKeyframe;
    }());

    /**
     * \@experimental Animation support is experimental.
     * @abstract
     */
    var AnimationPlayer = (function () {
        function AnimationPlayer() {
        }
        /**
         * @abstract
         * @param {?} fn
         * @return {?}
         */
        AnimationPlayer.prototype.onDone = function (fn) { };
        /**
         * @abstract
         * @param {?} fn
         * @return {?}
         */
        AnimationPlayer.prototype.onStart = function (fn) { };
        /**
         * @abstract
         * @return {?}
         */
        AnimationPlayer.prototype.init = function () { };
        /**
         * @abstract
         * @return {?}
         */
        AnimationPlayer.prototype.hasStarted = function () { };
        /**
         * @abstract
         * @return {?}
         */
        AnimationPlayer.prototype.play = function () { };
        /**
         * @abstract
         * @return {?}
         */
        AnimationPlayer.prototype.pause = function () { };
        /**
         * @abstract
         * @return {?}
         */
        AnimationPlayer.prototype.restart = function () { };
        /**
         * @abstract
         * @return {?}
         */
        AnimationPlayer.prototype.finish = function () { };
        /**
         * @abstract
         * @return {?}
         */
        AnimationPlayer.prototype.destroy = function () { };
        /**
         * @abstract
         * @return {?}
         */
        AnimationPlayer.prototype.reset = function () { };
        /**
         * @abstract
         * @param {?} p
         * @return {?}
         */
        AnimationPlayer.prototype.setPosition = function (p) { };
        /**
         * @abstract
         * @return {?}
         */
        AnimationPlayer.prototype.getPosition = function () { };
        Object.defineProperty(AnimationPlayer.prototype, "parentPlayer", {
            /**
             * @return {?}
             */
            get: function () { throw new Error('NOT IMPLEMENTED: Base Class'); },
            /**
             * @param {?} player
             * @return {?}
             */
            set: function (player) { throw new Error('NOT IMPLEMENTED: Base Class'); },
            enumerable: true,
            configurable: true
        });
        return AnimationPlayer;
    }());
    var NoOpAnimationPlayer = (function () {
        function NoOpAnimationPlayer() {
            var _this = this;
            this._onDoneFns = [];
            this._onStartFns = [];
            this._started = false;
            this.parentPlayer = null;
            scheduleMicroTask(function () { return _this._onFinish(); });
        }
        /**
         * \@internal
         * @return {?}
         */
        NoOpAnimationPlayer.prototype._onFinish = function () {
            this._onDoneFns.forEach(function (fn) { return fn(); });
            this._onDoneFns = [];
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        NoOpAnimationPlayer.prototype.onStart = function (fn) { this._onStartFns.push(fn); };
        /**
         * @param {?} fn
         * @return {?}
         */
        NoOpAnimationPlayer.prototype.onDone = function (fn) { this._onDoneFns.push(fn); };
        /**
         * @return {?}
         */
        NoOpAnimationPlayer.prototype.hasStarted = function () { return this._started; };
        /**
         * @return {?}
         */
        NoOpAnimationPlayer.prototype.init = function () { };
        /**
         * @return {?}
         */
        NoOpAnimationPlayer.prototype.play = function () {
            if (!this.hasStarted()) {
                this._onStartFns.forEach(function (fn) { return fn(); });
                this._onStartFns = [];
            }
            this._started = true;
        };
        /**
         * @return {?}
         */
        NoOpAnimationPlayer.prototype.pause = function () { };
        /**
         * @return {?}
         */
        NoOpAnimationPlayer.prototype.restart = function () { };
        /**
         * @return {?}
         */
        NoOpAnimationPlayer.prototype.finish = function () { this._onFinish(); };
        /**
         * @return {?}
         */
        NoOpAnimationPlayer.prototype.destroy = function () { };
        /**
         * @return {?}
         */
        NoOpAnimationPlayer.prototype.reset = function () { };
        /**
         * @param {?} p
         * @return {?}
         */
        NoOpAnimationPlayer.prototype.setPosition = function (p) { };
        /**
         * @return {?}
         */
        NoOpAnimationPlayer.prototype.getPosition = function () { return 0; };
        return NoOpAnimationPlayer;
    }());

    var AnimationSequencePlayer = (function () {
        /**
         * @param {?} _players
         */
        function AnimationSequencePlayer(_players) {
            var _this = this;
            this._players = _players;
            this._currentIndex = 0;
            this._onDoneFns = [];
            this._onStartFns = [];
            this._finished = false;
            this._started = false;
            this._destroyed = false;
            this.parentPlayer = null;
            this._players.forEach(function (player) { player.parentPlayer = _this; });
            this._onNext(false);
        }
        /**
         * @param {?} start
         * @return {?}
         */
        AnimationSequencePlayer.prototype._onNext = function (start) {
            var _this = this;
            if (this._finished)
                return;
            if (this._players.length == 0) {
                this._activePlayer = new NoOpAnimationPlayer();
                scheduleMicroTask(function () { return _this._onFinish(); });
            }
            else if (this._currentIndex >= this._players.length) {
                this._activePlayer = new NoOpAnimationPlayer();
                this._onFinish();
            }
            else {
                var /** @type {?} */ player = this._players[this._currentIndex++];
                player.onDone(function () { return _this._onNext(true); });
                this._activePlayer = player;
                if (start) {
                    player.play();
                }
            }
        };
        /**
         * @return {?}
         */
        AnimationSequencePlayer.prototype._onFinish = function () {
            if (!this._finished) {
                this._finished = true;
                this._onDoneFns.forEach(function (fn) { return fn(); });
                this._onDoneFns = [];
            }
        };
        /**
         * @return {?}
         */
        AnimationSequencePlayer.prototype.init = function () { this._players.forEach(function (player) { return player.init(); }); };
        /**
         * @param {?} fn
         * @return {?}
         */
        AnimationSequencePlayer.prototype.onStart = function (fn) { this._onStartFns.push(fn); };
        /**
         * @param {?} fn
         * @return {?}
         */
        AnimationSequencePlayer.prototype.onDone = function (fn) { this._onDoneFns.push(fn); };
        /**
         * @return {?}
         */
        AnimationSequencePlayer.prototype.hasStarted = function () { return this._started; };
        /**
         * @return {?}
         */
        AnimationSequencePlayer.prototype.play = function () {
            if (!isPresent(this.parentPlayer)) {
                this.init();
            }
            if (!this.hasStarted()) {
                this._onStartFns.forEach(function (fn) { return fn(); });
                this._onStartFns = [];
                this._started = true;
            }
            this._activePlayer.play();
        };
        /**
         * @return {?}
         */
        AnimationSequencePlayer.prototype.pause = function () { this._activePlayer.pause(); };
        /**
         * @return {?}
         */
        AnimationSequencePlayer.prototype.restart = function () {
            this.reset();
            if (this._players.length > 0) {
                this._players[0].restart();
            }
        };
        /**
         * @return {?}
         */
        AnimationSequencePlayer.prototype.reset = function () {
            this._players.forEach(function (player) { return player.reset(); });
            this._destroyed = false;
            this._finished = false;
            this._started = false;
        };
        /**
         * @return {?}
         */
        AnimationSequencePlayer.prototype.finish = function () {
            this._onFinish();
            this._players.forEach(function (player) { return player.finish(); });
        };
        /**
         * @return {?}
         */
        AnimationSequencePlayer.prototype.destroy = function () {
            if (!this._destroyed) {
                this._onFinish();
                this._players.forEach(function (player) { return player.destroy(); });
                this._destroyed = true;
                this._activePlayer = new NoOpAnimationPlayer();
            }
        };
        /**
         * @param {?} p
         * @return {?}
         */
        AnimationSequencePlayer.prototype.setPosition = function (p) { this._players[0].setPosition(p); };
        /**
         * @return {?}
         */
        AnimationSequencePlayer.prototype.getPosition = function () { return this._players[0].getPosition(); };
        Object.defineProperty(AnimationSequencePlayer.prototype, "players", {
            /**
             * @return {?}
             */
            get: function () { return this._players; },
            enumerable: true,
            configurable: true
        });
        return AnimationSequencePlayer;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$13 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * @experimental Animation support is experimental.
     */
    var /** @type {?} */ AUTO_STYLE = '*';
    /**
     * Metadata representing the entry of animations.
     * Instances of this class are provided via the animation DSL when the {\@link trigger trigger
     * animation function} is called.
     *
     * \@experimental Animation support is experimental.
     */
    var AnimationEntryMetadata = (function () {
        /**
         * @param {?} name
         * @param {?} definitions
         */
        function AnimationEntryMetadata(name, definitions) {
            this.name = name;
            this.definitions = definitions;
        }
        return AnimationEntryMetadata;
    }());
    /**
     * \@experimental Animation support is experimental.
     * @abstract
     */
    var AnimationStateMetadata = (function () {
        function AnimationStateMetadata() {
        }
        return AnimationStateMetadata;
    }());
    /**
     * Metadata representing the entry of animations.
     * Instances of this class are provided via the animation DSL when the {\@link state state animation
     * function} is called.
     *
     * \@experimental Animation support is experimental.
     */
    var AnimationStateDeclarationMetadata = (function (_super) {
        __extends$13(AnimationStateDeclarationMetadata, _super);
        /**
         * @param {?} stateNameExpr
         * @param {?} styles
         */
        function AnimationStateDeclarationMetadata(stateNameExpr, styles) {
            _super.call(this);
            this.stateNameExpr = stateNameExpr;
            this.styles = styles;
        }
        return AnimationStateDeclarationMetadata;
    }(AnimationStateMetadata));
    /**
     * Metadata representing the entry of animations.
     * Instances of this class are provided via the animation DSL when the
     * {\@link transition transition animation function} is called.
     *
     * \@experimental Animation support is experimental.
     */
    var AnimationStateTransitionMetadata = (function (_super) {
        __extends$13(AnimationStateTransitionMetadata, _super);
        /**
         * @param {?} stateChangeExpr
         * @param {?} steps
         */
        function AnimationStateTransitionMetadata(stateChangeExpr, steps) {
            _super.call(this);
            this.stateChangeExpr = stateChangeExpr;
            this.steps = steps;
        }
        return AnimationStateTransitionMetadata;
    }(AnimationStateMetadata));
    /**
     * \@experimental Animation support is experimental.
     * @abstract
     */
    var AnimationMetadata = (function () {
        function AnimationMetadata() {
        }
        return AnimationMetadata;
    }());
    /**
     * Metadata representing the entry of animations.
     * Instances of this class are provided via the animation DSL when the {\@link keyframes keyframes
     * animation function} is called.
     *
     * \@experimental Animation support is experimental.
     */
    var AnimationKeyframesSequenceMetadata = (function (_super) {
        __extends$13(AnimationKeyframesSequenceMetadata, _super);
        /**
         * @param {?} steps
         */
        function AnimationKeyframesSequenceMetadata(steps) {
            _super.call(this);
            this.steps = steps;
        }
        return AnimationKeyframesSequenceMetadata;
    }(AnimationMetadata));
    /**
     * Metadata representing the entry of animations.
     * Instances of this class are provided via the animation DSL when the {\@link style style animation
     * function} is called.
     *
     * \@experimental Animation support is experimental.
     */
    var AnimationStyleMetadata = (function (_super) {
        __extends$13(AnimationStyleMetadata, _super);
        /**
         * @param {?} styles
         * @param {?=} offset
         */
        function AnimationStyleMetadata(styles, offset) {
            if (offset === void 0) { offset = null; }
            _super.call(this);
            this.styles = styles;
            this.offset = offset;
        }
        return AnimationStyleMetadata;
    }(AnimationMetadata));
    /**
     * Metadata representing the entry of animations.
     * Instances of this class are provided via the animation DSL when the {\@link animate animate
     * animation function} is called.
     *
     * \@experimental Animation support is experimental.
     */
    var AnimationAnimateMetadata = (function (_super) {
        __extends$13(AnimationAnimateMetadata, _super);
        /**
         * @param {?} timings
         * @param {?} styles
         */
        function AnimationAnimateMetadata(timings, styles) {
            _super.call(this);
            this.timings = timings;
            this.styles = styles;
        }
        return AnimationAnimateMetadata;
    }(AnimationMetadata));
    /**
     * \@experimental Animation support is experimental.
     * @abstract
     */
    var AnimationWithStepsMetadata = (function (_super) {
        __extends$13(AnimationWithStepsMetadata, _super);
        function AnimationWithStepsMetadata() {
            _super.call(this);
        }
        Object.defineProperty(AnimationWithStepsMetadata.prototype, "steps", {
            /**
             * @return {?}
             */
            get: function () { throw new Error('NOT IMPLEMENTED: Base Class'); },
            enumerable: true,
            configurable: true
        });
        return AnimationWithStepsMetadata;
    }(AnimationMetadata));
    /**
     * Metadata representing the entry of animations.
     * Instances of this class are provided via the animation DSL when the {\@link sequence sequence
     * animation function} is called.
     *
     * \@experimental Animation support is experimental.
     */
    var AnimationSequenceMetadata = (function (_super) {
        __extends$13(AnimationSequenceMetadata, _super);
        /**
         * @param {?} _steps
         */
        function AnimationSequenceMetadata(_steps) {
            _super.call(this);
            this._steps = _steps;
        }
        Object.defineProperty(AnimationSequenceMetadata.prototype, "steps", {
            /**
             * @return {?}
             */
            get: function () { return this._steps; },
            enumerable: true,
            configurable: true
        });
        return AnimationSequenceMetadata;
    }(AnimationWithStepsMetadata));
    /**
     * Metadata representing the entry of animations.
     * Instances of this class are provided via the animation DSL when the {\@link group group animation
     * function} is called.
     *
     * \@experimental Animation support is experimental.
     */
    var AnimationGroupMetadata = (function (_super) {
        __extends$13(AnimationGroupMetadata, _super);
        /**
         * @param {?} _steps
         */
        function AnimationGroupMetadata(_steps) {
            _super.call(this);
            this._steps = _steps;
        }
        Object.defineProperty(AnimationGroupMetadata.prototype, "steps", {
            /**
             * @return {?}
             */
            get: function () { return this._steps; },
            enumerable: true,
            configurable: true
        });
        return AnimationGroupMetadata;
    }(AnimationWithStepsMetadata));
    /**
     * `animate` is an animation-specific function that is designed to be used inside of Angular2's
     * animation
     * DSL language. If this information is new, please navigate to the
     * {\@link Component#animations-anchor component animations metadata
     * page} to gain a better understanding of how animations in Angular2 are used.
     *
     * `animate` specifies an animation step that will apply the provided `styles` data for a given
     * amount of
     * time based on the provided `timing` expression value. Calls to `animate` are expected to be
     * used within {\@link sequence an animation sequence}, {\@link group group}, or {\@link transition
     * transition}.
     *
     * ### Usage
     *
     * The `animate` function accepts two input parameters: `timing` and `styles`:
     *
     * - `timing` is a string based value that can be a combination of a duration with optional
     * delay and easing values. The format for the expression breaks down to `duration delay easing`
     * (therefore a value such as `1s 100ms ease-out` will be parse itself into `duration=1000,
     * delay=100, easing=ease-out`.
     * If a numeric value is provided then that will be used as the `duration` value in millisecond
     * form.
     * - `styles` is the style input data which can either be a call to {\@link style style} or {\@link
     * keyframes keyframes}.
     * If left empty then the styles from the destination state will be collected and used (this is
     * useful when
     * describing an animation step that will complete an animation by {\@link
     * transition#the-final-animate-call animating to the final state}).
     *
     * ```typescript
     * // various functions for specifying timing data
     * animate(500, style(...))
     * animate("1s", style(...))
     * animate("100ms 0.5s", style(...))
     * animate("5s ease", style(...))
     * animate("5s 10ms cubic-bezier(.17,.67,.88,.1)", style(...))
     *
     * // either style() of keyframes() can be used
     * animate(500, style({ background: "red" }))
     * animate(500, keyframes([
     *   style({ background: "blue" })),
     *   style({ background: "red" }))
     * ])
     * ```
     *
     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
     *
     * {\@example core/animation/ts/dsl/animation_example.ts region='Component'}
     *
     * \@experimental Animation support is experimental.
     * @param {?} timing
     * @param {?=} styles
     * @return {?}
     */
    function animate(timing, styles) {
        if (styles === void 0) { styles = null; }
        var /** @type {?} */ stylesEntry = styles;
        if (!isPresent(stylesEntry)) {
            var /** @type {?} */ EMPTY_STYLE = {};
            stylesEntry = new AnimationStyleMetadata([EMPTY_STYLE], 1);
        }
        return new AnimationAnimateMetadata(timing, stylesEntry);
    }
    /**
     * `group` is an animation-specific function that is designed to be used inside of Angular2's
     * animation
     * DSL language. If this information is new, please navigate to the
     * {\@link Component#animations-anchor component animations metadata
     * page} to gain a better understanding of how animations in Angular2 are used.
     *
     * `group` specifies a list of animation steps that are all run in parallel. Grouped animations
     * are useful when a series of styles must be animated/closed off
     * at different statrting/ending times.
     *
     * The `group` function can either be used within a {\@link sequence sequence} or a {\@link transition
     * transition}
     * and it will only continue to the next instruction once all of the inner animation steps
     * have completed.
     *
     * ### Usage
     *
     * The `steps` data that is passed into the `group` animation function can either consist
     * of {\@link style style} or {\@link animate animate} function calls. Each call to `style()` or
     * `animate()`
     * within a group will be executed instantly (use {\@link keyframes keyframes} or a
     * {\@link animate#usage animate() with a delay value} to offset styles to be applied at a later
     * time).
     *
     * ```typescript
     * group([
     *   animate("1s", { background: "black" }))
     *   animate("2s", { color: "white" }))
     * ])
     * ```
     *
     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
     *
     * {\@example core/animation/ts/dsl/animation_example.ts region='Component'}
     *
     * \@experimental Animation support is experimental.
     * @param {?} steps
     * @return {?}
     */
    function group(steps) {
        return new AnimationGroupMetadata(steps);
    }
    /**
     * `sequence` is an animation-specific function that is designed to be used inside of Angular2's
     * animation
     * DSL language. If this information is new, please navigate to the
     * {\@link Component#animations-anchor component animations metadata
     * page} to gain a better understanding of how animations in Angular2 are used.
     *
     * `sequence` Specifies a list of animation steps that are run one by one. (`sequence` is used
     * by default when an array is passed as animation data into {\@link transition transition}.)
     *
     * The `sequence` function can either be used within a {\@link group group} or a {\@link transition
     * transition}
     * and it will only continue to the next instruction once each of the inner animation steps
     * have completed.
     *
     * To perform animation styling in parallel with other animation steps then
     * have a look at the {\@link group group} animation function.
     *
     * ### Usage
     *
     * The `steps` data that is passed into the `sequence` animation function can either consist
     * of {\@link style style} or {\@link animate animate} function calls. A call to `style()` will apply
     * the
     * provided styling data immediately while a call to `animate()` will apply its styling
     * data over a given time depending on its timing data.
     *
     * ```typescript
     * sequence([
     *   style({ opacity: 0 })),
     *   animate("1s", { opacity: 1 }))
     * ])
     * ```
     *
     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
     *
     * {\@example core/animation/ts/dsl/animation_example.ts region='Component'}
     *
     * \@experimental Animation support is experimental.
     * @param {?} steps
     * @return {?}
     */
    function sequence(steps) {
        return new AnimationSequenceMetadata(steps);
    }
    /**
     * `style` is an animation-specific function that is designed to be used inside of Angular2's
     * animation
     * DSL language. If this information is new, please navigate to the
     * {\@link Component#animations-anchor component animations metadata
     * page} to gain a better understanding of how animations in Angular2 are used.
     *
     * `style` declares a key/value object containing CSS properties/styles that can then
     * be used for {\@link state animation states}, within an {\@link sequence animation sequence}, or as
     * styling data for both {\@link animate animate} and {\@link keyframes keyframes}.
     *
     * ### Usage
     *
     * `style` takes in a key/value string map as data and expects one or more CSS property/value
     * pairs to be defined.
     *
     * ```typescript
     * // string values are used for css properties
     * style({ background: "red", color: "blue" })
     *
     * // numerical (pixel) values are also supported
     * style({ width: 100, height: 0 })
     * ```
     *
     * #### Auto-styles (using `*`)
     *
     * When an asterix (`*`) character is used as a value then it will be detected from the element
     * being animated
     * and applied as animation data when the animation starts.
     *
     * This feature proves useful for a state depending on layout and/or environment factors; in such
     * cases
     * the styles are calculated just before the animation starts.
     *
     * ```typescript
     * // the steps below will animate from 0 to the
     * // actual height of the element
     * style({ height: 0 }),
     * animate("1s", style({ height: "*" }))
     * ```
     *
     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
     *
     * {\@example core/animation/ts/dsl/animation_example.ts region='Component'}
     *
     * \@experimental Animation support is experimental.
     * @param {?} tokens
     * @return {?}
     */
    function style(tokens) {
        var /** @type {?} */ input;
        var /** @type {?} */ offset = null;
        if (typeof tokens === 'string') {
            input = [(tokens)];
        }
        else {
            if (Array.isArray(tokens)) {
                input = (tokens);
            }
            else {
                input = [(tokens)];
            }
            input.forEach(function (entry) {
                var /** @type {?} */ entryOffset = ((entry) /** TODO #9100 */)['offset'];
                if (isPresent(entryOffset)) {
                    offset = offset == null ? parseFloat(entryOffset) : offset;
                }
            });
        }
        return new AnimationStyleMetadata(input, offset);
    }
    /**
     * `state` is an animation-specific function that is designed to be used inside of Angular2's
     * animation
     * DSL language. If this information is new, please navigate to the
     * {\@link Component#animations-anchor component animations metadata
     * page} to gain a better understanding of how animations in Angular2 are used.
     *
     * `state` declares an animation state within the given trigger. When a state is
     * active within a component then its associated styles will persist on
     * the element that the trigger is attached to (even when the animation ends).
     *
     * To animate between states, have a look at the animation {\@link transition transition}
     * DSL function. To register states to an animation trigger please have a look
     * at the {\@link trigger trigger} function.
     *
     * #### The `void` state
     *
     * The `void` state value is a reserved word that angular uses to determine when the element is not
     * apart
     * of the application anymore (e.g. when an `ngIf` evaluates to false then the state of the
     * associated element
     * is void).
     *
     * #### The `*` (default) state
     *
     * The `*` state (when styled) is a fallback state that will be used if
     * the state that is being animated is not declared within the trigger.
     *
     * ### Usage
     *
     * `state` will declare an animation state with its associated styles
     * within the given trigger.
     *
     * - `stateNameExpr` can be one or more state names separated by commas.
     * - `styles` refers to the {\@link style styling data} that will be persisted on the element once
     * the state
     * has been reached.
     *
     * ```typescript
     * // "void" is a reserved name for a state and is used to represent
     * // the state in which an element is detached from from the application.
     * state("void", style({ height: 0 }))
     *
     * // user-defined states
     * state("closed", style({ height: 0 }))
     * state("open, visible", style({ height: "*" }))
     * ```
     *
     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
     *
     * {\@example core/animation/ts/dsl/animation_example.ts region='Component'}
     *
     * \@experimental Animation support is experimental.
     * @param {?} stateNameExpr
     * @param {?} styles
     * @return {?}
     */
    function state(stateNameExpr, styles) {
        return new AnimationStateDeclarationMetadata(stateNameExpr, styles);
    }
    /**
     * `keyframes` is an animation-specific function that is designed to be used inside of Angular2's
     * animation
     * DSL language. If this information is new, please navigate to the
     * {\@link Component#animations-anchor component animations metadata
     * page} to gain a better understanding of how animations in Angular2 are used.
     *
     * `keyframes` specifies a collection of {\@link style style} entries each optionally characterized
     * by an `offset` value.
     *
     * ### Usage
     *
     * The `keyframes` animation function is designed to be used alongside the {\@link animate animate}
     * animation function. Instead of applying animations from where they are
     * currently to their destination, keyframes can describe how each style entry is applied
     * and at what point within the animation arc (much like CSS Keyframe Animations do).
     *
     * For each `style()` entry an `offset` value can be set. Doing so allows to specifiy at
     * what percentage of the animate time the styles will be applied.
     *
     * ```typescript
     * // the provided offset values describe when each backgroundColor value is applied.
     * animate("5s", keyframes([
     *   style({ backgroundColor: "red", offset: 0 }),
     *   style({ backgroundColor: "blue", offset: 0.2 }),
     *   style({ backgroundColor: "orange", offset: 0.3 }),
     *   style({ backgroundColor: "black", offset: 1 })
     * ]))
     * ```
     *
     * Alternatively, if there are no `offset` values used within the style entries then the offsets
     * will
     * be calculated automatically.
     *
     * ```typescript
     * animate("5s", keyframes([
     *   style({ backgroundColor: "red" }) // offset = 0
     *   style({ backgroundColor: "blue" }) // offset = 0.33
     *   style({ backgroundColor: "orange" }) // offset = 0.66
     *   style({ backgroundColor: "black" }) // offset = 1
     * ]))
     * ```
     *
     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
     *
     * {\@example core/animation/ts/dsl/animation_example.ts region='Component'}
     *
     * \@experimental Animation support is experimental.
     * @param {?} steps
     * @return {?}
     */
    function keyframes(steps) {
        return new AnimationKeyframesSequenceMetadata(steps);
    }
    /**
     * `transition` is an animation-specific function that is designed to be used inside of Angular2's
     * animation
     * DSL language. If this information is new, please navigate to the
     * {\@link Component#animations-anchor component animations metadata
     * page} to gain a better understanding of how animations in Angular2 are used.
     *
     * `transition` declares the {\@link sequence sequence of animation steps} that will be run when the
     * provided
     * `stateChangeExpr` value is satisfied. The `stateChangeExpr` consists of a `state1 => state2`
     * which consists
     * of two known states (use an asterix (`*`) to refer to a dynamic starting and/or ending state).
     *
     * Animation transitions are placed within an {\@link trigger animation trigger}. For an transition
     * to animate to
     * a state value and persist its styles then one or more {\@link state animation states} is expected
     * to be defined.
     *
     * ### Usage
     *
     * An animation transition is kicked off the `stateChangeExpr` predicate evaluates to true based on
     * what the
     * previous state is and what the current state has become. In other words, if a transition is
     * defined that
     * matches the old/current state criteria then the associated animation will be triggered.
     *
     * ```typescript
     * // all transition/state changes are defined within an animation trigger
     * trigger("myAnimationTrigger", [
     *   // if a state is defined then its styles will be persisted when the
     *   // animation has fully completed itself
     *   state("on", style({ background: "green" })),
     *   state("off", style({ background: "grey" })),
     *
     *   // a transition animation that will be kicked off when the state value
     *   // bound to "myAnimationTrigger" changes from "on" to "off"
     *   transition("on => off", animate(500)),
     *
     *   // it is also possible to do run the same animation for both directions
     *   transition("on <=> off", animate(500)),
     *
     *   // or to define multiple states pairs separated by commas
     *   transition("on => off, off => void", animate(500)),
     *
     *   // this is a catch-all state change for when an element is inserted into
     *   // the page and the destination state is unknown
     *   transition("void => *", [
     *     style({ opacity: 0 }),
     *     animate(500)
     *   ]),
     *
     *   // this will capture a state change between any states
     *   transition("* => *", animate("1s 0s")),
     * ])
     * ```
     *
     * The template associated with this component will make use of the `myAnimationTrigger`
     * animation trigger by binding to an element within its template code.
     *
     * ```html
     * <!-- somewhere inside of my-component-tpl.html -->
     * <div [\@myAnimationTrigger]="myStatusExp">...</div>
     * ```
     *
     * #### The final `animate` call
     *
     * If the final step within the transition steps is a call to `animate()` that **only**
     * uses a timing value with **no style data** then it will be automatically used as the final
     * animation
     * arc for the element to animate itself to the final state. This involves an automatic mix of
     * adding/removing CSS styles so that the element will be in the exact state it should be for the
     * applied state to be presented correctly.
     *
     * ```
     * // start off by hiding the element, but make sure that it animates properly to whatever state
     * // is currently active for "myAnimationTrigger"
     * transition("void => *", [
     *   style({ opacity: 0 }),
     *   animate(500)
     * ])
     * ```
     *
     * ### Transition Aliases (`:enter` and `:leave`)
     *
     * Given that enter (insertion) and leave (removal) animations are so common,
     * the `transition` function accepts both `:enter` and `:leave` values which
     * are aliases for the `void => *` and `* => void` state changes.
     *
     * ```
     * transition(":enter", [
     *   style({ opacity: 0 }),
     *   animate(500, style({ opacity: 1 }))
     * ])
     * transition(":leave", [
     *   animate(500, style({ opacity: 0 }))
     * ])
     * ```
     *
     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
     *
     * {\@example core/animation/ts/dsl/animation_example.ts region='Component'}
     *
     * \@experimental Animation support is experimental.
     * @param {?} stateChangeExpr
     * @param {?} steps
     * @return {?}
     */
    function transition(stateChangeExpr, steps) {
        var /** @type {?} */ animationData = Array.isArray(steps) ? new AnimationSequenceMetadata(steps) : steps;
        return new AnimationStateTransitionMetadata(stateChangeExpr, animationData);
    }
    /**
     * `trigger` is an animation-specific function that is designed to be used inside of Angular2's
     * animation
     * DSL language. If this information is new, please navigate to the
     * {\@link Component#animations-anchor component animations metadata
     * page} to gain a better understanding of how animations in Angular2 are used.
     *
     * `trigger` Creates an animation trigger which will a list of {\@link state state} and {\@link
     * transition transition}
     * entries that will be evaluated when the expression bound to the trigger changes.
     *
     * Triggers are registered within the component annotation data under the
     * {\@link Component#animations-anchor animations section}. An animation trigger can
     * be placed on an element within a template by referencing the name of the
     * trigger followed by the expression value that the trigger is bound to
     * (in the form of `[\@triggerName]="expression"`.
     *
     * ### Usage
     *
     * `trigger` will create an animation trigger reference based on the provided `name` value.
     * The provided `animation` value is expected to be an array consisting of {\@link state state} and
     * {\@link transition transition}
     * declarations.
     *
     * ```typescript
     * \@Component({
     *   selector: 'my-component',
     *   templateUrl: 'my-component-tpl.html',
     *   animations: [
     *     trigger("myAnimationTrigger", [
     *       state(...),
     *       state(...),
     *       transition(...),
     *       transition(...)
     *     ])
     *   ]
     * })
     * class MyComponent {
     *   myStatusExp = "something";
     * }
     * ```
     *
     * The template associated with this component will make use of the `myAnimationTrigger`
     * animation trigger by binding to an element within its template code.
     *
     * ```html
     * <!-- somewhere inside of my-component-tpl.html -->
     * <div [\@myAnimationTrigger]="myStatusExp">...</div>
     * ```
     *
     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
     *
     * {\@example core/animation/ts/dsl/animation_example.ts region='Component'}
     *
     * \@experimental Animation support is experimental.
     * @param {?} name
     * @param {?} animation
     * @return {?}
     */
    function trigger(name, animation) {
        return new AnimationEntryMetadata(name, animation);
    }

    /**
     * @param {?} previousStyles
     * @param {?} newStyles
     * @param {?=} nullValue
     * @return {?}
     */
    function prepareFinalAnimationStyles(previousStyles, newStyles, nullValue) {
        if (nullValue === void 0) { nullValue = null; }
        var /** @type {?} */ finalStyles = {};
        Object.keys(newStyles).forEach(function (prop) {
            var /** @type {?} */ value = newStyles[prop];
            finalStyles[prop] = value == AUTO_STYLE ? nullValue : value.toString();
        });
        Object.keys(previousStyles).forEach(function (prop) {
            if (!isPresent(finalStyles[prop])) {
                finalStyles[prop] = nullValue;
            }
        });
        return finalStyles;
    }
    /**
     * @param {?} collectedStyles
     * @param {?} finalStateStyles
     * @param {?} keyframes
     * @return {?}
     */
    function balanceAnimationKeyframes(collectedStyles, finalStateStyles, keyframes) {
        var /** @type {?} */ limit = keyframes.length - 1;
        var /** @type {?} */ firstKeyframe = keyframes[0];
        // phase 1: copy all the styles from the first keyframe into the lookup map
        var /** @type {?} */ flatenedFirstKeyframeStyles = flattenStyles(firstKeyframe.styles.styles);
        var /** @type {?} */ extraFirstKeyframeStyles = {};
        var /** @type {?} */ hasExtraFirstStyles = false;
        Object.keys(collectedStyles).forEach(function (prop) {
            var /** @type {?} */ value = (collectedStyles[prop]);
            // if the style is already defined in the first keyframe then
            // we do not replace it.
            if (!flatenedFirstKeyframeStyles[prop]) {
                flatenedFirstKeyframeStyles[prop] = value;
                extraFirstKeyframeStyles[prop] = value;
                hasExtraFirstStyles = true;
            }
        });
        var /** @type {?} */ keyframeCollectedStyles = StringMapWrapper.merge({}, flatenedFirstKeyframeStyles);
        // phase 2: normalize the final keyframe
        var /** @type {?} */ finalKeyframe = keyframes[limit];
        finalKeyframe.styles.styles.unshift(finalStateStyles);
        var /** @type {?} */ flatenedFinalKeyframeStyles = flattenStyles(finalKeyframe.styles.styles);
        var /** @type {?} */ extraFinalKeyframeStyles = {};
        var /** @type {?} */ hasExtraFinalStyles = false;
        Object.keys(keyframeCollectedStyles).forEach(function (prop) {
            if (!isPresent(flatenedFinalKeyframeStyles[prop])) {
                extraFinalKeyframeStyles[prop] = AUTO_STYLE;
                hasExtraFinalStyles = true;
            }
        });
        if (hasExtraFinalStyles) {
            finalKeyframe.styles.styles.push(extraFinalKeyframeStyles);
        }
        Object.keys(flatenedFinalKeyframeStyles).forEach(function (prop) {
            if (!isPresent(flatenedFirstKeyframeStyles[prop])) {
                extraFirstKeyframeStyles[prop] = AUTO_STYLE;
                hasExtraFirstStyles = true;
            }
        });
        if (hasExtraFirstStyles) {
            firstKeyframe.styles.styles.push(extraFirstKeyframeStyles);
        }
        collectAndResolveStyles(collectedStyles, [finalStateStyles]);
        return keyframes;
    }
    /**
     * @param {?} styles
     * @return {?}
     */
    function clearStyles(styles) {
        var /** @type {?} */ finalStyles = {};
        Object.keys(styles).forEach(function (key) { finalStyles[key] = null; });
        return finalStyles;
    }
    /**
     * @param {?} collection
     * @param {?} styles
     * @return {?}
     */
    function collectAndResolveStyles(collection, styles) {
        return styles.map(function (entry) {
            var /** @type {?} */ stylesObj = {};
            Object.keys(entry).forEach(function (prop) {
                var /** @type {?} */ value = entry[prop];
                if (value == FILL_STYLE_FLAG) {
                    value = collection[prop];
                    if (!isPresent(value)) {
                        value = AUTO_STYLE;
                    }
                }
                collection[prop] = value;
                stylesObj[prop] = value;
            });
            return stylesObj;
        });
    }
    /**
     * @param {?} element
     * @param {?} renderer
     * @param {?} styles
     * @return {?}
     */
    function renderStyles(element, renderer, styles) {
        Object.keys(styles).forEach(function (prop) { renderer.setElementStyle(element, prop, styles[prop]); });
    }
    /**
     * @param {?} styles
     * @return {?}
     */
    function flattenStyles(styles) {
        var /** @type {?} */ finalStyles = {};
        styles.forEach(function (entry) {
            Object.keys(entry).forEach(function (prop) { finalStyles[prop] = (entry[prop]); });
        });
        return finalStyles;
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * `AnimationStyles` consists of a collection of key/value maps containing CSS-based style data
     * that can either be used as initial styling data or apart of a series of keyframes within an
     * animation.
     * This class is mostly internal, and it is designed to be used alongside
     * {\@link AnimationKeyframe `AnimationKeyframe`} and {\@link Renderer#animate-anchor
     * `Renderer.animate`}.
     *
     * \@experimental Animation support is experimental
     */
    var AnimationStyles = (function () {
        /**
         * @param {?} styles
         */
        function AnimationStyles(styles) {
            this.styles = styles;
        }
        return AnimationStyles;
    }());

    /**
     * An instance of this class is returned as an event parameter when an animation
     * callback is captured for an animation either during the start or done phase.
     *
     * ```typescript
     * \@Component({
     *   host: {
     *     '[\@myAnimationTrigger]': 'someExpression',
     *     '(\@myAnimationTrigger.start)': 'captureStartEvent($event)',
     *     '(\@myAnimationTrigger.done)': 'captureDoneEvent($event)',
     *   },
     *   animations: [
     *     trigger("myAnimationTrigger", [
     *        // ...
     *     ])
     *   ]
     * })
     * class MyComponent {
     *   someExpression: any = false;
     *   captureStartEvent(event: AnimationTransitionEvent) {
     *     // the toState, fromState and totalTime data is accessible from the event variable
     *   }
     *
     *   captureDoneEvent(event: AnimationTransitionEvent) {
     *     // the toState, fromState and totalTime data is accessible from the event variable
     *   }
     * }
     * ```
     *
     * \@experimental Animation support is experimental.
     */
    var AnimationTransitionEvent = (function () {
        /**
         * @param {?} __0
         */
        function AnimationTransitionEvent(_a) {
            var fromState = _a.fromState, toState = _a.toState, totalTime = _a.totalTime, phaseName = _a.phaseName;
            this.fromState = fromState;
            this.toState = toState;
            this.totalTime = totalTime;
            this.phaseName = phaseName;
        }
        return AnimationTransitionEvent;
    }());

    var AnimationTransition = (function () {
        /**
         * @param {?} _player
         * @param {?} _fromState
         * @param {?} _toState
         * @param {?} _totalTime
         */
        function AnimationTransition(_player, _fromState, _toState, _totalTime) {
            this._player = _player;
            this._fromState = _fromState;
            this._toState = _toState;
            this._totalTime = _totalTime;
        }
        /**
         * @param {?} phaseName
         * @return {?}
         */
        AnimationTransition.prototype._createEvent = function (phaseName) {
            return new AnimationTransitionEvent({
                fromState: this._fromState,
                toState: this._toState,
                totalTime: this._totalTime,
                phaseName: phaseName
            });
        };
        /**
         * @param {?} callback
         * @return {?}
         */
        AnimationTransition.prototype.onStart = function (callback) {
            var _this = this;
            var /** @type {?} */ fn = (Zone.current.wrap(function () { return callback(_this._createEvent('start')); }, 'player.onStart'));
            this._player.onStart(fn);
        };
        /**
         * @param {?} callback
         * @return {?}
         */
        AnimationTransition.prototype.onDone = function (callback) {
            var _this = this;
            var /** @type {?} */ fn = (Zone.current.wrap(function () { return callback(_this._createEvent('done')); }, 'player.onDone'));
            this._player.onDone(fn);
        };
        return AnimationTransition;
    }());

    var DebugDomRootRenderer = (function () {
        /**
         * @param {?} _delegate
         */
        function DebugDomRootRenderer(_delegate) {
            this._delegate = _delegate;
        }
        /**
         * @param {?} componentProto
         * @return {?}
         */
        DebugDomRootRenderer.prototype.renderComponent = function (componentProto) {
            return new DebugDomRenderer(this._delegate.renderComponent(componentProto));
        };
        return DebugDomRootRenderer;
    }());
    var DebugDomRenderer = (function () {
        /**
         * @param {?} _delegate
         */
        function DebugDomRenderer(_delegate) {
            this._delegate = _delegate;
        }
        /**
         * @param {?} selectorOrNode
         * @param {?=} debugInfo
         * @return {?}
         */
        DebugDomRenderer.prototype.selectRootElement = function (selectorOrNode, debugInfo) {
            var /** @type {?} */ nativeEl = this._delegate.selectRootElement(selectorOrNode, debugInfo);
            var /** @type {?} */ debugEl = new DebugElement(nativeEl, null, debugInfo);
            indexDebugNode(debugEl);
            return nativeEl;
        };
        /**
         * @param {?} parentElement
         * @param {?} name
         * @param {?=} debugInfo
         * @return {?}
         */
        DebugDomRenderer.prototype.createElement = function (parentElement, name, debugInfo) {
            var /** @type {?} */ nativeEl = this._delegate.createElement(parentElement, name, debugInfo);
            var /** @type {?} */ debugEl = new DebugElement(nativeEl, getDebugNode(parentElement), debugInfo);
            debugEl.name = name;
            indexDebugNode(debugEl);
            return nativeEl;
        };
        /**
         * @param {?} hostElement
         * @return {?}
         */
        DebugDomRenderer.prototype.createViewRoot = function (hostElement) { return this._delegate.createViewRoot(hostElement); };
        /**
         * @param {?} parentElement
         * @param {?=} debugInfo
         * @return {?}
         */
        DebugDomRenderer.prototype.createTemplateAnchor = function (parentElement, debugInfo) {
            var /** @type {?} */ comment = this._delegate.createTemplateAnchor(parentElement, debugInfo);
            var /** @type {?} */ debugEl = new DebugNode(comment, getDebugNode(parentElement), debugInfo);
            indexDebugNode(debugEl);
            return comment;
        };
        /**
         * @param {?} parentElement
         * @param {?} value
         * @param {?=} debugInfo
         * @return {?}
         */
        DebugDomRenderer.prototype.createText = function (parentElement, value, debugInfo) {
            var /** @type {?} */ text = this._delegate.createText(parentElement, value, debugInfo);
            var /** @type {?} */ debugEl = new DebugNode(text, getDebugNode(parentElement), debugInfo);
            indexDebugNode(debugEl);
            return text;
        };
        /**
         * @param {?} parentElement
         * @param {?} nodes
         * @return {?}
         */
        DebugDomRenderer.prototype.projectNodes = function (parentElement, nodes) {
            var /** @type {?} */ debugParent = getDebugNode(parentElement);
            if (isPresent(debugParent) && debugParent instanceof DebugElement) {
                var /** @type {?} */ debugElement_1 = debugParent;
                nodes.forEach(function (node) { debugElement_1.addChild(getDebugNode(node)); });
            }
            this._delegate.projectNodes(parentElement, nodes);
        };
        /**
         * @param {?} node
         * @param {?} viewRootNodes
         * @return {?}
         */
        DebugDomRenderer.prototype.attachViewAfter = function (node, viewRootNodes) {
            var /** @type {?} */ debugNode = getDebugNode(node);
            if (isPresent(debugNode)) {
                var /** @type {?} */ debugParent = debugNode.parent;
                if (viewRootNodes.length > 0 && isPresent(debugParent)) {
                    var /** @type {?} */ debugViewRootNodes_1 = [];
                    viewRootNodes.forEach(function (rootNode) { return debugViewRootNodes_1.push(getDebugNode(rootNode)); });
                    debugParent.insertChildrenAfter(debugNode, debugViewRootNodes_1);
                }
            }
            this._delegate.attachViewAfter(node, viewRootNodes);
        };
        /**
         * @param {?} viewRootNodes
         * @return {?}
         */
        DebugDomRenderer.prototype.detachView = function (viewRootNodes) {
            viewRootNodes.forEach(function (node) {
                var /** @type {?} */ debugNode = getDebugNode(node);
                if (isPresent(debugNode) && isPresent(debugNode.parent)) {
                    debugNode.parent.removeChild(debugNode);
                }
            });
            this._delegate.detachView(viewRootNodes);
        };
        /**
         * @param {?} hostElement
         * @param {?} viewAllNodes
         * @return {?}
         */
        DebugDomRenderer.prototype.destroyView = function (hostElement, viewAllNodes) {
            viewAllNodes = viewAllNodes || [];
            viewAllNodes.forEach(function (node) { removeDebugNodeFromIndex(getDebugNode(node)); });
            this._delegate.destroyView(hostElement, viewAllNodes);
        };
        /**
         * @param {?} renderElement
         * @param {?} name
         * @param {?} callback
         * @return {?}
         */
        DebugDomRenderer.prototype.listen = function (renderElement, name, callback) {
            var /** @type {?} */ debugEl = getDebugNode(renderElement);
            if (isPresent(debugEl)) {
                debugEl.listeners.push(new EventListener(name, callback));
            }
            return this._delegate.listen(renderElement, name, callback);
        };
        /**
         * @param {?} target
         * @param {?} name
         * @param {?} callback
         * @return {?}
         */
        DebugDomRenderer.prototype.listenGlobal = function (target, name, callback) {
            return this._delegate.listenGlobal(target, name, callback);
        };
        /**
         * @param {?} renderElement
         * @param {?} propertyName
         * @param {?} propertyValue
         * @return {?}
         */
        DebugDomRenderer.prototype.setElementProperty = function (renderElement, propertyName, propertyValue) {
            var /** @type {?} */ debugEl = getDebugNode(renderElement);
            if (isPresent(debugEl) && debugEl instanceof DebugElement) {
                debugEl.properties[propertyName] = propertyValue;
            }
            this._delegate.setElementProperty(renderElement, propertyName, propertyValue);
        };
        /**
         * @param {?} renderElement
         * @param {?} attributeName
         * @param {?} attributeValue
         * @return {?}
         */
        DebugDomRenderer.prototype.setElementAttribute = function (renderElement, attributeName, attributeValue) {
            var /** @type {?} */ debugEl = getDebugNode(renderElement);
            if (isPresent(debugEl) && debugEl instanceof DebugElement) {
                debugEl.attributes[attributeName] = attributeValue;
            }
            this._delegate.setElementAttribute(renderElement, attributeName, attributeValue);
        };
        /**
         * @param {?} renderElement
         * @param {?} propertyName
         * @param {?} propertyValue
         * @return {?}
         */
        DebugDomRenderer.prototype.setBindingDebugInfo = function (renderElement, propertyName, propertyValue) {
            this._delegate.setBindingDebugInfo(renderElement, propertyName, propertyValue);
        };
        /**
         * @param {?} renderElement
         * @param {?} className
         * @param {?} isAdd
         * @return {?}
         */
        DebugDomRenderer.prototype.setElementClass = function (renderElement, className, isAdd) {
            var /** @type {?} */ debugEl = getDebugNode(renderElement);
            if (isPresent(debugEl) && debugEl instanceof DebugElement) {
                debugEl.classes[className] = isAdd;
            }
            this._delegate.setElementClass(renderElement, className, isAdd);
        };
        /**
         * @param {?} renderElement
         * @param {?} styleName
         * @param {?} styleValue
         * @return {?}
         */
        DebugDomRenderer.prototype.setElementStyle = function (renderElement, styleName, styleValue) {
            var /** @type {?} */ debugEl = getDebugNode(renderElement);
            if (isPresent(debugEl) && debugEl instanceof DebugElement) {
                debugEl.styles[styleName] = styleValue;
            }
            this._delegate.setElementStyle(renderElement, styleName, styleValue);
        };
        /**
         * @param {?} renderElement
         * @param {?} methodName
         * @param {?=} args
         * @return {?}
         */
        DebugDomRenderer.prototype.invokeElementMethod = function (renderElement, methodName, args) {
            this._delegate.invokeElementMethod(renderElement, methodName, args);
        };
        /**
         * @param {?} renderNode
         * @param {?} text
         * @return {?}
         */
        DebugDomRenderer.prototype.setText = function (renderNode, text) { this._delegate.setText(renderNode, text); };
        /**
         * @param {?} element
         * @param {?} startingStyles
         * @param {?} keyframes
         * @param {?} duration
         * @param {?} delay
         * @param {?} easing
         * @param {?=} previousPlayers
         * @return {?}
         */
        DebugDomRenderer.prototype.animate = function (element, startingStyles, keyframes, duration, delay, easing, previousPlayers) {
            if (previousPlayers === void 0) { previousPlayers = []; }
            return this._delegate.animate(element, startingStyles, keyframes, duration, delay, easing, previousPlayers);
        };
        return DebugDomRenderer;
    }());

    var ViewType = {};
    ViewType.HOST = 0;
    ViewType.COMPONENT = 1;
    ViewType.EMBEDDED = 2;
    ViewType[ViewType.HOST] = "HOST";
    ViewType[ViewType.COMPONENT] = "COMPONENT";
    ViewType[ViewType.EMBEDDED] = "EMBEDDED";

    var StaticNodeDebugInfo = (function () {
        /**
         * @param {?} providerTokens
         * @param {?} componentToken
         * @param {?} refTokens
         */
        function StaticNodeDebugInfo(providerTokens, componentToken, refTokens) {
            this.providerTokens = providerTokens;
            this.componentToken = componentToken;
            this.refTokens = refTokens;
        }
        return StaticNodeDebugInfo;
    }());
    var DebugContext = (function () {
        /**
         * @param {?} _view
         * @param {?} _nodeIndex
         * @param {?} _tplRow
         * @param {?} _tplCol
         */
        function DebugContext(_view, _nodeIndex, _tplRow, _tplCol) {
            this._view = _view;
            this._nodeIndex = _nodeIndex;
            this._tplRow = _tplRow;
            this._tplCol = _tplCol;
        }
        Object.defineProperty(DebugContext.prototype, "_staticNodeInfo", {
            /**
             * @return {?}
             */
            get: function () {
                return isPresent(this._nodeIndex) ? this._view.staticNodeDebugInfos[this._nodeIndex] : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DebugContext.prototype, "context", {
            /**
             * @return {?}
             */
            get: function () { return this._view.context; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DebugContext.prototype, "component", {
            /**
             * @return {?}
             */
            get: function () {
                var /** @type {?} */ staticNodeInfo = this._staticNodeInfo;
                if (isPresent(staticNodeInfo) && isPresent(staticNodeInfo.componentToken)) {
                    return this.injector.get(staticNodeInfo.componentToken);
                }
                return null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DebugContext.prototype, "componentRenderElement", {
            /**
             * @return {?}
             */
            get: function () {
                var /** @type {?} */ componentView = this._view;
                while (isPresent(componentView.parentView) && componentView.type !== ViewType.COMPONENT) {
                    componentView = (componentView.parentView);
                }
                return componentView.parentElement;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DebugContext.prototype, "injector", {
            /**
             * @return {?}
             */
            get: function () { return this._view.injector(this._nodeIndex); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DebugContext.prototype, "renderNode", {
            /**
             * @return {?}
             */
            get: function () {
                if (isPresent(this._nodeIndex) && this._view.allNodes) {
                    return this._view.allNodes[this._nodeIndex];
                }
                else {
                    return null;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DebugContext.prototype, "providerTokens", {
            /**
             * @return {?}
             */
            get: function () {
                var /** @type {?} */ staticNodeInfo = this._staticNodeInfo;
                return isPresent(staticNodeInfo) ? staticNodeInfo.providerTokens : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DebugContext.prototype, "source", {
            /**
             * @return {?}
             */
            get: function () {
                return this._view.componentType.templateUrl + ":" + this._tplRow + ":" + this._tplCol;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DebugContext.prototype, "references", {
            /**
             * @return {?}
             */
            get: function () {
                var _this = this;
                var /** @type {?} */ varValues = {};
                var /** @type {?} */ staticNodeInfo = this._staticNodeInfo;
                if (isPresent(staticNodeInfo)) {
                    var /** @type {?} */ refs_1 = staticNodeInfo.refTokens;
                    Object.keys(refs_1).forEach(function (refName) {
                        var /** @type {?} */ refToken = refs_1[refName];
                        var /** @type {?} */ varValue;
                        if (isBlank(refToken)) {
                            varValue = _this._view.allNodes ? _this._view.allNodes[_this._nodeIndex] : null;
                        }
                        else {
                            varValue = _this._view.injectorGet(refToken, _this._nodeIndex, null);
                        }
                        varValues[refName] = varValue;
                    });
                }
                return varValues;
            },
            enumerable: true,
            configurable: true
        });
        return DebugContext;
    }());

    var ViewAnimationMap = (function () {
        function ViewAnimationMap() {
            this._map = new Map();
            this._allPlayers = [];
        }
        /**
         * @param {?} element
         * @param {?} animationName
         * @return {?}
         */
        ViewAnimationMap.prototype.find = function (element, animationName) {
            var /** @type {?} */ playersByAnimation = this._map.get(element);
            if (isPresent(playersByAnimation)) {
                return playersByAnimation[animationName];
            }
        };
        /**
         * @param {?} element
         * @return {?}
         */
        ViewAnimationMap.prototype.findAllPlayersByElement = function (element) {
            var /** @type {?} */ el = this._map.get(element);
            return el ? Object.keys(el).map(function (k) { return el[k]; }) : [];
        };
        /**
         * @param {?} element
         * @param {?} animationName
         * @param {?} player
         * @return {?}
         */
        ViewAnimationMap.prototype.set = function (element, animationName, player) {
            var /** @type {?} */ playersByAnimation = this._map.get(element);
            if (!isPresent(playersByAnimation)) {
                playersByAnimation = {};
            }
            var /** @type {?} */ existingEntry = playersByAnimation[animationName];
            if (isPresent(existingEntry)) {
                this.remove(element, animationName);
            }
            playersByAnimation[animationName] = player;
            this._allPlayers.push(player);
            this._map.set(element, playersByAnimation);
        };
        /**
         * @return {?}
         */
        ViewAnimationMap.prototype.getAllPlayers = function () { return this._allPlayers; };
        /**
         * @param {?} element
         * @param {?} animationName
         * @param {?=} targetPlayer
         * @return {?}
         */
        ViewAnimationMap.prototype.remove = function (element, animationName, targetPlayer) {
            if (targetPlayer === void 0) { targetPlayer = null; }
            var /** @type {?} */ playersByAnimation = this._map.get(element);
            if (playersByAnimation) {
                var /** @type {?} */ player = playersByAnimation[animationName];
                if (!targetPlayer || player === targetPlayer) {
                    delete playersByAnimation[animationName];
                    var /** @type {?} */ index = this._allPlayers.indexOf(player);
                    this._allPlayers.splice(index, 1);
                    if (Object.keys(playersByAnimation).length === 0) {
                        this._map.delete(element);
                    }
                }
            }
        };
        return ViewAnimationMap;
    }());

    var AnimationViewContext = (function () {
        /**
         * @param {?} _animationQueue
         */
        function AnimationViewContext(_animationQueue) {
            this._animationQueue = _animationQueue;
            this._players = new ViewAnimationMap();
        }
        /**
         * @param {?} callback
         * @return {?}
         */
        AnimationViewContext.prototype.onAllActiveAnimationsDone = function (callback) {
            var /** @type {?} */ activeAnimationPlayers = this._players.getAllPlayers();
            // we check for the length to avoid having GroupAnimationPlayer
            // issue an unnecessary microtask when zero players are passed in
            if (activeAnimationPlayers.length) {
                new AnimationGroupPlayer(activeAnimationPlayers).onDone(function () { return callback(); });
            }
            else {
                callback();
            }
        };
        /**
         * @param {?} element
         * @param {?} animationName
         * @param {?} player
         * @return {?}
         */
        AnimationViewContext.prototype.queueAnimation = function (element, animationName, player) {
            var _this = this;
            this._animationQueue.enqueue(player);
            this._players.set(element, animationName, player);
            player.onDone(function () { return _this._players.remove(element, animationName, player); });
        };
        /**
         * @param {?} element
         * @param {?=} animationName
         * @return {?}
         */
        AnimationViewContext.prototype.getAnimationPlayers = function (element, animationName) {
            if (animationName === void 0) { animationName = null; }
            var /** @type {?} */ players = [];
            if (animationName) {
                var /** @type {?} */ currentPlayer = this._players.find(element, animationName);
                if (currentPlayer) {
                    _recursePlayers(currentPlayer, players);
                }
            }
            else {
                this._players.findAllPlayersByElement(element).forEach(function (player) { return _recursePlayers(player, players); });
            }
            return players;
        };
        return AnimationViewContext;
    }());
    /**
     * @param {?} player
     * @param {?} collectedPlayers
     * @return {?}
     */
    function _recursePlayers(player, collectedPlayers) {
        if ((player instanceof AnimationGroupPlayer) || (player instanceof AnimationSequencePlayer)) {
            player.players.forEach(function (player) { return _recursePlayers(player, collectedPlayers); });
        }
        else {
            collectedPlayers.push(player);
        }
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$15 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var ElementInjector = (function (_super) {
        __extends$15(ElementInjector, _super);
        /**
         * @param {?} _view
         * @param {?} _nodeIndex
         */
        function ElementInjector(_view, _nodeIndex) {
            _super.call(this);
            this._view = _view;
            this._nodeIndex = _nodeIndex;
        }
        /**
         * @param {?} token
         * @param {?=} notFoundValue
         * @return {?}
         */
        ElementInjector.prototype.get = function (token, notFoundValue) {
            if (notFoundValue === void 0) { notFoundValue = THROW_IF_NOT_FOUND; }
            return this._view.injectorGet(token, this._nodeIndex, notFoundValue);
        };
        return ElementInjector;
    }(Injector));

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$14 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var /** @type {?} */ _scope_check = wtfCreateScope("AppView#check(ascii id)");
    /**
     * @experimental
     */
    var /** @type {?} */ EMPTY_CONTEXT = new Object();
    var /** @type {?} */ UNDEFINED$1 = new Object();
    /**
     * Cost of making objects: http://jsperf.com/instantiate-size-of-object
     *
     * @abstract
     */
    var AppView = (function () {
        /**
         * @param {?} clazz
         * @param {?} componentType
         * @param {?} type
         * @param {?} viewUtils
         * @param {?} parentView
         * @param {?} parentIndex
         * @param {?} parentElement
         * @param {?} cdMode
         * @param {?=} declaredViewContainer
         */
        function AppView(clazz, componentType, type, viewUtils, parentView, parentIndex, parentElement, cdMode, declaredViewContainer) {
            if (declaredViewContainer === void 0) { declaredViewContainer = null; }
            this.clazz = clazz;
            this.componentType = componentType;
            this.type = type;
            this.viewUtils = viewUtils;
            this.parentView = parentView;
            this.parentIndex = parentIndex;
            this.parentElement = parentElement;
            this.cdMode = cdMode;
            this.declaredViewContainer = declaredViewContainer;
            this.numberOfChecks = 0;
            this.ref = new ViewRef_(this, viewUtils.animationQueue);
            if (type === ViewType.COMPONENT || type === ViewType.HOST) {
                this.renderer = viewUtils.renderComponent(componentType);
            }
            else {
                this.renderer = parentView.renderer;
            }
            this._directRenderer = this.renderer.directRenderer;
        }
        Object.defineProperty(AppView.prototype, "animationContext", {
            /**
             * @return {?}
             */
            get: function () {
                if (!this._animationContext) {
                    this._animationContext = new AnimationViewContext(this.viewUtils.animationQueue);
                }
                return this._animationContext;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AppView.prototype, "destroyed", {
            /**
             * @return {?}
             */
            get: function () { return this.cdMode === ChangeDetectorStatus.Destroyed; },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} context
         * @return {?}
         */
        AppView.prototype.create = function (context) {
            this.context = context;
            return this.createInternal(null);
        };
        /**
         * @param {?} rootSelectorOrNode
         * @param {?} hostInjector
         * @param {?} projectableNodes
         * @return {?}
         */
        AppView.prototype.createHostView = function (rootSelectorOrNode, hostInjector, projectableNodes) {
            this.context = (EMPTY_CONTEXT);
            this._hasExternalHostElement = isPresent(rootSelectorOrNode);
            this._hostInjector = hostInjector;
            this._hostProjectableNodes = projectableNodes;
            return this.createInternal(rootSelectorOrNode);
        };
        /**
         * Overwritten by implementations.
         * Returns the ComponentRef for the host element for ViewType.HOST.
         * @param {?} rootSelectorOrNode
         * @return {?}
         */
        AppView.prototype.createInternal = function (rootSelectorOrNode) { return null; };
        /**
         * Overwritten by implementations.
         * @param {?} templateNodeIndex
         * @return {?}
         */
        AppView.prototype.createEmbeddedViewInternal = function (templateNodeIndex) { return null; };
        /**
         * @param {?} lastRootNode
         * @param {?} allNodes
         * @param {?} disposables
         * @return {?}
         */
        AppView.prototype.init = function (lastRootNode, allNodes, disposables) {
            this.lastRootNode = lastRootNode;
            this.allNodes = allNodes;
            this.disposables = disposables;
            if (this.type === ViewType.COMPONENT) {
                this.dirtyParentQueriesInternal();
            }
        };
        /**
         * @param {?} token
         * @param {?} nodeIndex
         * @param {?=} notFoundValue
         * @return {?}
         */
        AppView.prototype.injectorGet = function (token, nodeIndex, notFoundValue) {
            if (notFoundValue === void 0) { notFoundValue = THROW_IF_NOT_FOUND; }
            var /** @type {?} */ result = UNDEFINED$1;
            var /** @type {?} */ view = this;
            while (result === UNDEFINED$1) {
                if (isPresent(nodeIndex)) {
                    result = view.injectorGetInternal(token, nodeIndex, UNDEFINED$1);
                }
                if (result === UNDEFINED$1 && view.type === ViewType.HOST) {
                    result = view._hostInjector.get(token, notFoundValue);
                }
                nodeIndex = view.parentIndex;
                view = view.parentView;
            }
            return result;
        };
        /**
         * Overwritten by implementations
         * @param {?} token
         * @param {?} nodeIndex
         * @param {?} notFoundResult
         * @return {?}
         */
        AppView.prototype.injectorGetInternal = function (token, nodeIndex, notFoundResult) {
            return notFoundResult;
        };
        /**
         * @param {?} nodeIndex
         * @return {?}
         */
        AppView.prototype.injector = function (nodeIndex) { return new ElementInjector(this, nodeIndex); };
        /**
         * @return {?}
         */
        AppView.prototype.detachAndDestroy = function () {
            if (this.viewContainer) {
                this.viewContainer.detachView(this.viewContainer.nestedViews.indexOf(this));
            }
            else if (this.appRef) {
                this.appRef.detachView(this.ref);
            }
            else if (this._hasExternalHostElement) {
                this.detach();
            }
            this.destroy();
        };
        /**
         * @return {?}
         */
        AppView.prototype.destroy = function () {
            var _this = this;
            if (this.cdMode === ChangeDetectorStatus.Destroyed) {
                return;
            }
            var /** @type {?} */ hostElement = this.type === ViewType.COMPONENT ? this.parentElement : null;
            if (this.disposables) {
                for (var /** @type {?} */ i = 0; i < this.disposables.length; i++) {
                    this.disposables[i]();
                }
            }
            this.destroyInternal();
            this.dirtyParentQueriesInternal();
            if (this._animationContext) {
                this._animationContext.onAllActiveAnimationsDone(function () { return _this.renderer.destroyView(hostElement, _this.allNodes); });
            }
            else {
                this.renderer.destroyView(hostElement, this.allNodes);
            }
            this.cdMode = ChangeDetectorStatus.Destroyed;
        };
        /**
         * Overwritten by implementations
         * @return {?}
         */
        AppView.prototype.destroyInternal = function () { };
        /**
         * Overwritten by implementations
         * @return {?}
         */
        AppView.prototype.detachInternal = function () { };
        /**
         * @return {?}
         */
        AppView.prototype.detach = function () {
            var _this = this;
            this.detachInternal();
            if (this._animationContext) {
                this._animationContext.onAllActiveAnimationsDone(function () { return _this._renderDetach(); });
            }
            else {
                this._renderDetach();
            }
            if (this.declaredViewContainer && this.declaredViewContainer !== this.viewContainer &&
                this.declaredViewContainer.projectedViews) {
                var /** @type {?} */ projectedViews = this.declaredViewContainer.projectedViews;
                var /** @type {?} */ index = projectedViews.indexOf(this);
                // perf: pop is faster than splice!
                if (index >= projectedViews.length - 1) {
                    projectedViews.pop();
                }
                else {
                    projectedViews.splice(index, 1);
                }
            }
            this.appRef = null;
            this.viewContainer = null;
            this.dirtyParentQueriesInternal();
        };
        /**
         * @return {?}
         */
        AppView.prototype._renderDetach = function () {
            if (this._directRenderer) {
                this.visitRootNodesInternal(this._directRenderer.remove, null);
            }
            else {
                this.renderer.detachView(this.flatRootNodes);
            }
        };
        /**
         * @param {?} appRef
         * @return {?}
         */
        AppView.prototype.attachToAppRef = function (appRef) {
            if (this.viewContainer) {
                throw new Error('This view is already attached to a ViewContainer!');
            }
            this.appRef = appRef;
            this.dirtyParentQueriesInternal();
        };
        /**
         * @param {?} viewContainer
         * @param {?} prevView
         * @return {?}
         */
        AppView.prototype.attachAfter = function (viewContainer, prevView) {
            if (this.appRef) {
                throw new Error('This view is already attached directly to the ApplicationRef!');
            }
            this._renderAttach(viewContainer, prevView);
            this.viewContainer = viewContainer;
            if (this.declaredViewContainer && this.declaredViewContainer !== viewContainer) {
                if (!this.declaredViewContainer.projectedViews) {
                    this.declaredViewContainer.projectedViews = [];
                }
                this.declaredViewContainer.projectedViews.push(this);
            }
            this.dirtyParentQueriesInternal();
        };
        /**
         * @param {?} viewContainer
         * @param {?} prevView
         * @return {?}
         */
        AppView.prototype.moveAfter = function (viewContainer, prevView) {
            this._renderAttach(viewContainer, prevView);
            this.dirtyParentQueriesInternal();
        };
        /**
         * @param {?} viewContainer
         * @param {?} prevView
         * @return {?}
         */
        AppView.prototype._renderAttach = function (viewContainer, prevView) {
            var /** @type {?} */ prevNode = prevView ? prevView.lastRootNode : viewContainer.nativeElement;
            if (this._directRenderer) {
                var /** @type {?} */ nextSibling = this._directRenderer.nextSibling(prevNode);
                if (nextSibling) {
                    this.visitRootNodesInternal(this._directRenderer.insertBefore, nextSibling);
                }
                else {
                    var /** @type {?} */ parentElement = this._directRenderer.parentElement(prevNode);
                    if (parentElement) {
                        this.visitRootNodesInternal(this._directRenderer.appendChild, parentElement);
                    }
                }
            }
            else {
                this.renderer.attachViewAfter(prevNode, this.flatRootNodes);
            }
        };
        Object.defineProperty(AppView.prototype, "changeDetectorRef", {
            /**
             * @return {?}
             */
            get: function () { return this.ref; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AppView.prototype, "flatRootNodes", {
            /**
             * @return {?}
             */
            get: function () {
                var /** @type {?} */ nodes = [];
                this.visitRootNodesInternal(addToArray, nodes);
                return nodes;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} parentElement
         * @param {?} ngContentIndex
         * @return {?}
         */
        AppView.prototype.projectNodes = function (parentElement, ngContentIndex) {
            if (this._directRenderer) {
                this.visitProjectedNodes(ngContentIndex, this._directRenderer.appendChild, parentElement);
            }
            else {
                var /** @type {?} */ nodes = [];
                this.visitProjectedNodes(ngContentIndex, addToArray, nodes);
                this.renderer.projectNodes(parentElement, nodes);
            }
        };
        /**
         * @param {?} ngContentIndex
         * @param {?} cb
         * @param {?} c
         * @return {?}
         */
        AppView.prototype.visitProjectedNodes = function (ngContentIndex, cb, c) {
            switch (this.type) {
                case ViewType.EMBEDDED:
                    this.parentView.visitProjectedNodes(ngContentIndex, cb, c);
                    break;
                case ViewType.COMPONENT:
                    if (this.parentView.type === ViewType.HOST) {
                        var /** @type {?} */ nodes = this.parentView._hostProjectableNodes[ngContentIndex] || [];
                        for (var /** @type {?} */ i = 0; i < nodes.length; i++) {
                            cb(nodes[i], c);
                        }
                    }
                    else {
                        this.parentView.visitProjectableNodesInternal(this.parentIndex, ngContentIndex, cb, c);
                    }
                    break;
            }
        };
        /**
         * Overwritten by implementations
         * @param {?} cb
         * @param {?} c
         * @return {?}
         */
        AppView.prototype.visitRootNodesInternal = function (cb, c) { };
        /**
         * Overwritten by implementations
         * @param {?} nodeIndex
         * @param {?} ngContentIndex
         * @param {?} cb
         * @param {?} c
         * @return {?}
         */
        AppView.prototype.visitProjectableNodesInternal = function (nodeIndex, ngContentIndex, cb, c) { };
        /**
         * Overwritten by implementations
         * @return {?}
         */
        AppView.prototype.dirtyParentQueriesInternal = function () { };
        /**
         * @param {?} throwOnChange
         * @return {?}
         */
        AppView.prototype.internalDetectChanges = function (throwOnChange) {
            if (this.cdMode !== ChangeDetectorStatus.Detached) {
                this.detectChanges(throwOnChange);
            }
        };
        /**
         * @param {?} throwOnChange
         * @return {?}
         */
        AppView.prototype.detectChanges = function (throwOnChange) {
            var /** @type {?} */ s = _scope_check(this.clazz);
            if (this.cdMode === ChangeDetectorStatus.Checked ||
                this.cdMode === ChangeDetectorStatus.Errored)
                return;
            if (this.cdMode === ChangeDetectorStatus.Destroyed) {
                this.throwDestroyedError('detectChanges');
            }
            this.detectChangesInternal(throwOnChange);
            if (this.cdMode === ChangeDetectorStatus.CheckOnce)
                this.cdMode = ChangeDetectorStatus.Checked;
            this.numberOfChecks++;
            wtfLeave(s);
        };
        /**
         * Overwritten by implementations
         * @param {?} throwOnChange
         * @return {?}
         */
        AppView.prototype.detectChangesInternal = function (throwOnChange) { };
        /**
         * @return {?}
         */
        AppView.prototype.markAsCheckOnce = function () { this.cdMode = ChangeDetectorStatus.CheckOnce; };
        /**
         * @return {?}
         */
        AppView.prototype.markPathToRootAsCheckOnce = function () {
            var /** @type {?} */ c = this;
            while (isPresent(c) && c.cdMode !== ChangeDetectorStatus.Detached) {
                if (c.cdMode === ChangeDetectorStatus.Checked) {
                    c.cdMode = ChangeDetectorStatus.CheckOnce;
                }
                if (c.type === ViewType.COMPONENT) {
                    c = c.parentView;
                }
                else {
                    c = c.viewContainer ? c.viewContainer.parentView : null;
                }
            }
        };
        /**
         * @param {?} cb
         * @return {?}
         */
        AppView.prototype.eventHandler = function (cb) {
            return cb;
        };
        /**
         * @param {?} details
         * @return {?}
         */
        AppView.prototype.throwDestroyedError = function (details) { throw new ViewDestroyedError(details); };
        return AppView;
    }());
    var DebugAppView = (function (_super) {
        __extends$14(DebugAppView, _super);
        /**
         * @param {?} clazz
         * @param {?} componentType
         * @param {?} type
         * @param {?} viewUtils
         * @param {?} parentView
         * @param {?} parentIndex
         * @param {?} parentNode
         * @param {?} cdMode
         * @param {?} staticNodeDebugInfos
         * @param {?=} declaredViewContainer
         */
        function DebugAppView(clazz, componentType, type, viewUtils, parentView, parentIndex, parentNode, cdMode, staticNodeDebugInfos, declaredViewContainer) {
            if (declaredViewContainer === void 0) { declaredViewContainer = null; }
            _super.call(this, clazz, componentType, type, viewUtils, parentView, parentIndex, parentNode, cdMode, declaredViewContainer);
            this.staticNodeDebugInfos = staticNodeDebugInfos;
            this._currentDebugContext = null;
        }
        /**
         * @param {?} context
         * @return {?}
         */
        DebugAppView.prototype.create = function (context) {
            this._resetDebug();
            try {
                return _super.prototype.create.call(this, context);
            }
            catch (e) {
                this._rethrowWithContext(e);
                throw e;
            }
        };
        /**
         * @param {?} rootSelectorOrNode
         * @param {?} injector
         * @param {?=} projectableNodes
         * @return {?}
         */
        DebugAppView.prototype.createHostView = function (rootSelectorOrNode, injector, projectableNodes) {
            if (projectableNodes === void 0) { projectableNodes = null; }
            this._resetDebug();
            try {
                return _super.prototype.createHostView.call(this, rootSelectorOrNode, injector, projectableNodes);
            }
            catch (e) {
                this._rethrowWithContext(e);
                throw e;
            }
        };
        /**
         * @param {?} token
         * @param {?} nodeIndex
         * @param {?=} notFoundResult
         * @return {?}
         */
        DebugAppView.prototype.injectorGet = function (token, nodeIndex, notFoundResult) {
            this._resetDebug();
            try {
                return _super.prototype.injectorGet.call(this, token, nodeIndex, notFoundResult);
            }
            catch (e) {
                this._rethrowWithContext(e);
                throw e;
            }
        };
        /**
         * @return {?}
         */
        DebugAppView.prototype.detach = function () {
            this._resetDebug();
            try {
                _super.prototype.detach.call(this);
            }
            catch (e) {
                this._rethrowWithContext(e);
                throw e;
            }
        };
        /**
         * @return {?}
         */
        DebugAppView.prototype.destroy = function () {
            this._resetDebug();
            try {
                _super.prototype.destroy.call(this);
            }
            catch (e) {
                this._rethrowWithContext(e);
                throw e;
            }
        };
        /**
         * @param {?} throwOnChange
         * @return {?}
         */
        DebugAppView.prototype.detectChanges = function (throwOnChange) {
            this._resetDebug();
            try {
                _super.prototype.detectChanges.call(this, throwOnChange);
            }
            catch (e) {
                this._rethrowWithContext(e);
                throw e;
            }
        };
        /**
         * @return {?}
         */
        DebugAppView.prototype._resetDebug = function () { this._currentDebugContext = null; };
        /**
         * @param {?} nodeIndex
         * @param {?} rowNum
         * @param {?} colNum
         * @return {?}
         */
        DebugAppView.prototype.debug = function (nodeIndex, rowNum, colNum) {
            return this._currentDebugContext = new DebugContext(this, nodeIndex, rowNum, colNum);
        };
        /**
         * @param {?} e
         * @return {?}
         */
        DebugAppView.prototype._rethrowWithContext = function (e) {
            if (!(e instanceof ViewWrappedError)) {
                if (!(e instanceof ExpressionChangedAfterItHasBeenCheckedError)) {
                    this.cdMode = ChangeDetectorStatus.Errored;
                }
                if (isPresent(this._currentDebugContext)) {
                    throw new ViewWrappedError(e, this._currentDebugContext);
                }
            }
        };
        /**
         * @param {?} cb
         * @return {?}
         */
        DebugAppView.prototype.eventHandler = function (cb) {
            var _this = this;
            var /** @type {?} */ superHandler = _super.prototype.eventHandler.call(this, cb);
            return function (eventName, event) {
                _this._resetDebug();
                try {
                    return superHandler.call(_this, eventName, event);
                }
                catch (e) {
                    _this._rethrowWithContext(e);
                    throw e;
                }
            };
        };
        return DebugAppView;
    }(AppView));

    /**
     * A ViewContainer is created for elements that have a ViewContainerRef
     * to keep track of the nested views.
     */
    var ViewContainer = (function () {
        /**
         * @param {?} index
         * @param {?} parentIndex
         * @param {?} parentView
         * @param {?} nativeElement
         */
        function ViewContainer(index, parentIndex, parentView, nativeElement) {
            this.index = index;
            this.parentIndex = parentIndex;
            this.parentView = parentView;
            this.nativeElement = nativeElement;
        }
        Object.defineProperty(ViewContainer.prototype, "elementRef", {
            /**
             * @return {?}
             */
            get: function () { return new ElementRef(this.nativeElement); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ViewContainer.prototype, "vcRef", {
            /**
             * @return {?}
             */
            get: function () { return new ViewContainerRef_(this); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ViewContainer.prototype, "parentInjector", {
            /**
             * @return {?}
             */
            get: function () { return this.parentView.injector(this.parentIndex); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ViewContainer.prototype, "injector", {
            /**
             * @return {?}
             */
            get: function () { return this.parentView.injector(this.index); },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} throwOnChange
         * @return {?}
         */
        ViewContainer.prototype.detectChangesInNestedViews = function (throwOnChange) {
            if (this.nestedViews) {
                for (var /** @type {?} */ i = 0; i < this.nestedViews.length; i++) {
                    this.nestedViews[i].detectChanges(throwOnChange);
                }
            }
        };
        /**
         * @return {?}
         */
        ViewContainer.prototype.destroyNestedViews = function () {
            if (this.nestedViews) {
                for (var /** @type {?} */ i = 0; i < this.nestedViews.length; i++) {
                    this.nestedViews[i].destroy();
                }
            }
        };
        /**
         * @param {?} cb
         * @param {?} c
         * @return {?}
         */
        ViewContainer.prototype.visitNestedViewRootNodes = function (cb, c) {
            if (this.nestedViews) {
                for (var /** @type {?} */ i = 0; i < this.nestedViews.length; i++) {
                    this.nestedViews[i].visitRootNodesInternal(cb, c);
                }
            }
        };
        /**
         * @param {?} nestedViewClass
         * @param {?} callback
         * @return {?}
         */
        ViewContainer.prototype.mapNestedViews = function (nestedViewClass, callback) {
            var /** @type {?} */ result = [];
            if (this.nestedViews) {
                for (var /** @type {?} */ i = 0; i < this.nestedViews.length; i++) {
                    var /** @type {?} */ nestedView = this.nestedViews[i];
                    if (nestedView.clazz === nestedViewClass) {
                        result.push(callback(nestedView));
                    }
                }
            }
            if (this.projectedViews) {
                for (var /** @type {?} */ i = 0; i < this.projectedViews.length; i++) {
                    var /** @type {?} */ projectedView = this.projectedViews[i];
                    if (projectedView.clazz === nestedViewClass) {
                        result.push(callback(projectedView));
                    }
                }
            }
            return result;
        };
        /**
         * @param {?} view
         * @param {?} currentIndex
         * @return {?}
         */
        ViewContainer.prototype.moveView = function (view, currentIndex) {
            var /** @type {?} */ previousIndex = this.nestedViews.indexOf(view);
            if (view.type === ViewType.COMPONENT) {
                throw new Error("Component views can't be moved!");
            }
            var /** @type {?} */ nestedViews = this.nestedViews;
            if (nestedViews == null) {
                nestedViews = [];
                this.nestedViews = nestedViews;
            }
            nestedViews.splice(previousIndex, 1);
            nestedViews.splice(currentIndex, 0, view);
            var /** @type {?} */ prevView = currentIndex > 0 ? nestedViews[currentIndex - 1] : null;
            view.moveAfter(this, prevView);
        };
        /**
         * @param {?} view
         * @param {?} viewIndex
         * @return {?}
         */
        ViewContainer.prototype.attachView = function (view, viewIndex) {
            if (view.type === ViewType.COMPONENT) {
                throw new Error("Component views can't be moved!");
            }
            var /** @type {?} */ nestedViews = this.nestedViews;
            if (nestedViews == null) {
                nestedViews = [];
                this.nestedViews = nestedViews;
            }
            // perf: array.push is faster than array.splice!
            if (viewIndex >= nestedViews.length) {
                nestedViews.push(view);
            }
            else {
                nestedViews.splice(viewIndex, 0, view);
            }
            var /** @type {?} */ prevView = viewIndex > 0 ? nestedViews[viewIndex - 1] : null;
            view.attachAfter(this, prevView);
        };
        /**
         * @param {?} viewIndex
         * @return {?}
         */
        ViewContainer.prototype.detachView = function (viewIndex) {
            var /** @type {?} */ view = this.nestedViews[viewIndex];
            // perf: array.pop is faster than array.splice!
            if (viewIndex >= this.nestedViews.length - 1) {
                this.nestedViews.pop();
            }
            else {
                this.nestedViews.splice(viewIndex, 1);
            }
            if (view.type === ViewType.COMPONENT) {
                throw new Error("Component views can't be moved!");
            }
            view.detach();
            return view;
        };
        return ViewContainer;
    }());

    var /** @type {?} */ __core_private__ = {
        isDefaultChangeDetectionStrategy: isDefaultChangeDetectionStrategy,
        ChangeDetectorStatus: ChangeDetectorStatus,
        constructDependencies: constructDependencies,
        LifecycleHooks: LifecycleHooks,
        LIFECYCLE_HOOKS_VALUES: LIFECYCLE_HOOKS_VALUES,
        ReflectorReader: ReflectorReader,
        CodegenComponentFactoryResolver: CodegenComponentFactoryResolver,
        ComponentRef_: ComponentRef_,
        ViewContainer: ViewContainer,
        AppView: AppView,
        DebugAppView: DebugAppView,
        NgModuleInjector: NgModuleInjector,
        registerModuleFactory: registerModuleFactory,
        ViewType: ViewType,
        view_utils: view_utils,
        ViewMetadata: ViewMetadata,
        DebugContext: DebugContext,
        StaticNodeDebugInfo: StaticNodeDebugInfo,
        devModeEqual: devModeEqual,
        UNINITIALIZED: UNINITIALIZED,
        ValueUnwrapper: ValueUnwrapper,
        RenderDebugInfo: RenderDebugInfo,
        TemplateRef_: TemplateRef_,
        ReflectionCapabilities: ReflectionCapabilities,
        makeDecorator: makeDecorator,
        DebugDomRootRenderer: DebugDomRootRenderer,
        Console: Console,
        reflector: reflector,
        Reflector: Reflector,
        NoOpAnimationPlayer: NoOpAnimationPlayer,
        AnimationPlayer: AnimationPlayer,
        AnimationSequencePlayer: AnimationSequencePlayer,
        AnimationGroupPlayer: AnimationGroupPlayer,
        AnimationKeyframe: AnimationKeyframe,
        prepareFinalAnimationStyles: prepareFinalAnimationStyles,
        balanceAnimationKeyframes: balanceAnimationKeyframes,
        flattenStyles: flattenStyles,
        clearStyles: clearStyles,
        renderStyles: renderStyles,
        collectAndResolveStyles: collectAndResolveStyles,
        APP_ID_RANDOM_PROVIDER: APP_ID_RANDOM_PROVIDER,
        AnimationStyles: AnimationStyles,
        ANY_STATE: ANY_STATE,
        DEFAULT_STATE: DEFAULT_STATE,
        EMPTY_STATE: EMPTY_STATE,
        FILL_STYLE_FLAG: FILL_STYLE_FLAG,
        ComponentStillLoadingError: ComponentStillLoadingError,
        isPromise: isPromise,
        AnimationTransition: AnimationTransition
    };

    exports.createPlatform = createPlatform;
    exports.assertPlatform = assertPlatform;
    exports.destroyPlatform = destroyPlatform;
    exports.getPlatform = getPlatform;
    exports.PlatformRef = PlatformRef;
    exports.ApplicationRef = ApplicationRef;
    exports.enableProdMode = enableProdMode;
    exports.isDevMode = isDevMode;
    exports.createPlatformFactory = createPlatformFactory;
    exports.NgProbeToken = NgProbeToken;
    exports.APP_ID = APP_ID;
    exports.PACKAGE_ROOT_URL = PACKAGE_ROOT_URL;
    exports.PLATFORM_INITIALIZER = PLATFORM_INITIALIZER;
    exports.APP_BOOTSTRAP_LISTENER = APP_BOOTSTRAP_LISTENER;
    exports.APP_INITIALIZER = APP_INITIALIZER;
    exports.ApplicationInitStatus = ApplicationInitStatus;
    exports.DebugElement = DebugElement;
    exports.DebugNode = DebugNode;
    exports.asNativeElements = asNativeElements;
    exports.getDebugNode = getDebugNode;
    exports.Testability = Testability;
    exports.TestabilityRegistry = TestabilityRegistry;
    exports.setTestabilityGetter = setTestabilityGetter;
    exports.TRANSLATIONS = TRANSLATIONS;
    exports.TRANSLATIONS_FORMAT = TRANSLATIONS_FORMAT;
    exports.LOCALE_ID = LOCALE_ID;
    exports.ApplicationModule = ApplicationModule;
    exports.wtfCreateScope = wtfCreateScope;
    exports.wtfLeave = wtfLeave;
    exports.wtfStartTimeRange = wtfStartTimeRange;
    exports.wtfEndTimeRange = wtfEndTimeRange;
    exports.Type = Type;
    exports.EventEmitter = EventEmitter;
    exports.ErrorHandler = ErrorHandler;
    exports.AnimationTransitionEvent = AnimationTransitionEvent;
    exports.AnimationPlayer = AnimationPlayer;
    exports.AnimationStyles = AnimationStyles;
    exports.AnimationKeyframe = AnimationKeyframe;
    exports.Sanitizer = Sanitizer;
    exports.SecurityContext = SecurityContext;
    exports.ANALYZE_FOR_ENTRY_COMPONENTS = ANALYZE_FOR_ENTRY_COMPONENTS;
    exports.Attribute = Attribute;
    exports.ContentChild = ContentChild;
    exports.ContentChildren = ContentChildren;
    exports.Query = Query;
    exports.ViewChild = ViewChild;
    exports.ViewChildren = ViewChildren;
    exports.Component = Component;
    exports.Directive = Directive;
    exports.HostBinding = HostBinding;
    exports.HostListener = HostListener;
    exports.Input = Input;
    exports.Output = Output;
    exports.Pipe = Pipe;
    exports.AfterContentChecked = AfterContentChecked;
    exports.AfterContentInit = AfterContentInit;
    exports.AfterViewChecked = AfterViewChecked;
    exports.AfterViewInit = AfterViewInit;
    exports.DoCheck = DoCheck;
    exports.OnChanges = OnChanges;
    exports.OnDestroy = OnDestroy;
    exports.OnInit = OnInit;
    exports.CUSTOM_ELEMENTS_SCHEMA = CUSTOM_ELEMENTS_SCHEMA;
    exports.NO_ERRORS_SCHEMA = NO_ERRORS_SCHEMA;
    exports.NgModule = NgModule;
    exports.ViewEncapsulation = ViewEncapsulation;
    exports.Version = Version;
    exports.VERSION = VERSION;
    exports.Class = Class;
    exports.forwardRef = forwardRef;
    exports.resolveForwardRef = resolveForwardRef;
    exports.Injector = Injector;
    exports.ReflectiveInjector = ReflectiveInjector;
    exports.ResolvedReflectiveFactory = ResolvedReflectiveFactory;
    exports.ReflectiveKey = ReflectiveKey;
    exports.OpaqueToken = OpaqueToken;
    exports.Inject = Inject;
    exports.Optional = Optional;
    exports.Injectable = Injectable;
    exports.Self = Self;
    exports.SkipSelf = SkipSelf;
    exports.Host = Host;
    exports.NgZone = NgZone;
    exports.RenderComponentType = RenderComponentType;
    exports.Renderer = Renderer;
    exports.RootRenderer = RootRenderer;
    exports.COMPILER_OPTIONS = COMPILER_OPTIONS;
    exports.Compiler = Compiler;
    exports.CompilerFactory = CompilerFactory;
    exports.ModuleWithComponentFactories = ModuleWithComponentFactories;
    exports.ComponentFactory = ComponentFactory;
    exports.ComponentRef = ComponentRef;
    exports.ComponentFactoryResolver = ComponentFactoryResolver;
    exports.ElementRef = ElementRef;
    exports.NgModuleFactory = NgModuleFactory;
    exports.NgModuleRef = NgModuleRef;
    exports.NgModuleFactoryLoader = NgModuleFactoryLoader;
    exports.getModuleFactory = getModuleFactory;
    exports.QueryList = QueryList;
    exports.SystemJsNgModuleLoader = SystemJsNgModuleLoader;
    exports.SystemJsNgModuleLoaderConfig = SystemJsNgModuleLoaderConfig;
    exports.TemplateRef = TemplateRef;
    exports.ViewContainerRef = ViewContainerRef;
    exports.EmbeddedViewRef = EmbeddedViewRef;
    exports.ViewRef = ViewRef;
    exports.ChangeDetectionStrategy = ChangeDetectionStrategy;
    exports.ChangeDetectorRef = ChangeDetectorRef;
    exports.CollectionChangeRecord = CollectionChangeRecord;
    exports.DefaultIterableDiffer = DefaultIterableDiffer;
    exports.IterableDiffers = IterableDiffers;
    exports.KeyValueChangeRecord = KeyValueChangeRecord;
    exports.KeyValueDiffers = KeyValueDiffers;
    exports.SimpleChange = SimpleChange;
    exports.WrappedValue = WrappedValue;
    exports.platformCore = platformCore;
    exports.__core_private__ = __core_private__;
    exports.AUTO_STYLE = AUTO_STYLE;
    exports.AnimationEntryMetadata = AnimationEntryMetadata;
    exports.AnimationStateMetadata = AnimationStateMetadata;
    exports.AnimationStateDeclarationMetadata = AnimationStateDeclarationMetadata;
    exports.AnimationStateTransitionMetadata = AnimationStateTransitionMetadata;
    exports.AnimationMetadata = AnimationMetadata;
    exports.AnimationKeyframesSequenceMetadata = AnimationKeyframesSequenceMetadata;
    exports.AnimationStyleMetadata = AnimationStyleMetadata;
    exports.AnimationAnimateMetadata = AnimationAnimateMetadata;
    exports.AnimationWithStepsMetadata = AnimationWithStepsMetadata;
    exports.AnimationSequenceMetadata = AnimationSequenceMetadata;
    exports.AnimationGroupMetadata = AnimationGroupMetadata;
    exports.animate = animate;
    exports.group = group;
    exports.sequence = sequence;
    exports.style = style;
    exports.state = state;
    exports.keyframes = keyframes;
    exports.transition = transition;
    exports.trigger = trigger;

}));
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"rxjs/Observable":2,"rxjs/Subject":4}],2:[function(require,module,exports){
"use strict";
var root_1 = require('./util/root');
var toSubscriber_1 = require('./util/toSubscriber');
var observable_1 = require('./symbol/observable');
/**
 * A representation of any set of values over any amount of time. This the most basic building block
 * of RxJS.
 *
 * @class Observable<T>
 */
var Observable = (function () {
    /**
     * @constructor
     * @param {Function} subscribe the function that is  called when the Observable is
     * initially subscribed to. This function is given a Subscriber, to which new values
     * can be `next`ed, or an `error` method can be called to raise an error, or
     * `complete` can be called to notify of a successful completion.
     */
    function Observable(subscribe) {
        this._isScalar = false;
        if (subscribe) {
            this._subscribe = subscribe;
        }
    }
    /**
     * Creates a new Observable, with this Observable as the source, and the passed
     * operator defined as the new observable's operator.
     * @method lift
     * @param {Operator} operator the operator defining the operation to take on the observable
     * @return {Observable} a new observable with the Operator applied
     */
    Observable.prototype.lift = function (operator) {
        var observable = new Observable();
        observable.source = this;
        observable.operator = operator;
        return observable;
    };
    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
        var operator = this.operator;
        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
        if (operator) {
            operator.call(sink, this.source);
        }
        else {
            sink.add(this._subscribe(sink));
        }
        if (sink.syncErrorThrowable) {
            sink.syncErrorThrowable = false;
            if (sink.syncErrorThrown) {
                throw sink.syncErrorValue;
            }
        }
        return sink;
    };
    /**
     * @method forEach
     * @param {Function} next a handler for each value emitted by the observable
     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise
     * @return {Promise} a promise that either resolves on observable completion or
     *  rejects with the handled error
     */
    Observable.prototype.forEach = function (next, PromiseCtor) {
        var _this = this;
        if (!PromiseCtor) {
            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
                PromiseCtor = root_1.root.Rx.config.Promise;
            }
            else if (root_1.root.Promise) {
                PromiseCtor = root_1.root.Promise;
            }
        }
        if (!PromiseCtor) {
            throw new Error('no Promise impl found');
        }
        return new PromiseCtor(function (resolve, reject) {
            var subscription = _this.subscribe(function (value) {
                if (subscription) {
                    // if there is a subscription, then we can surmise
                    // the next handling is asynchronous. Any errors thrown
                    // need to be rejected explicitly and unsubscribe must be
                    // called manually
                    try {
                        next(value);
                    }
                    catch (err) {
                        reject(err);
                        subscription.unsubscribe();
                    }
                }
                else {
                    // if there is NO subscription, then we're getting a nexted
                    // value synchronously during subscription. We can just call it.
                    // If it errors, Observable's `subscribe` will ensure the
                    // unsubscription logic is called, then synchronously rethrow the error.
                    // After that, Promise will trap the error and send it
                    // down the rejection path.
                    next(value);
                }
            }, reject, resolve);
        });
    };
    Observable.prototype._subscribe = function (subscriber) {
        return this.source.subscribe(subscriber);
    };
    /**
     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable
     * @method Symbol.observable
     * @return {Observable} this instance of the observable
     */
    Observable.prototype[observable_1.$$observable] = function () {
        return this;
    };
    // HACK: Since TypeScript inherits static properties too, we have to
    // fight against TypeScript here so Subject can have a different static create signature
    /**
     * Creates a new cold Observable by calling the Observable constructor
     * @static true
     * @owner Observable
     * @method create
     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
     * @return {Observable} a new cold observable
     */
    Observable.create = function (subscribe) {
        return new Observable(subscribe);
    };
    return Observable;
}());
exports.Observable = Observable;

},{"./symbol/observable":8,"./util/root":16,"./util/toSubscriber":17}],3:[function(require,module,exports){
"use strict";
exports.empty = {
    closed: true,
    next: function (value) { },
    error: function (err) { throw err; },
    complete: function () { }
};

},{}],4:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('./Observable');
var Subscriber_1 = require('./Subscriber');
var Subscription_1 = require('./Subscription');
var ObjectUnsubscribedError_1 = require('./util/ObjectUnsubscribedError');
var SubjectSubscription_1 = require('./SubjectSubscription');
var rxSubscriber_1 = require('./symbol/rxSubscriber');
/**
 * @class SubjectSubscriber<T>
 */
var SubjectSubscriber = (function (_super) {
    __extends(SubjectSubscriber, _super);
    function SubjectSubscriber(destination) {
        _super.call(this, destination);
        this.destination = destination;
    }
    return SubjectSubscriber;
}(Subscriber_1.Subscriber));
exports.SubjectSubscriber = SubjectSubscriber;
/**
 * @class Subject<T>
 */
var Subject = (function (_super) {
    __extends(Subject, _super);
    function Subject() {
        _super.call(this);
        this.observers = [];
        this.closed = false;
        this.isStopped = false;
        this.hasError = false;
        this.thrownError = null;
    }
    Subject.prototype[rxSubscriber_1.$$rxSubscriber] = function () {
        return new SubjectSubscriber(this);
    };
    Subject.prototype.lift = function (operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
    };
    Subject.prototype.next = function (value) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        if (!this.isStopped) {
            var observers = this.observers;
            var len = observers.length;
            var copy = observers.slice();
            for (var i = 0; i < len; i++) {
                copy[i].next(value);
            }
        }
    };
    Subject.prototype.error = function (err) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.hasError = true;
        this.thrownError = err;
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].error(err);
        }
        this.observers.length = 0;
    };
    Subject.prototype.complete = function () {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].complete();
        }
        this.observers.length = 0;
    };
    Subject.prototype.unsubscribe = function () {
        this.isStopped = true;
        this.closed = true;
        this.observers = null;
    };
    Subject.prototype._subscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else if (this.hasError) {
            subscriber.error(this.thrownError);
            return Subscription_1.Subscription.EMPTY;
        }
        else if (this.isStopped) {
            subscriber.complete();
            return Subscription_1.Subscription.EMPTY;
        }
        else {
            this.observers.push(subscriber);
            return new SubjectSubscription_1.SubjectSubscription(this, subscriber);
        }
    };
    Subject.prototype.asObservable = function () {
        var observable = new Observable_1.Observable();
        observable.source = this;
        return observable;
    };
    Subject.create = function (destination, source) {
        return new AnonymousSubject(destination, source);
    };
    return Subject;
}(Observable_1.Observable));
exports.Subject = Subject;
/**
 * @class AnonymousSubject<T>
 */
var AnonymousSubject = (function (_super) {
    __extends(AnonymousSubject, _super);
    function AnonymousSubject(destination, source) {
        _super.call(this);
        this.destination = destination;
        this.source = source;
    }
    AnonymousSubject.prototype.next = function (value) {
        var destination = this.destination;
        if (destination && destination.next) {
            destination.next(value);
        }
    };
    AnonymousSubject.prototype.error = function (err) {
        var destination = this.destination;
        if (destination && destination.error) {
            this.destination.error(err);
        }
    };
    AnonymousSubject.prototype.complete = function () {
        var destination = this.destination;
        if (destination && destination.complete) {
            this.destination.complete();
        }
    };
    AnonymousSubject.prototype._subscribe = function (subscriber) {
        var source = this.source;
        if (source) {
            return this.source.subscribe(subscriber);
        }
        else {
            return Subscription_1.Subscription.EMPTY;
        }
    };
    return AnonymousSubject;
}(Subject));
exports.AnonymousSubject = AnonymousSubject;

},{"./Observable":2,"./SubjectSubscription":5,"./Subscriber":6,"./Subscription":7,"./symbol/rxSubscriber":9,"./util/ObjectUnsubscribedError":10}],5:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscription_1 = require('./Subscription');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SubjectSubscription = (function (_super) {
    __extends(SubjectSubscription, _super);
    function SubjectSubscription(subject, subscriber) {
        _super.call(this);
        this.subject = subject;
        this.subscriber = subscriber;
        this.closed = false;
    }
    SubjectSubscription.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.closed = true;
        var subject = this.subject;
        var observers = subject.observers;
        this.subject = null;
        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
            return;
        }
        var subscriberIndex = observers.indexOf(this.subscriber);
        if (subscriberIndex !== -1) {
            observers.splice(subscriberIndex, 1);
        }
    };
    return SubjectSubscription;
}(Subscription_1.Subscription));
exports.SubjectSubscription = SubjectSubscription;

},{"./Subscription":7}],6:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var isFunction_1 = require('./util/isFunction');
var Subscription_1 = require('./Subscription');
var Observer_1 = require('./Observer');
var rxSubscriber_1 = require('./symbol/rxSubscriber');
/**
 * Implements the {@link Observer} interface and extends the
 * {@link Subscription} class. While the {@link Observer} is the public API for
 * consuming the values of an {@link Observable}, all Observers get converted to
 * a Subscriber, in order to provide Subscription-like capabilities such as
 * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for
 * implementing operators, but it is rarely used as a public API.
 *
 * @class Subscriber<T>
 */
var Subscriber = (function (_super) {
    __extends(Subscriber, _super);
    /**
     * @param {Observer|function(value: T): void} [destinationOrNext] A partially
     * defined Observer or a `next` callback function.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     */
    function Subscriber(destinationOrNext, error, complete) {
        _super.call(this);
        this.syncErrorValue = null;
        this.syncErrorThrown = false;
        this.syncErrorThrowable = false;
        this.isStopped = false;
        switch (arguments.length) {
            case 0:
                this.destination = Observer_1.empty;
                break;
            case 1:
                if (!destinationOrNext) {
                    this.destination = Observer_1.empty;
                    break;
                }
                if (typeof destinationOrNext === 'object') {
                    if (destinationOrNext instanceof Subscriber) {
                        this.destination = destinationOrNext;
                        this.destination.add(this);
                    }
                    else {
                        this.syncErrorThrowable = true;
                        this.destination = new SafeSubscriber(this, destinationOrNext);
                    }
                    break;
                }
            default:
                this.syncErrorThrowable = true;
                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);
                break;
        }
    }
    Subscriber.prototype[rxSubscriber_1.$$rxSubscriber] = function () { return this; };
    /**
     * A static factory for a Subscriber, given a (potentially partial) definition
     * of an Observer.
     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)
     * Observer represented by the given arguments.
     */
    Subscriber.create = function (next, error, complete) {
        var subscriber = new Subscriber(next, error, complete);
        subscriber.syncErrorThrowable = false;
        return subscriber;
    };
    /**
     * The {@link Observer} callback to receive notifications of type `next` from
     * the Observable, with a value. The Observable may call this method 0 or more
     * times.
     * @param {T} [value] The `next` value.
     * @return {void}
     */
    Subscriber.prototype.next = function (value) {
        if (!this.isStopped) {
            this._next(value);
        }
    };
    /**
     * The {@link Observer} callback to receive notifications of type `error` from
     * the Observable, with an attached {@link Error}. Notifies the Observer that
     * the Observable has experienced an error condition.
     * @param {any} [err] The `error` exception.
     * @return {void}
     */
    Subscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            this.isStopped = true;
            this._error(err);
        }
    };
    /**
     * The {@link Observer} callback to receive a valueless notification of type
     * `complete` from the Observable. Notifies the Observer that the Observable
     * has finished sending push-based notifications.
     * @return {void}
     */
    Subscriber.prototype.complete = function () {
        if (!this.isStopped) {
            this.isStopped = true;
            this._complete();
        }
    };
    Subscriber.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
    };
    Subscriber.prototype._next = function (value) {
        this.destination.next(value);
    };
    Subscriber.prototype._error = function (err) {
        this.destination.error(err);
        this.unsubscribe();
    };
    Subscriber.prototype._complete = function () {
        this.destination.complete();
        this.unsubscribe();
    };
    return Subscriber;
}(Subscription_1.Subscription));
exports.Subscriber = Subscriber;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SafeSubscriber = (function (_super) {
    __extends(SafeSubscriber, _super);
    function SafeSubscriber(_parent, observerOrNext, error, complete) {
        _super.call(this);
        this._parent = _parent;
        var next;
        var context = this;
        if (isFunction_1.isFunction(observerOrNext)) {
            next = observerOrNext;
        }
        else if (observerOrNext) {
            context = observerOrNext;
            next = observerOrNext.next;
            error = observerOrNext.error;
            complete = observerOrNext.complete;
            if (isFunction_1.isFunction(context.unsubscribe)) {
                this.add(context.unsubscribe.bind(context));
            }
            context.unsubscribe = this.unsubscribe.bind(this);
        }
        this._context = context;
        this._next = next;
        this._error = error;
        this._complete = complete;
    }
    SafeSubscriber.prototype.next = function (value) {
        if (!this.isStopped && this._next) {
            var _parent = this._parent;
            if (!_parent.syncErrorThrowable) {
                this.__tryOrUnsub(this._next, value);
            }
            else if (this.__tryOrSetError(_parent, this._next, value)) {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _parent = this._parent;
            if (this._error) {
                if (!_parent.syncErrorThrowable) {
                    this.__tryOrUnsub(this._error, err);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parent, this._error, err);
                    this.unsubscribe();
                }
            }
            else if (!_parent.syncErrorThrowable) {
                this.unsubscribe();
                throw err;
            }
            else {
                _parent.syncErrorValue = err;
                _parent.syncErrorThrown = true;
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.complete = function () {
        if (!this.isStopped) {
            var _parent = this._parent;
            if (this._complete) {
                if (!_parent.syncErrorThrowable) {
                    this.__tryOrUnsub(this._complete);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parent, this._complete);
                    this.unsubscribe();
                }
            }
            else {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            this.unsubscribe();
            throw err;
        }
    };
    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            parent.syncErrorValue = err;
            parent.syncErrorThrown = true;
            return true;
        }
        return false;
    };
    SafeSubscriber.prototype._unsubscribe = function () {
        var _parent = this._parent;
        this._context = null;
        this._parent = null;
        _parent.unsubscribe();
    };
    return SafeSubscriber;
}(Subscriber));

},{"./Observer":3,"./Subscription":7,"./symbol/rxSubscriber":9,"./util/isFunction":14}],7:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var isArray_1 = require('./util/isArray');
var isObject_1 = require('./util/isObject');
var isFunction_1 = require('./util/isFunction');
var tryCatch_1 = require('./util/tryCatch');
var errorObject_1 = require('./util/errorObject');
var UnsubscriptionError_1 = require('./util/UnsubscriptionError');
/**
 * Represents a disposable resource, such as the execution of an Observable. A
 * Subscription has one important method, `unsubscribe`, that takes no argument
 * and just disposes the resource held by the subscription.
 *
 * Additionally, subscriptions may be grouped together through the `add()`
 * method, which will attach a child Subscription to the current Subscription.
 * When a Subscription is unsubscribed, all its children (and its grandchildren)
 * will be unsubscribed as well.
 *
 * @class Subscription
 */
var Subscription = (function () {
    /**
     * @param {function(): void} [unsubscribe] A function describing how to
     * perform the disposal of resources when the `unsubscribe` method is called.
     */
    function Subscription(unsubscribe) {
        /**
         * A flag to indicate whether this Subscription has already been unsubscribed.
         * @type {boolean}
         */
        this.closed = false;
        if (unsubscribe) {
            this._unsubscribe = unsubscribe;
        }
    }
    /**
     * Disposes the resources held by the subscription. May, for instance, cancel
     * an ongoing Observable execution or cancel any other type of work that
     * started when the Subscription was created.
     * @return {void}
     */
    Subscription.prototype.unsubscribe = function () {
        var hasErrors = false;
        var errors;
        if (this.closed) {
            return;
        }
        this.closed = true;
        var _a = this, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
        this._subscriptions = null;
        if (isFunction_1.isFunction(_unsubscribe)) {
            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);
            if (trial === errorObject_1.errorObject) {
                hasErrors = true;
                errors = errors || (errorObject_1.errorObject.e instanceof UnsubscriptionError_1.UnsubscriptionError ?
                    flattenUnsubscriptionErrors(errorObject_1.errorObject.e.errors) : [errorObject_1.errorObject.e]);
            }
        }
        if (isArray_1.isArray(_subscriptions)) {
            var index = -1;
            var len = _subscriptions.length;
            while (++index < len) {
                var sub = _subscriptions[index];
                if (isObject_1.isObject(sub)) {
                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);
                    if (trial === errorObject_1.errorObject) {
                        hasErrors = true;
                        errors = errors || [];
                        var err = errorObject_1.errorObject.e;
                        if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
                            errors = errors.concat(flattenUnsubscriptionErrors(err.errors));
                        }
                        else {
                            errors.push(err);
                        }
                    }
                }
            }
        }
        if (hasErrors) {
            throw new UnsubscriptionError_1.UnsubscriptionError(errors);
        }
    };
    /**
     * Adds a tear down to be called during the unsubscribe() of this
     * Subscription.
     *
     * If the tear down being added is a subscription that is already
     * unsubscribed, is the same reference `add` is being called on, or is
     * `Subscription.EMPTY`, it will not be added.
     *
     * If this subscription is already in an `closed` state, the passed
     * tear down logic will be executed immediately.
     *
     * @param {TeardownLogic} teardown The additional logic to execute on
     * teardown.
     * @return {Subscription} Returns the Subscription used or created to be
     * added to the inner subscriptions list. This Subscription can be used with
     * `remove()` to remove the passed teardown logic from the inner subscriptions
     * list.
     */
    Subscription.prototype.add = function (teardown) {
        if (!teardown || (teardown === Subscription.EMPTY)) {
            return Subscription.EMPTY;
        }
        if (teardown === this) {
            return this;
        }
        var sub = teardown;
        switch (typeof teardown) {
            case 'function':
                sub = new Subscription(teardown);
            case 'object':
                if (sub.closed || typeof sub.unsubscribe !== 'function') {
                    return sub;
                }
                else if (this.closed) {
                    sub.unsubscribe();
                    return sub;
                }
                break;
            default:
                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
        }
        var childSub = new ChildSubscription(sub, this);
        this._subscriptions = this._subscriptions || [];
        this._subscriptions.push(childSub);
        return childSub;
    };
    /**
     * Removes a Subscription from the internal list of subscriptions that will
     * unsubscribe during the unsubscribe process of this Subscription.
     * @param {Subscription} subscription The subscription to remove.
     * @return {void}
     */
    Subscription.prototype.remove = function (subscription) {
        // HACK: This might be redundant because of the logic in `add()`
        if (subscription == null || (subscription === this) || (subscription === Subscription.EMPTY)) {
            return;
        }
        var subscriptions = this._subscriptions;
        if (subscriptions) {
            var subscriptionIndex = subscriptions.indexOf(subscription);
            if (subscriptionIndex !== -1) {
                subscriptions.splice(subscriptionIndex, 1);
            }
        }
    };
    Subscription.EMPTY = (function (empty) {
        empty.closed = true;
        return empty;
    }(new Subscription()));
    return Subscription;
}());
exports.Subscription = Subscription;
var ChildSubscription = (function (_super) {
    __extends(ChildSubscription, _super);
    function ChildSubscription(_innerSub, _parent) {
        _super.call(this);
        this._innerSub = _innerSub;
        this._parent = _parent;
    }
    ChildSubscription.prototype._unsubscribe = function () {
        var _a = this, _innerSub = _a._innerSub, _parent = _a._parent;
        _parent.remove(this);
        _innerSub.unsubscribe();
    };
    return ChildSubscription;
}(Subscription));
exports.ChildSubscription = ChildSubscription;
function flattenUnsubscriptionErrors(errors) {
    return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError_1.UnsubscriptionError) ? err.errors : err); }, []);
}

},{"./util/UnsubscriptionError":11,"./util/errorObject":12,"./util/isArray":13,"./util/isFunction":14,"./util/isObject":15,"./util/tryCatch":18}],8:[function(require,module,exports){
"use strict";
var root_1 = require('../util/root');
function getSymbolObservable(context) {
    var $$observable;
    var Symbol = context.Symbol;
    if (typeof Symbol === 'function') {
        if (Symbol.observable) {
            $$observable = Symbol.observable;
        }
        else {
            $$observable = Symbol('observable');
            Symbol.observable = $$observable;
        }
    }
    else {
        $$observable = '@@observable';
    }
    return $$observable;
}
exports.getSymbolObservable = getSymbolObservable;
exports.$$observable = getSymbolObservable(root_1.root);

},{"../util/root":16}],9:[function(require,module,exports){
"use strict";
var root_1 = require('../util/root');
var Symbol = root_1.root.Symbol;
exports.$$rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?
    Symbol.for('rxSubscriber') : '@@rxSubscriber';

},{"../util/root":16}],10:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when an action is invalid because the object has been
 * unsubscribed.
 *
 * @see {@link Subject}
 * @see {@link BehaviorSubject}
 *
 * @class ObjectUnsubscribedError
 */
var ObjectUnsubscribedError = (function (_super) {
    __extends(ObjectUnsubscribedError, _super);
    function ObjectUnsubscribedError() {
        var err = _super.call(this, 'object unsubscribed');
        this.name = err.name = 'ObjectUnsubscribedError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return ObjectUnsubscribedError;
}(Error));
exports.ObjectUnsubscribedError = ObjectUnsubscribedError;

},{}],11:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when one or more errors have occurred during the
 * `unsubscribe` of a {@link Subscription}.
 */
var UnsubscriptionError = (function (_super) {
    __extends(UnsubscriptionError, _super);
    function UnsubscriptionError(errors) {
        _super.call(this);
        this.errors = errors;
        var err = Error.call(this, errors ?
            errors.length + " errors occurred during unsubscription:\n  " + errors.map(function (err, i) { return ((i + 1) + ") " + err.toString()); }).join('\n  ') : '');
        this.name = err.name = 'UnsubscriptionError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return UnsubscriptionError;
}(Error));
exports.UnsubscriptionError = UnsubscriptionError;

},{}],12:[function(require,module,exports){
"use strict";
// typeof any so that it we don't have to cast when comparing a result to the error object
exports.errorObject = { e: {} };

},{}],13:[function(require,module,exports){
"use strict";
exports.isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });

},{}],14:[function(require,module,exports){
"use strict";
function isFunction(x) {
    return typeof x === 'function';
}
exports.isFunction = isFunction;

},{}],15:[function(require,module,exports){
"use strict";
function isObject(x) {
    return x != null && typeof x === 'object';
}
exports.isObject = isObject;

},{}],16:[function(require,module,exports){
(function (global){
"use strict";
/**
 * window: browser in DOM main thread
 * self: browser in WebWorker
 * global: Node.js/other
 */
exports.root = (typeof window == 'object' && window.window === window && window
    || typeof self == 'object' && self.self === self && self
    || typeof global == 'object' && global.global === global && global);
if (!exports.root) {
    throw new Error('RxJS could not find any global context (window, self, global)');
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],17:[function(require,module,exports){
"use strict";
var Subscriber_1 = require('../Subscriber');
var rxSubscriber_1 = require('../symbol/rxSubscriber');
var Observer_1 = require('../Observer');
function toSubscriber(nextOrObserver, error, complete) {
    if (nextOrObserver) {
        if (nextOrObserver instanceof Subscriber_1.Subscriber) {
            return nextOrObserver;
        }
        if (nextOrObserver[rxSubscriber_1.$$rxSubscriber]) {
            return nextOrObserver[rxSubscriber_1.$$rxSubscriber]();
        }
    }
    if (!nextOrObserver && !error && !complete) {
        return new Subscriber_1.Subscriber(Observer_1.empty);
    }
    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);
}
exports.toSubscriber = toSubscriber;

},{"../Observer":3,"../Subscriber":6,"../symbol/rxSubscriber":9}],18:[function(require,module,exports){
"use strict";
var errorObject_1 = require('./errorObject');
var tryCatchTarget;
function tryCatcher() {
    try {
        return tryCatchTarget.apply(this, arguments);
    }
    catch (e) {
        errorObject_1.errorObject.e = e;
        return errorObject_1.errorObject;
    }
}
function tryCatch(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
}
exports.tryCatch = tryCatch;
;

},{"./errorObject":12}],19:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var core_1 = require("@angular/core");
var AppComponent = (function () {
    function AppComponent() {
        this.name = 'Angular';
    }
    return AppComponent;
}());
AppComponent = __decorate([
    core_1.Component({
        selector: 'my-app',
        template: "<h1>Hello {{name}}</h1>"
    })
], AppComponent);
exports.AppComponent = AppComponent;
},{"@angular/core":1}]},{},[19])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29yZS9idW5kbGVzL2NvcmUudW1kLmpzIiwibm9kZV9tb2R1bGVzL3J4anMvT2JzZXJ2YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9yeGpzL09ic2VydmVyLmpzIiwibm9kZV9tb2R1bGVzL3J4anMvU3ViamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9yeGpzL1N1YmplY3RTdWJzY3JpcHRpb24uanMiLCJub2RlX21vZHVsZXMvcnhqcy9TdWJzY3JpYmVyLmpzIiwibm9kZV9tb2R1bGVzL3J4anMvU3Vic2NyaXB0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3J4anMvc3ltYm9sL29ic2VydmFibGUuanMiLCJub2RlX21vZHVsZXMvcnhqcy9zeW1ib2wvcnhTdWJzY3JpYmVyLmpzIiwibm9kZV9tb2R1bGVzL3J4anMvdXRpbC9PYmplY3RVbnN1YnNjcmliZWRFcnJvci5qcyIsIm5vZGVfbW9kdWxlcy9yeGpzL3V0aWwvVW5zdWJzY3JpcHRpb25FcnJvci5qcyIsIm5vZGVfbW9kdWxlcy9yeGpzL3V0aWwvZXJyb3JPYmplY3QuanMiLCJub2RlX21vZHVsZXMvcnhqcy91dGlsL2lzQXJyYXkuanMiLCJub2RlX21vZHVsZXMvcnhqcy91dGlsL2lzRnVuY3Rpb24uanMiLCJub2RlX21vZHVsZXMvcnhqcy91dGlsL2lzT2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL3J4anMvdXRpbC9yb290LmpzIiwibm9kZV9tb2R1bGVzL3J4anMvdXRpbC90b1N1YnNjcmliZXIuanMiLCJub2RlX21vZHVsZXMvcnhqcy91dGlsL3RyeUNhdGNoLmpzIiwic3JjL2FwcC9hcHAudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDci9aQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUNsQkEsc0NBQTBDO0FBTTFDLElBQWEsWUFBWTtJQUp6QjtRQUk0QixTQUFJLEdBQUcsU0FBUyxDQUFDO0lBQUMsQ0FBQztJQUFELG1CQUFDO0FBQUQsQ0FBOUMsQUFBK0MsSUFBQTtBQUFsQyxZQUFZO0lBSnhCLGdCQUFTLENBQUM7UUFDVCxRQUFRLEVBQUUsUUFBUTtRQUNsQixRQUFRLEVBQUUseUJBQXlCO0tBQ3BDLENBQUM7R0FDVyxZQUFZLENBQXNCO0FBQWxDLG9DQUFZIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8qKlxuICogQGxpY2Vuc2UgQW5ndWxhciB2Mi40LjVcbiAqIChjKSAyMDEwLTIwMTYgR29vZ2xlLCBJbmMuIGh0dHBzOi8vYW5ndWxhci5pby9cbiAqIExpY2Vuc2U6IE1JVFxuICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cywgcmVxdWlyZSgncnhqcy9TdWJqZWN0JyksIHJlcXVpcmUoJ3J4anMvT2JzZXJ2YWJsZScpKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICdyeGpzL1N1YmplY3QnLCAncnhqcy9PYnNlcnZhYmxlJ10sIGZhY3RvcnkpIDpcbiAgICAoZmFjdG9yeSgoZ2xvYmFsLm5nID0gZ2xvYmFsLm5nIHx8IHt9LCBnbG9iYWwubmcuY29yZSA9IGdsb2JhbC5uZy5jb3JlIHx8IHt9KSxnbG9iYWwuUngsZ2xvYmFsLlJ4KSk7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzLHJ4anNfU3ViamVjdCxyeGpzX09ic2VydmFibGUpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGdsb2JhbFNjb3BlO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAodHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGUpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IFJlcGxhY2UgYW55IHdpdGggV29ya2VyR2xvYmFsU2NvcGUgZnJvbSBsaWIud2Vid29ya2VyLmQudHMgIzM0OTJcbiAgICAgICAgICAgIGdsb2JhbFNjb3BlID0gKHNlbGYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFsU2NvcGUgPSAoZ2xvYmFsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2xvYmFsU2NvcGUgPSAod2luZG93KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBmblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2NoZWR1bGVNaWNyb1Rhc2soZm4pIHtcbiAgICAgICAgWm9uZS5jdXJyZW50LnNjaGVkdWxlTWljcm9UYXNrKCdzY2hlZHVsZU1pY3JvdGFzaycsIGZuKTtcbiAgICB9XG4gICAgLy8gTmVlZCB0byBkZWNsYXJlIGEgbmV3IHZhcmlhYmxlIGZvciBnbG9iYWwgaGVyZSBzaW5jZSBUeXBlU2NyaXB0XG4gICAgLy8gZXhwb3J0cyB0aGUgb3JpZ2luYWwgdmFsdWUgb2YgdGhlIHN5bWJvbC5cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBnbG9iYWwkMSA9IGdsb2JhbFNjb3BlO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0VHlwZU5hbWVGb3JEZWJ1Z2dpbmcodHlwZSkge1xuICAgICAgICByZXR1cm4gdHlwZVsnbmFtZSddIHx8IHR5cGVvZiB0eXBlO1xuICAgIH1cbiAgICAvLyBUT0RPOiByZW1vdmUgY2FsbHMgdG8gYXNzZXJ0IGluIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRcbiAgICAvLyBOb3RlOiBDYW4ndCBqdXN0IGV4cG9ydCB0aGlzIGFuZCBpbXBvcnQgaW4gaW4gb3RoZXIgZmlsZXNcbiAgICAvLyBhcyBgYXNzZXJ0YCBpcyBhIHJlc2VydmVkIGtleXdvcmQgaW4gRGFydFxuICAgIGdsb2JhbCQxLmFzc2VydCA9IGZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24pIHtcbiAgICAgICAgLy8gVE9ETzogdG8gYmUgZml4ZWQgcHJvcGVybHkgdmlhICMyODMwLCBub29wIGZvciBub3dcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gb2JqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1ByZXNlbnQob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogIT0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBvYmpcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQmxhbmsob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogPT0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0b2tlblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RyaW5naWZ5KHRva2VuKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAnJyArIHRva2VuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbi5vdmVycmlkZGVuTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCIgKyB0b2tlbi5vdmVycmlkZGVuTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW4ubmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCIgKyB0b2tlbi5uYW1lO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlcyA9IHRva2VuLnRvU3RyaW5nKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5ld0xpbmVJbmRleCA9IHJlcy5pbmRleE9mKCdcXG4nKTtcbiAgICAgICAgcmV0dXJuIG5ld0xpbmVJbmRleCA9PT0gLTEgPyByZXMgOiByZXMuc3Vic3RyaW5nKDAsIG5ld0xpbmVJbmRleCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYVxuICAgICAqIEBwYXJhbSB7P30gYlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gbG9vc2VJZGVudGljYWwoYSwgYikge1xuICAgICAgICByZXR1cm4gYSA9PT0gYiB8fCB0eXBlb2YgYSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGIgPT09ICdudW1iZXInICYmIGlzTmFOKGEpICYmIGlzTmFOKGIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG9cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzSnNPYmplY3Qobykge1xuICAgICAgICByZXR1cm4gbyAhPT0gbnVsbCAmJiAodHlwZW9mIG8gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIG8gPT09ICdvYmplY3QnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBvYmpcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByaW50KG9iaikge1xuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tY29uc29sZVxuICAgICAgICBjb25zb2xlLmxvZyhvYmopO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG9ialxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gd2FybihvYmopIHtcbiAgICAgICAgY29uc29sZS53YXJuKG9iaik7XG4gICAgfVxuICAgIHZhciAvKiogQHR5cGUgez99ICovIF9zeW1ib2xJdGVyYXRvciA9IG51bGw7XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRTeW1ib2xJdGVyYXRvcigpIHtcbiAgICAgICAgaWYgKCFfc3ltYm9sSXRlcmF0b3IpIHtcbiAgICAgICAgICAgIGlmICgoKGdsb2JhbFNjb3BlKSkuU3ltYm9sICYmIFN5bWJvbC5pdGVyYXRvcikge1xuICAgICAgICAgICAgICAgIF9zeW1ib2xJdGVyYXRvciA9IFN5bWJvbC5pdGVyYXRvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGVzNi1zaGltIHNwZWNpZmljIGxvZ2ljXG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8ga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE1hcC5wcm90b3R5cGUpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgIT09ICdlbnRyaWVzJyAmJiBrZXkgIT09ICdzaXplJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKChNYXApKS5wcm90b3R5cGVba2V5XSA9PT0gTWFwLnByb3RvdHlwZVsnZW50cmllcyddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfc3ltYm9sSXRlcmF0b3IgPSBrZXk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9zeW1ib2xJdGVyYXRvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBvYmpcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUHJpbWl0aXZlKG9iaikge1xuICAgICAgICByZXR1cm4gIWlzSnNPYmplY3Qob2JqKTtcbiAgICB9XG5cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBfbmV4dENsYXNzSWQgPSAwO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIFJlZmxlY3QgPSBnbG9iYWwkMS5SZWZsZWN0O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYW5ub3RhdGlvblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gZXh0cmFjdEFubm90YXRpb24oYW5ub3RhdGlvbikge1xuICAgICAgICBpZiAodHlwZW9mIGFubm90YXRpb24gPT09ICdmdW5jdGlvbicgJiYgYW5ub3RhdGlvbi5oYXNPd25Qcm9wZXJ0eSgnYW5ub3RhdGlvbicpKSB7XG4gICAgICAgICAgICAvLyBpdCBpcyBhIGRlY29yYXRvciwgZXh0cmFjdCBhbm5vdGF0aW9uXG4gICAgICAgICAgICBhbm5vdGF0aW9uID0gYW5ub3RhdGlvbi5hbm5vdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbm5vdGF0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGZuT3JBcnJheVxuICAgICAqIEBwYXJhbSB7P30ga2V5XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcHBseVBhcmFtcyhmbk9yQXJyYXksIGtleSkge1xuICAgICAgICBpZiAoZm5PckFycmF5ID09PSBPYmplY3QgfHwgZm5PckFycmF5ID09PSBTdHJpbmcgfHwgZm5PckFycmF5ID09PSBGdW5jdGlvbiB8fFxuICAgICAgICAgICAgZm5PckFycmF5ID09PSBOdW1iZXIgfHwgZm5PckFycmF5ID09PSBBcnJheSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCB1c2UgbmF0aXZlIFwiICsgc3RyaW5naWZ5KGZuT3JBcnJheSkgKyBcIiBhcyBjb25zdHJ1Y3RvclwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGZuT3JBcnJheSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIGZuT3JBcnJheTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmbk9yQXJyYXkpKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhbm5vdGF0aW9ucyA9IGZuT3JBcnJheTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFubm9MZW5ndGggPSBhbm5vdGF0aW9ucy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZm4gPSBmbk9yQXJyYXlbYW5ub0xlbmd0aF07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTGFzdCBwb3NpdGlvbiBvZiBDbGFzcyBtZXRob2QgYXJyYXkgbXVzdCBiZSBGdW5jdGlvbiBpbiBrZXkgXCIgKyBrZXkgKyBcIiB3YXMgJ1wiICsgc3RyaW5naWZ5KGZuKSArIFwiJ1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbm5vTGVuZ3RoICE9IGZuLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk51bWJlciBvZiBhbm5vdGF0aW9ucyAoXCIgKyBhbm5vTGVuZ3RoICsgXCIpIGRvZXMgbm90IG1hdGNoIG51bWJlciBvZiBhcmd1bWVudHMgKFwiICsgZm4ubGVuZ3RoICsgXCIpIGluIHRoZSBmdW5jdGlvbjogXCIgKyBzdHJpbmdpZnkoZm4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcmFtc0Fubm90YXRpb25zID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwLCAvKiogQHR5cGUgez99ICovIGlpID0gYW5ub3RhdGlvbnMubGVuZ3RoIC0gMTsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJhbUFubm90YXRpb25zID0gW107XG4gICAgICAgICAgICAgICAgcGFyYW1zQW5ub3RhdGlvbnMucHVzaChwYXJhbUFubm90YXRpb25zKTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhbm5vdGF0aW9uID0gYW5ub3RhdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYW5ub3RhdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBqID0gMDsgaiA8IGFubm90YXRpb24ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtQW5ub3RhdGlvbnMucHVzaChleHRyYWN0QW5ub3RhdGlvbihhbm5vdGF0aW9uW2pdKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFubm90YXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1Bbm5vdGF0aW9ucy5wdXNoKGV4dHJhY3RBbm5vdGF0aW9uKGFubm90YXRpb24pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtQW5ub3RhdGlvbnMucHVzaChhbm5vdGF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSZWZsZWN0LmRlZmluZU1ldGFkYXRhKCdwYXJhbWV0ZXJzJywgcGFyYW1zQW5ub3RhdGlvbnMsIGZuKTtcbiAgICAgICAgICAgIHJldHVybiBmbjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IEZ1bmN0aW9uIG9yIEFycmF5IGlzIHN1cHBvcnRlZCBpbiBDbGFzcyBkZWZpbml0aW9uIGZvciBrZXkgJ1wiICsga2V5ICsgXCInIGlzICdcIiArIHN0cmluZ2lmeShmbk9yQXJyYXkpICsgXCInXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyBhIHdheSBmb3IgZXhwcmVzc2luZyBFUzYgY2xhc3NlcyB3aXRoIHBhcmFtZXRlciBhbm5vdGF0aW9ucyBpbiBFUzUuXG4gICAgICpcbiAgICAgKiAjIyBCYXNpYyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiB2YXIgR3JlZXRlciA9IG5nLkNsYXNzKHtcbiAgICAgKiAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICogICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICogICB9LFxuICAgICAqXG4gICAgICogICBncmVldDogZnVuY3Rpb24oKSB7XG4gICAgICogICAgIGFsZXJ0KCdIZWxsbyAnICsgdGhpcy5uYW1lICsgJyEnKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIGlzIGVxdWl2YWxlbnQgdG8gRVM2OlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogY2xhc3MgR3JlZXRlciB7XG4gICAgICogICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgICogICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICogICB9XG4gICAgICpcbiAgICAgKiAgIGdyZWV0KCkge1xuICAgICAqICAgICBhbGVydCgnSGVsbG8gJyArIHRoaXMubmFtZSArICchJyk7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogb3IgZXF1aXZhbGVudCB0byBFUzU6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiB2YXIgR3JlZXRlciA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICogICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEdyZWV0ZXIucHJvdG90eXBlLmdyZWV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAqICAgYWxlcnQoJ0hlbGxvICcgKyB0aGlzLm5hbWUgKyAnIScpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlIHdpdGggcGFyYW1ldGVyIGFubm90YXRpb25zXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiB2YXIgTXlTZXJ2aWNlID0gbmcuQ2xhc3Moe1xuICAgICAqICAgY29uc3RydWN0b3I6IFtTdHJpbmcsIFtuZXcgT3B0aW9uYWwoKSwgU2VydmljZV0sIGZ1bmN0aW9uKG5hbWUsIG15U2VydmljZSkge1xuICAgICAqICAgICAuLi5cbiAgICAgKiAgIH1dXG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBpcyBlcXVpdmFsZW50IHRvIEVTNjpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIGNsYXNzIE15U2VydmljZSB7XG4gICAgICogICBjb25zdHJ1Y3RvcihuYW1lOiBzdHJpbmcsIFxcQE9wdGlvbmFsKCkgbXlTZXJ2aWNlOiBTZXJ2aWNlKSB7XG4gICAgICogICAgIC4uLlxuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlIHdpdGggaW5oZXJpdGFuY2VcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIHZhciBTaGFwZSA9IG5nLkNsYXNzKHtcbiAgICAgKiAgIGNvbnN0cnVjdG9yOiAoY29sb3IpIHtcbiAgICAgKiAgICAgdGhpcy5jb2xvciA9IGNvbG9yO1xuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogdmFyIFNxdWFyZSA9IG5nLkNsYXNzKHtcbiAgICAgKiAgIGV4dGVuZHM6IFNoYXBlLFxuICAgICAqICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKGNvbG9yLCBzaXplKSB7XG4gICAgICogICAgIFNoYXBlLmNhbGwodGhpcywgY29sb3IpO1xuICAgICAqICAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqIFxcQHN0YWJsZVxuICAgICAqIEBwYXJhbSB7P30gY2xzRGVmXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDbGFzcyhjbHNEZWYpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29uc3RydWN0b3IgPSBhcHBseVBhcmFtcyhjbHNEZWYuaGFzT3duUHJvcGVydHkoJ2NvbnN0cnVjdG9yJykgPyBjbHNEZWYuY29uc3RydWN0b3IgOiB1bmRlZmluZWQsICdjb25zdHJ1Y3RvcicpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm90byA9IGNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgICAgICAgaWYgKGNsc0RlZi5oYXNPd25Qcm9wZXJ0eSgnZXh0ZW5kcycpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNsc0RlZi5leHRlbmRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgKChjb25zdHJ1Y3RvcikpLnByb3RvdHlwZSA9IHByb3RvID1cbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmNyZWF0ZSgoKGNsc0RlZi5leHRlbmRzKSkucHJvdG90eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNsYXNzIGRlZmluaXRpb24gJ2V4dGVuZHMnIHByb3BlcnR5IG11c3QgYmUgYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiB3YXM6IFwiICsgc3RyaW5naWZ5KGNsc0RlZi5leHRlbmRzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIga2V5IGluIGNsc0RlZikge1xuICAgICAgICAgICAgaWYgKGtleSAhPT0gJ2V4dGVuZHMnICYmIGtleSAhPT0gJ3Byb3RvdHlwZScgJiYgY2xzRGVmLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBwcm90b1trZXldID0gYXBwbHlQYXJhbXMoY2xzRGVmW2tleV0sIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMgJiYgdGhpcy5hbm5vdGF0aW9ucyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICBSZWZsZWN0LmRlZmluZU1ldGFkYXRhKCdhbm5vdGF0aW9ucycsIHRoaXMuYW5ub3RhdGlvbnMsIGNvbnN0cnVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb25zdHJ1Y3Rvck5hbWUgPSBjb25zdHJ1Y3RvclsnbmFtZSddO1xuICAgICAgICBpZiAoIWNvbnN0cnVjdG9yTmFtZSB8fCBjb25zdHJ1Y3Rvck5hbWUgPT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICAgICgoY29uc3RydWN0b3IpKVsnb3ZlcnJpZGRlbk5hbWUnXSA9IFwiY2xhc3NcIiArIF9uZXh0Q2xhc3NJZCsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoY29uc3RydWN0b3IpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IHByb3BzXG4gICAgICogQHBhcmFtIHs/PX0gcGFyZW50Q2xhc3NcbiAgICAgKiBAcGFyYW0gez89fSBjaGFpbkZuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYWtlRGVjb3JhdG9yKG5hbWUsIHByb3BzLCBwYXJlbnRDbGFzcywgY2hhaW5Gbikge1xuICAgICAgICBpZiAoY2hhaW5GbiA9PT0gdm9pZCAwKSB7IGNoYWluRm4gPSBudWxsOyB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1ldGFDdG9yID0gbWFrZU1ldGFkYXRhQ3RvcihbcHJvcHNdKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gb2JqT3JUeXBlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBEZWNvcmF0b3JGYWN0b3J5KG9iak9yVHlwZSkge1xuICAgICAgICAgICAgaWYgKCEoUmVmbGVjdCAmJiBSZWZsZWN0LmdldE93bk1ldGFkYXRhKSkge1xuICAgICAgICAgICAgICAgIHRocm93ICdyZWZsZWN0LW1ldGFkYXRhIHNoaW0gaXMgcmVxdWlyZWQgd2hlbiB1c2luZyBjbGFzcyBkZWNvcmF0b3JzJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgRGVjb3JhdG9yRmFjdG9yeSkge1xuICAgICAgICAgICAgICAgIG1ldGFDdG9yLmNhbGwodGhpcywgb2JqT3JUeXBlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFubm90YXRpb25JbnN0YW5jZSA9IG5ldyAoKERlY29yYXRvckZhY3RvcnkpKShvYmpPclR5cGUpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2hhaW5Bbm5vdGF0aW9uID0gdHlwZW9mIHRoaXMgPT09ICdmdW5jdGlvbicgJiYgQXJyYXkuaXNBcnJheSh0aGlzLmFubm90YXRpb25zKSA/IHRoaXMuYW5ub3RhdGlvbnMgOiBbXTtcbiAgICAgICAgICAgIGNoYWluQW5ub3RhdGlvbi5wdXNoKGFubm90YXRpb25JbnN0YW5jZSk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBUeXBlRGVjb3JhdG9yID0gKGZ1bmN0aW9uIFR5cGVEZWNvcmF0b3IoY2xzKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYW5ub3RhdGlvbnMgPSBSZWZsZWN0LmdldE93bk1ldGFkYXRhKCdhbm5vdGF0aW9ucycsIGNscykgfHwgW107XG4gICAgICAgICAgICAgICAgYW5ub3RhdGlvbnMucHVzaChhbm5vdGF0aW9uSW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEoJ2Fubm90YXRpb25zJywgYW5ub3RhdGlvbnMsIGNscyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNscztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgVHlwZURlY29yYXRvci5hbm5vdGF0aW9ucyA9IGNoYWluQW5ub3RhdGlvbjtcbiAgICAgICAgICAgIFR5cGVEZWNvcmF0b3IuQ2xhc3MgPSBDbGFzcztcbiAgICAgICAgICAgIGlmIChjaGFpbkZuKVxuICAgICAgICAgICAgICAgIGNoYWluRm4oVHlwZURlY29yYXRvcik7XG4gICAgICAgICAgICByZXR1cm4gVHlwZURlY29yYXRvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyZW50Q2xhc3MpIHtcbiAgICAgICAgICAgIERlY29yYXRvckZhY3RvcnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRDbGFzcy5wcm90b3R5cGUpO1xuICAgICAgICB9XG4gICAgICAgIERlY29yYXRvckZhY3RvcnkucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKFwiQFwiICsgbmFtZSk7IH07XG4gICAgICAgICgoRGVjb3JhdG9yRmFjdG9yeSkpLmFubm90YXRpb25DbHMgPSBEZWNvcmF0b3JGYWN0b3J5O1xuICAgICAgICByZXR1cm4gRGVjb3JhdG9yRmFjdG9yeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwcm9wc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFrZU1ldGFkYXRhQ3Rvcihwcm9wcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gY3RvcigpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvcHMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCwgaSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFyZ1ZhbCA9IGFyZ3NbaV07XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcGxhaW4gcGFyYW1ldGVyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzW3Byb3BbMF1dID0gYXJnVmFsID09PSB1bmRlZmluZWQgPyBwcm9wWzFdIDogYXJnVmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gcHJvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXNbcHJvcE5hbWVdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdWYWwgJiYgYXJnVmFsLmhhc093blByb3BlcnR5KHByb3BOYW1lKSA/IGFyZ1ZhbFtwcm9wTmFtZV0gOiBwcm9wW3Byb3BOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IHByb3BzXG4gICAgICogQHBhcmFtIHs/PX0gcGFyZW50Q2xhc3NcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1ha2VQYXJhbURlY29yYXRvcihuYW1lLCBwcm9wcywgcGFyZW50Q2xhc3MpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWV0YUN0b3IgPSBtYWtlTWV0YWRhdGFDdG9yKHByb3BzKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7Li4uP30gYXJnc1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gUGFyYW1EZWNvcmF0b3JGYWN0b3J5KCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgUGFyYW1EZWNvcmF0b3JGYWN0b3J5KSB7XG4gICAgICAgICAgICAgICAgbWV0YUN0b3IuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhbm5vdGF0aW9uSW5zdGFuY2UgPSBuZXcgKChfYSA9ICgoUGFyYW1EZWNvcmF0b3JGYWN0b3J5KSkpLmJpbmQuYXBwbHkoX2EsIFt2b2lkIDBdLmNvbmNhdChhcmdzKSkpKCk7XG4gICAgICAgICAgICAoKFBhcmFtRGVjb3JhdG9yKSkuYW5ub3RhdGlvbiA9IGFubm90YXRpb25JbnN0YW5jZTtcbiAgICAgICAgICAgIHJldHVybiBQYXJhbURlY29yYXRvcjtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBjbHNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gdW51c2VkS2V5XG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGluZGV4XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBQYXJhbURlY29yYXRvcihjbHMsIHVudXNlZEtleSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJhbWV0ZXJzID0gUmVmbGVjdC5nZXRPd25NZXRhZGF0YSgncGFyYW1ldGVycycsIGNscykgfHwgW107XG4gICAgICAgICAgICAgICAgLy8gdGhlcmUgbWlnaHQgYmUgZ2FwcyBpZiBzb21lIGluIGJldHdlZW4gcGFyYW1ldGVycyBkbyBub3QgaGF2ZSBhbm5vdGF0aW9ucy5cbiAgICAgICAgICAgICAgICAvLyB3ZSBwYWQgd2l0aCBudWxscy5cbiAgICAgICAgICAgICAgICB3aGlsZSAocGFyYW1ldGVycy5sZW5ndGggPD0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVycy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzW2luZGV4XSA9IHBhcmFtZXRlcnNbaW5kZXhdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnNbaW5kZXhdLnB1c2goYW5ub3RhdGlvbkluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICBSZWZsZWN0LmRlZmluZU1ldGFkYXRhKCdwYXJhbWV0ZXJzJywgcGFyYW1ldGVycywgY2xzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJlbnRDbGFzcykge1xuICAgICAgICAgICAgUGFyYW1EZWNvcmF0b3JGYWN0b3J5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUocGFyZW50Q2xhc3MucHJvdG90eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBQYXJhbURlY29yYXRvckZhY3RvcnkucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKFwiQFwiICsgbmFtZSk7IH07XG4gICAgICAgICgoUGFyYW1EZWNvcmF0b3JGYWN0b3J5KSkuYW5ub3RhdGlvbkNscyA9IFBhcmFtRGVjb3JhdG9yRmFjdG9yeTtcbiAgICAgICAgcmV0dXJuIFBhcmFtRGVjb3JhdG9yRmFjdG9yeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBwcm9wc1xuICAgICAqIEBwYXJhbSB7Pz19IHBhcmVudENsYXNzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYWtlUHJvcERlY29yYXRvcihuYW1lLCBwcm9wcywgcGFyZW50Q2xhc3MpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWV0YUN0b3IgPSBtYWtlTWV0YWRhdGFDdG9yKHByb3BzKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7Li4uP30gYXJnc1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gUHJvcERlY29yYXRvckZhY3RvcnkoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBQcm9wRGVjb3JhdG9yRmFjdG9yeSkge1xuICAgICAgICAgICAgICAgIG1ldGFDdG9yLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVjb3JhdG9ySW5zdGFuY2UgPSBuZXcgKChfYSA9ICgoUHJvcERlY29yYXRvckZhY3RvcnkpKSkuYmluZC5hcHBseShfYSwgW3ZvaWQgMF0uY29uY2F0KGFyZ3MpKSkoKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBQcm9wRGVjb3JhdG9yKHRhcmdldCwgbmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1ldGEgPSBSZWZsZWN0LmdldE93bk1ldGFkYXRhKCdwcm9wTWV0YWRhdGEnLCB0YXJnZXQuY29uc3RydWN0b3IpIHx8IHt9O1xuICAgICAgICAgICAgICAgIG1ldGFbbmFtZV0gPSBtZXRhLmhhc093blByb3BlcnR5KG5hbWUpICYmIG1ldGFbbmFtZV0gfHwgW107XG4gICAgICAgICAgICAgICAgbWV0YVtuYW1lXS51bnNoaWZ0KGRlY29yYXRvckluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICBSZWZsZWN0LmRlZmluZU1ldGFkYXRhKCdwcm9wTWV0YWRhdGEnLCBtZXRhLCB0YXJnZXQuY29uc3RydWN0b3IpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyZW50Q2xhc3MpIHtcbiAgICAgICAgICAgIFByb3BEZWNvcmF0b3JGYWN0b3J5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUocGFyZW50Q2xhc3MucHJvdG90eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBQcm9wRGVjb3JhdG9yRmFjdG9yeS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoXCJAXCIgKyBuYW1lKTsgfTtcbiAgICAgICAgKChQcm9wRGVjb3JhdG9yRmFjdG9yeSkpLmFubm90YXRpb25DbHMgPSBQcm9wRGVjb3JhdG9yRmFjdG9yeTtcbiAgICAgICAgcmV0dXJuIFByb3BEZWNvcmF0b3JGYWN0b3J5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluamVjdCBkZWNvcmF0b3IgYW5kIG1ldGFkYXRhLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqIEBBbm5vdGF0aW9uXG4gICAgICovXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gSW5qZWN0ID0gbWFrZVBhcmFtRGVjb3JhdG9yKCdJbmplY3QnLCBbWyd0b2tlbicsIHVuZGVmaW5lZF1dKTtcbiAgICAvKipcbiAgICAgKiBPcHRpb25hbCBkZWNvcmF0b3IgYW5kIG1ldGFkYXRhLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqIEBBbm5vdGF0aW9uXG4gICAgICovXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gT3B0aW9uYWwgPSBtYWtlUGFyYW1EZWNvcmF0b3IoJ09wdGlvbmFsJywgW10pO1xuICAgIC8qKlxuICAgICAqIEluamVjdGFibGUgZGVjb3JhdG9yIGFuZCBtZXRhZGF0YS5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKiBAQW5ub3RhdGlvblxuICAgICAqL1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIEluamVjdGFibGUgPSAobWFrZURlY29yYXRvcignSW5qZWN0YWJsZScsIFtdKSk7XG4gICAgLyoqXG4gICAgICogU2VsZiBkZWNvcmF0b3IgYW5kIG1ldGFkYXRhLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqIEBBbm5vdGF0aW9uXG4gICAgICovXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gU2VsZiA9IG1ha2VQYXJhbURlY29yYXRvcignU2VsZicsIFtdKTtcbiAgICAvKipcbiAgICAgKiBTa2lwU2VsZiBkZWNvcmF0b3IgYW5kIG1ldGFkYXRhLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqIEBBbm5vdGF0aW9uXG4gICAgICovXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gU2tpcFNlbGYgPSBtYWtlUGFyYW1EZWNvcmF0b3IoJ1NraXBTZWxmJywgW10pO1xuICAgIC8qKlxuICAgICAqIEhvc3QgZGVjb3JhdG9yIGFuZCBtZXRhZGF0YS5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKiBAQW5ub3RhdGlvblxuICAgICAqL1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIEhvc3QgPSBtYWtlUGFyYW1EZWNvcmF0b3IoJ0hvc3QnLCBbXSk7XG5cbiAgICB2YXIgT3BhcXVlVG9rZW4gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBfZGVzY1xuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gT3BhcXVlVG9rZW4oX2Rlc2MpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rlc2MgPSBfZGVzYztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIE9wYXF1ZVRva2VuLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiVG9rZW4gXCIgKyB0aGlzLl9kZXNjOyB9O1xuICAgICAgICBPcGFxdWVUb2tlbi5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBPcGFxdWVUb2tlbi5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgIF07IH07XG4gICAgICAgIHJldHVybiBPcGFxdWVUb2tlbjtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyB0b2tlbiBjYW4gYmUgdXNlZCB0byBjcmVhdGUgYSB2aXJ0dWFsIHByb3ZpZGVyIHRoYXQgd2lsbCBwb3B1bGF0ZSB0aGVcbiAgICAgKiBgZW50cnlDb21wb25lbnRzYCBmaWVsZHMgb2YgY29tcG9uZW50cyBhbmQgbmcgbW9kdWxlcyBiYXNlZCBvbiBpdHMgYHVzZVZhbHVlYC5cbiAgICAgKiBBbGwgY29tcG9uZW50cyB0aGF0IGFyZSByZWZlcmVuY2VkIGluIHRoZSBgdXNlVmFsdWVgIHZhbHVlIChlaXRoZXIgZGlyZWN0bHlcbiAgICAgKiBvciBpbiBhIG5lc3RlZCBhcnJheSBvciBtYXApIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGBlbnRyeUNvbXBvbmVudHNgIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVcbiAgICAgKiBUaGUgZm9sbG93aW5nIGV4YW1wbGUgc2hvd3MgaG93IHRoZSByb3V0ZXIgY2FuIHBvcHVsYXRlIHRoZSBgZW50cnlDb21wb25lbnRzYFxuICAgICAqIGZpZWxkIG9mIGFuIE5nTW9kdWxlIGJhc2VkIG9uIHRoZSByb3V0ZXIgY29uZmlndXJhdGlvbiB3aGljaCByZWZlcnNcbiAgICAgKiB0byBjb21wb25lbnRzLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIGhlbHBlciBmdW5jdGlvbiBpbnNpZGUgdGhlIHJvdXRlclxuICAgICAqIGZ1bmN0aW9uIHByb3ZpZGVSb3V0ZXMocm91dGVzKSB7XG4gICAgICogICByZXR1cm4gW1xuICAgICAqICAgICB7cHJvdmlkZTogUk9VVEVTLCB1c2VWYWx1ZTogcm91dGVzfSxcbiAgICAgKiAgICAge3Byb3ZpZGU6IEFOQUxZWkVfRk9SX0VOVFJZX0NPTVBPTkVOVFMsIHVzZVZhbHVlOiByb3V0ZXMsIG11bHRpOiB0cnVlfVxuICAgICAqICAgXTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiAvLyB1c2VyIGNvZGVcbiAgICAgKiBsZXQgcm91dGVzID0gW1xuICAgICAqICAge3BhdGg6ICcvcm9vdCcsIGNvbXBvbmVudDogUm9vdENvbXB9LFxuICAgICAqICAge3BhdGg6ICcvdGVhbXMnLCBjb21wb25lbnQ6IFRlYW1zQ29tcH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogQE5nTW9kdWxlKHtcbiAgICAgKiAgIHByb3ZpZGVyczogW3Byb3ZpZGVSb3V0ZXMocm91dGVzKV1cbiAgICAgKiB9KVxuICAgICAqIGNsYXNzIE1vZHVsZVdpdGhSb3V0ZXMge31cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBBTkFMWVpFX0ZPUl9FTlRSWV9DT01QT05FTlRTID0gbmV3IE9wYXF1ZVRva2VuKCdBbmFseXplRm9yRW50cnlDb21wb25lbnRzJyk7XG4gICAgLyoqXG4gICAgICogQXR0cmlidXRlIGRlY29yYXRvciBhbmQgbWV0YWRhdGEuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICogQEFubm90YXRpb25cbiAgICAgKi9cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBBdHRyaWJ1dGUgPSBtYWtlUGFyYW1EZWNvcmF0b3IoJ0F0dHJpYnV0ZScsIFtbJ2F0dHJpYnV0ZU5hbWUnLCB1bmRlZmluZWRdXSk7XG4gICAgLyoqXG4gICAgICogQmFzZSBjbGFzcyBmb3IgcXVlcnkgbWV0YWRhdGEuXG4gICAgICpcbiAgICAgKiBTZWUge1xcQGxpbmsgQ29udGVudENoaWxkcmVufSwge1xcQGxpbmsgQ29udGVudENoaWxkfSwge1xcQGxpbmsgVmlld0NoaWxkcmVufSwge1xcQGxpbmsgVmlld0NoaWxkfSBmb3JcbiAgICAgKiBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAqXG4gICAgICogXFxAc3RhYmxlXG4gICAgICogQGFic3RyYWN0XG4gICAgICovXG4gICAgdmFyIFF1ZXJ5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUXVlcnkoKSB7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFF1ZXJ5O1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogQ29udGVudENoaWxkcmVuIGRlY29yYXRvciBhbmQgbWV0YWRhdGEuXG4gICAgICpcbiAgICAgKiAgQHN0YWJsZVxuICAgICAqICBAQW5ub3RhdGlvblxuICAgICAqL1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIENvbnRlbnRDaGlsZHJlbiA9IChtYWtlUHJvcERlY29yYXRvcignQ29udGVudENoaWxkcmVuJywgW1xuICAgICAgICBbJ3NlbGVjdG9yJywgdW5kZWZpbmVkXSwge1xuICAgICAgICAgICAgZmlyc3Q6IGZhbHNlLFxuICAgICAgICAgICAgaXNWaWV3UXVlcnk6IGZhbHNlLFxuICAgICAgICAgICAgZGVzY2VuZGFudHM6IGZhbHNlLFxuICAgICAgICAgICAgcmVhZDogdW5kZWZpbmVkLFxuICAgICAgICB9XG4gICAgXSwgUXVlcnkpKTtcbiAgICAvKipcbiAgICAgKiBDb250ZW50Q2hpbGQgZGVjb3JhdG9yIGFuZCBtZXRhZGF0YS5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKiBAQW5ub3RhdGlvblxuICAgICAqL1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIENvbnRlbnRDaGlsZCA9IG1ha2VQcm9wRGVjb3JhdG9yKCdDb250ZW50Q2hpbGQnLCBbXG4gICAgICAgIFsnc2VsZWN0b3InLCB1bmRlZmluZWRdLCB7XG4gICAgICAgICAgICBmaXJzdDogdHJ1ZSxcbiAgICAgICAgICAgIGlzVmlld1F1ZXJ5OiBmYWxzZSxcbiAgICAgICAgICAgIGRlc2NlbmRhbnRzOiB0cnVlLFxuICAgICAgICAgICAgcmVhZDogdW5kZWZpbmVkLFxuICAgICAgICB9XG4gICAgXSwgUXVlcnkpO1xuICAgIC8qKlxuICAgICAqIFZpZXdDaGlsZHJlbiBkZWNvcmF0b3IgYW5kIG1ldGFkYXRhLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqIEBBbm5vdGF0aW9uXG4gICAgICovXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gVmlld0NoaWxkcmVuID0gbWFrZVByb3BEZWNvcmF0b3IoJ1ZpZXdDaGlsZHJlbicsIFtcbiAgICAgICAgWydzZWxlY3RvcicsIHVuZGVmaW5lZF0sIHtcbiAgICAgICAgICAgIGZpcnN0OiBmYWxzZSxcbiAgICAgICAgICAgIGlzVmlld1F1ZXJ5OiB0cnVlLFxuICAgICAgICAgICAgZGVzY2VuZGFudHM6IHRydWUsXG4gICAgICAgICAgICByZWFkOiB1bmRlZmluZWQsXG4gICAgICAgIH1cbiAgICBdLCBRdWVyeSk7XG4gICAgLyoqXG4gICAgICogVmlld0NoaWxkIGRlY29yYXRvciBhbmQgbWV0YWRhdGEuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICogQEFubm90YXRpb25cbiAgICAgKi9cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBWaWV3Q2hpbGQgPSBtYWtlUHJvcERlY29yYXRvcignVmlld0NoaWxkJywgW1xuICAgICAgICBbJ3NlbGVjdG9yJywgdW5kZWZpbmVkXSwge1xuICAgICAgICAgICAgZmlyc3Q6IHRydWUsXG4gICAgICAgICAgICBpc1ZpZXdRdWVyeTogdHJ1ZSxcbiAgICAgICAgICAgIGRlc2NlbmRhbnRzOiB0cnVlLFxuICAgICAgICAgICAgcmVhZDogdW5kZWZpbmVkLFxuICAgICAgICB9XG4gICAgXSwgUXVlcnkpO1xuXG4gICAgdmFyIENoYW5nZURldGVjdGlvblN0cmF0ZWd5ID0ge307XG4gICAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoID0gMDtcbiAgICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5EZWZhdWx0ID0gMTtcbiAgICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneVtDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hdID0gXCJPblB1c2hcIjtcbiAgICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneVtDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5EZWZhdWx0XSA9IFwiRGVmYXVsdFwiO1xuICAgIHZhciBDaGFuZ2VEZXRlY3RvclN0YXR1cyA9IHt9O1xuICAgIENoYW5nZURldGVjdG9yU3RhdHVzLkNoZWNrT25jZSA9IDA7XG4gICAgQ2hhbmdlRGV0ZWN0b3JTdGF0dXMuQ2hlY2tlZCA9IDE7XG4gICAgQ2hhbmdlRGV0ZWN0b3JTdGF0dXMuQ2hlY2tBbHdheXMgPSAyO1xuICAgIENoYW5nZURldGVjdG9yU3RhdHVzLkRldGFjaGVkID0gMztcbiAgICBDaGFuZ2VEZXRlY3RvclN0YXR1cy5FcnJvcmVkID0gNDtcbiAgICBDaGFuZ2VEZXRlY3RvclN0YXR1cy5EZXN0cm95ZWQgPSA1O1xuICAgIENoYW5nZURldGVjdG9yU3RhdHVzW0NoYW5nZURldGVjdG9yU3RhdHVzLkNoZWNrT25jZV0gPSBcIkNoZWNrT25jZVwiO1xuICAgIENoYW5nZURldGVjdG9yU3RhdHVzW0NoYW5nZURldGVjdG9yU3RhdHVzLkNoZWNrZWRdID0gXCJDaGVja2VkXCI7XG4gICAgQ2hhbmdlRGV0ZWN0b3JTdGF0dXNbQ2hhbmdlRGV0ZWN0b3JTdGF0dXMuQ2hlY2tBbHdheXNdID0gXCJDaGVja0Fsd2F5c1wiO1xuICAgIENoYW5nZURldGVjdG9yU3RhdHVzW0NoYW5nZURldGVjdG9yU3RhdHVzLkRldGFjaGVkXSA9IFwiRGV0YWNoZWRcIjtcbiAgICBDaGFuZ2VEZXRlY3RvclN0YXR1c1tDaGFuZ2VEZXRlY3RvclN0YXR1cy5FcnJvcmVkXSA9IFwiRXJyb3JlZFwiO1xuICAgIENoYW5nZURldGVjdG9yU3RhdHVzW0NoYW5nZURldGVjdG9yU3RhdHVzLkRlc3Ryb3llZF0gPSBcIkRlc3Ryb3llZFwiO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3lcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRGVmYXVsdENoYW5nZURldGVjdGlvblN0cmF0ZWd5KGNoYW5nZURldGVjdGlvblN0cmF0ZWd5KSB7XG4gICAgICAgIHJldHVybiBpc0JsYW5rKGNoYW5nZURldGVjdGlvblN0cmF0ZWd5KSB8fFxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgPT09IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LkRlZmF1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGlyZWN0aXZlIGRlY29yYXRvciBhbmQgbWV0YWRhdGEuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICogQEFubm90YXRpb25cbiAgICAgKi9cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBEaXJlY3RpdmUgPSAobWFrZURlY29yYXRvcignRGlyZWN0aXZlJywge1xuICAgICAgICBzZWxlY3RvcjogdW5kZWZpbmVkLFxuICAgICAgICBpbnB1dHM6IHVuZGVmaW5lZCxcbiAgICAgICAgb3V0cHV0czogdW5kZWZpbmVkLFxuICAgICAgICBob3N0OiB1bmRlZmluZWQsXG4gICAgICAgIHByb3ZpZGVyczogdW5kZWZpbmVkLFxuICAgICAgICBleHBvcnRBczogdW5kZWZpbmVkLFxuICAgICAgICBxdWVyaWVzOiB1bmRlZmluZWRcbiAgICB9KSk7XG4gICAgLyoqXG4gICAgICogQ29tcG9uZW50IGRlY29yYXRvciBhbmQgbWV0YWRhdGEuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICogQEFubm90YXRpb25cbiAgICAgKi9cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBDb21wb25lbnQgPSAobWFrZURlY29yYXRvcignQ29tcG9uZW50Jywge1xuICAgICAgICBzZWxlY3RvcjogdW5kZWZpbmVkLFxuICAgICAgICBpbnB1dHM6IHVuZGVmaW5lZCxcbiAgICAgICAgb3V0cHV0czogdW5kZWZpbmVkLFxuICAgICAgICBob3N0OiB1bmRlZmluZWQsXG4gICAgICAgIGV4cG9ydEFzOiB1bmRlZmluZWQsXG4gICAgICAgIG1vZHVsZUlkOiB1bmRlZmluZWQsXG4gICAgICAgIHByb3ZpZGVyczogdW5kZWZpbmVkLFxuICAgICAgICB2aWV3UHJvdmlkZXJzOiB1bmRlZmluZWQsXG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuRGVmYXVsdCxcbiAgICAgICAgcXVlcmllczogdW5kZWZpbmVkLFxuICAgICAgICB0ZW1wbGF0ZVVybDogdW5kZWZpbmVkLFxuICAgICAgICB0ZW1wbGF0ZTogdW5kZWZpbmVkLFxuICAgICAgICBzdHlsZVVybHM6IHVuZGVmaW5lZCxcbiAgICAgICAgc3R5bGVzOiB1bmRlZmluZWQsXG4gICAgICAgIGFuaW1hdGlvbnM6IHVuZGVmaW5lZCxcbiAgICAgICAgZW5jYXBzdWxhdGlvbjogdW5kZWZpbmVkLFxuICAgICAgICBpbnRlcnBvbGF0aW9uOiB1bmRlZmluZWQsXG4gICAgICAgIGVudHJ5Q29tcG9uZW50czogdW5kZWZpbmVkXG4gICAgfSwgRGlyZWN0aXZlKSk7XG4gICAgLyoqXG4gICAgICogUGlwZSBkZWNvcmF0b3IgYW5kIG1ldGFkYXRhLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqIEBBbm5vdGF0aW9uXG4gICAgICovXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gUGlwZSA9IChtYWtlRGVjb3JhdG9yKCdQaXBlJywge1xuICAgICAgICBuYW1lOiB1bmRlZmluZWQsXG4gICAgICAgIHB1cmU6IHRydWUsXG4gICAgfSkpO1xuICAgIC8qKlxuICAgICAqIElucHV0IGRlY29yYXRvciBhbmQgbWV0YWRhdGEuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICogQEFubm90YXRpb25cbiAgICAgKi9cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBJbnB1dCA9IG1ha2VQcm9wRGVjb3JhdG9yKCdJbnB1dCcsIFtbJ2JpbmRpbmdQcm9wZXJ0eU5hbWUnLCB1bmRlZmluZWRdXSk7XG4gICAgLyoqXG4gICAgICogT3V0cHV0IGRlY29yYXRvciBhbmQgbWV0YWRhdGEuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICogQEFubm90YXRpb25cbiAgICAgKi9cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBPdXRwdXQgPSBtYWtlUHJvcERlY29yYXRvcignT3V0cHV0JywgW1snYmluZGluZ1Byb3BlcnR5TmFtZScsIHVuZGVmaW5lZF1dKTtcbiAgICAvKipcbiAgICAgKiBIb3N0QmluZGluZyBkZWNvcmF0b3IgYW5kIG1ldGFkYXRhLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqIEBBbm5vdGF0aW9uXG4gICAgICovXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gSG9zdEJpbmRpbmcgPSBtYWtlUHJvcERlY29yYXRvcignSG9zdEJpbmRpbmcnLCBbWydob3N0UHJvcGVydHlOYW1lJywgdW5kZWZpbmVkXV0pO1xuICAgIC8qKlxuICAgICAqIEhvc3RMaXN0ZW5lciBkZWNvcmF0b3IgYW5kIG1ldGFkYXRhLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqIEBBbm5vdGF0aW9uXG4gICAgICovXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gSG9zdExpc3RlbmVyID0gbWFrZVByb3BEZWNvcmF0b3IoJ0hvc3RMaXN0ZW5lcicsIFtbJ2V2ZW50TmFtZScsIHVuZGVmaW5lZF0sIFsnYXJncycsIFtdXV0pO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBMaWZlY3ljbGVIb29rcyA9IHt9O1xuICAgIExpZmVjeWNsZUhvb2tzLk9uSW5pdCA9IDA7XG4gICAgTGlmZWN5Y2xlSG9va3MuT25EZXN0cm95ID0gMTtcbiAgICBMaWZlY3ljbGVIb29rcy5Eb0NoZWNrID0gMjtcbiAgICBMaWZlY3ljbGVIb29rcy5PbkNoYW5nZXMgPSAzO1xuICAgIExpZmVjeWNsZUhvb2tzLkFmdGVyQ29udGVudEluaXQgPSA0O1xuICAgIExpZmVjeWNsZUhvb2tzLkFmdGVyQ29udGVudENoZWNrZWQgPSA1O1xuICAgIExpZmVjeWNsZUhvb2tzLkFmdGVyVmlld0luaXQgPSA2O1xuICAgIExpZmVjeWNsZUhvb2tzLkFmdGVyVmlld0NoZWNrZWQgPSA3O1xuICAgIExpZmVjeWNsZUhvb2tzW0xpZmVjeWNsZUhvb2tzLk9uSW5pdF0gPSBcIk9uSW5pdFwiO1xuICAgIExpZmVjeWNsZUhvb2tzW0xpZmVjeWNsZUhvb2tzLk9uRGVzdHJveV0gPSBcIk9uRGVzdHJveVwiO1xuICAgIExpZmVjeWNsZUhvb2tzW0xpZmVjeWNsZUhvb2tzLkRvQ2hlY2tdID0gXCJEb0NoZWNrXCI7XG4gICAgTGlmZWN5Y2xlSG9va3NbTGlmZWN5Y2xlSG9va3MuT25DaGFuZ2VzXSA9IFwiT25DaGFuZ2VzXCI7XG4gICAgTGlmZWN5Y2xlSG9va3NbTGlmZWN5Y2xlSG9va3MuQWZ0ZXJDb250ZW50SW5pdF0gPSBcIkFmdGVyQ29udGVudEluaXRcIjtcbiAgICBMaWZlY3ljbGVIb29rc1tMaWZlY3ljbGVIb29rcy5BZnRlckNvbnRlbnRDaGVja2VkXSA9IFwiQWZ0ZXJDb250ZW50Q2hlY2tlZFwiO1xuICAgIExpZmVjeWNsZUhvb2tzW0xpZmVjeWNsZUhvb2tzLkFmdGVyVmlld0luaXRdID0gXCJBZnRlclZpZXdJbml0XCI7XG4gICAgTGlmZWN5Y2xlSG9va3NbTGlmZWN5Y2xlSG9va3MuQWZ0ZXJWaWV3Q2hlY2tlZF0gPSBcIkFmdGVyVmlld0NoZWNrZWRcIjtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBMSUZFQ1lDTEVfSE9PS1NfVkFMVUVTID0gW1xuICAgICAgICBMaWZlY3ljbGVIb29rcy5PbkluaXQsIExpZmVjeWNsZUhvb2tzLk9uRGVzdHJveSwgTGlmZWN5Y2xlSG9va3MuRG9DaGVjaywgTGlmZWN5Y2xlSG9va3MuT25DaGFuZ2VzLFxuICAgICAgICBMaWZlY3ljbGVIb29rcy5BZnRlckNvbnRlbnRJbml0LCBMaWZlY3ljbGVIb29rcy5BZnRlckNvbnRlbnRDaGVja2VkLCBMaWZlY3ljbGVIb29rcy5BZnRlclZpZXdJbml0LFxuICAgICAgICBMaWZlY3ljbGVIb29rcy5BZnRlclZpZXdDaGVja2VkXG4gICAgXTtcbiAgICAvKipcbiAgICAgKiBcXEB3aGF0SXREb2VzIExpZmVjeWNsZSBob29rIHRoYXQgaXMgY2FsbGVkIHdoZW4gYW55IGRhdGEtYm91bmQgcHJvcGVydHkgb2YgYSBkaXJlY3RpdmUgY2hhbmdlcy5cbiAgICAgKiBcXEBob3dUb1VzZVxuICAgICAqIHtcXEBleGFtcGxlIGNvcmUvdHMvbWV0YWRhdGEvbGlmZWN5Y2xlX2hvb2tzX3NwZWMudHMgcmVnaW9uPSdPbkNoYW5nZXMnfVxuICAgICAqXG4gICAgICogXFxAZGVzY3JpcHRpb25cbiAgICAgKiBgbmdPbkNoYW5nZXNgIGlzIGNhbGxlZCByaWdodCBhZnRlciB0aGUgZGF0YS1ib3VuZCBwcm9wZXJ0aWVzIGhhdmUgYmVlbiBjaGVja2VkIGFuZCBiZWZvcmUgdmlld1xuICAgICAqIGFuZCBjb250ZW50IGNoaWxkcmVuIGFyZSBjaGVja2VkIGlmIGF0IGxlYXN0IG9uZSBvZiB0aGVtIGhhcyBjaGFuZ2VkLlxuICAgICAqIFRoZSBgY2hhbmdlc2AgcGFyYW1ldGVyIGNvbnRhaW5zIHRoZSBjaGFuZ2VkIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBTZWUge1xcQGxpbmtEb2NzIGd1aWRlL2xpZmVjeWNsZS1ob29rcyNvbmNoYW5nZXMgXCJMaWZlY3ljbGUgSG9va3MgR3VpZGVcIn0uXG4gICAgICpcbiAgICAgKiBcXEBzdGFibGVcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICB2YXIgT25DaGFuZ2VzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gT25DaGFuZ2VzKCkge1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAYWJzdHJhY3RcbiAgICAgICAgICogQHBhcmFtIHs/fSBjaGFuZ2VzXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBPbkNoYW5nZXMucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHsgfTtcbiAgICAgICAgcmV0dXJuIE9uQ2hhbmdlcztcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIFxcQHdoYXRJdERvZXMgTGlmZWN5Y2xlIGhvb2sgdGhhdCBpcyBjYWxsZWQgYWZ0ZXIgZGF0YS1ib3VuZCBwcm9wZXJ0aWVzIG9mIGEgZGlyZWN0aXZlIGFyZVxuICAgICAqIGluaXRpYWxpemVkLlxuICAgICAqIFxcQGhvd1RvVXNlXG4gICAgICoge1xcQGV4YW1wbGUgY29yZS90cy9tZXRhZGF0YS9saWZlY3ljbGVfaG9va3Nfc3BlYy50cyByZWdpb249J09uSW5pdCd9XG4gICAgICpcbiAgICAgKiBcXEBkZXNjcmlwdGlvblxuICAgICAqIGBuZ09uSW5pdGAgaXMgY2FsbGVkIHJpZ2h0IGFmdGVyIHRoZSBkaXJlY3RpdmUncyBkYXRhLWJvdW5kIHByb3BlcnRpZXMgaGF2ZSBiZWVuIGNoZWNrZWQgZm9yIHRoZVxuICAgICAqIGZpcnN0IHRpbWUsIGFuZCBiZWZvcmUgYW55IG9mIGl0cyBjaGlsZHJlbiBoYXZlIGJlZW4gY2hlY2tlZC4gSXQgaXMgaW52b2tlZCBvbmx5IG9uY2Ugd2hlbiB0aGVcbiAgICAgKiBkaXJlY3RpdmUgaXMgaW5zdGFudGlhdGVkLlxuICAgICAqXG4gICAgICogU2VlIHtcXEBsaW5rRG9jcyBndWlkZS9saWZlY3ljbGUtaG9va3MgXCJMaWZlY3ljbGUgSG9va3MgR3VpZGVcIn0uXG4gICAgICpcbiAgICAgKiBcXEBzdGFibGVcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICB2YXIgT25Jbml0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gT25Jbml0KCkge1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAYWJzdHJhY3RcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIE9uSW5pdC5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIHJldHVybiBPbkluaXQ7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBcXEB3aGF0SXREb2VzIExpZmVjeWNsZSBob29rIHRoYXQgaXMgY2FsbGVkIHdoZW4gQW5ndWxhciBkaXJ0eSBjaGVja3MgYSBkaXJlY3RpdmUuXG4gICAgICogXFxAaG93VG9Vc2VcbiAgICAgKiB7XFxAZXhhbXBsZSBjb3JlL3RzL21ldGFkYXRhL2xpZmVjeWNsZV9ob29rc19zcGVjLnRzIHJlZ2lvbj0nRG9DaGVjayd9XG4gICAgICpcbiAgICAgKiBcXEBkZXNjcmlwdGlvblxuICAgICAqIGBuZ0RvQ2hlY2tgIGdldHMgY2FsbGVkIHRvIGNoZWNrIHRoZSBjaGFuZ2VzIGluIHRoZSBkaXJlY3RpdmVzIGluIGFkZGl0aW9uIHRvIHRoZSBkZWZhdWx0XG4gICAgICogYWxnb3JpdGhtLiBUaGUgZGVmYXVsdCBjaGFuZ2UgZGV0ZWN0aW9uIGFsZ29yaXRobSBsb29rcyBmb3IgZGlmZmVyZW5jZXMgYnkgY29tcGFyaW5nXG4gICAgICogYm91bmQtcHJvcGVydHkgdmFsdWVzIGJ5IHJlZmVyZW5jZSBhY3Jvc3MgY2hhbmdlIGRldGVjdGlvbiBydW5zLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IGEgZGlyZWN0aXZlIHR5cGljYWxseSBzaG91bGQgbm90IHVzZSBib3RoIGBEb0NoZWNrYCBhbmQge1xcQGxpbmsgT25DaGFuZ2VzfSB0byByZXNwb25kIHRvXG4gICAgICogY2hhbmdlcyBvbiB0aGUgc2FtZSBpbnB1dCwgYXMgYG5nT25DaGFuZ2VzYCB3aWxsIGNvbnRpbnVlIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBkZWZhdWx0IGNoYW5nZVxuICAgICAqIGRldGVjdG9yIGRldGVjdHMgY2hhbmdlcy5cbiAgICAgKlxuICAgICAqIFNlZSB7XFxAbGluayBLZXlWYWx1ZURpZmZlcnN9IGFuZCB7XFxAbGluayBJdGVyYWJsZURpZmZlcnN9IGZvciBpbXBsZW1lbnRpbmcgY3VzdG9tIGRpcnR5IGNoZWNraW5nXG4gICAgICogZm9yIGNvbGxlY3Rpb25zLlxuICAgICAqXG4gICAgICogU2VlIHtcXEBsaW5rRG9jcyBndWlkZS9saWZlY3ljbGUtaG9va3MjZG9jaGVjayBcIkxpZmVjeWNsZSBIb29rcyBHdWlkZVwifS5cbiAgICAgKlxuICAgICAqIFxcQHN0YWJsZVxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICAgIHZhciBEb0NoZWNrID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRG9DaGVjaygpIHtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBEb0NoZWNrLnByb3RvdHlwZS5uZ0RvQ2hlY2sgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIHJldHVybiBEb0NoZWNrO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogXFxAd2hhdEl0RG9lcyBMaWZlY3ljbGUgaG9vayB0aGF0IGlzIGNhbGxlZCB3aGVuIGEgZGlyZWN0aXZlLCBwaXBlIG9yIHNlcnZpY2UgaXMgZGVzdHJveWVkLlxuICAgICAqIFxcQGhvd1RvVXNlXG4gICAgICoge1xcQGV4YW1wbGUgY29yZS90cy9tZXRhZGF0YS9saWZlY3ljbGVfaG9va3Nfc3BlYy50cyByZWdpb249J09uRGVzdHJveSd9XG4gICAgICpcbiAgICAgKiBcXEBkZXNjcmlwdGlvblxuICAgICAqIGBuZ09uRGVzdHJveWAgY2FsbGJhY2sgaXMgdHlwaWNhbGx5IHVzZWQgZm9yIGFueSBjdXN0b20gY2xlYW51cCB0aGF0IG5lZWRzIHRvIG9jY3VyIHdoZW4gdGhlXG4gICAgICogaW5zdGFuY2UgaXMgZGVzdHJveWVkLlxuICAgICAqXG4gICAgICogU2VlIHtcXEBsaW5rRG9jcyBndWlkZS9saWZlY3ljbGUtaG9va3MgXCJMaWZlY3ljbGUgSG9va3MgR3VpZGVcIn0uXG4gICAgICpcbiAgICAgKiBcXEBzdGFibGVcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICB2YXIgT25EZXN0cm95ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gT25EZXN0cm95KCkge1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAYWJzdHJhY3RcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIE9uRGVzdHJveS5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIHJldHVybiBPbkRlc3Ryb3k7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIFxcQHdoYXRJdERvZXMgTGlmZWN5Y2xlIGhvb2sgdGhhdCBpcyBjYWxsZWQgYWZ0ZXIgYSBkaXJlY3RpdmUncyBjb250ZW50IGhhcyBiZWVuIGZ1bGx5XG4gICAgICogaW5pdGlhbGl6ZWQuXG4gICAgICogXFxAaG93VG9Vc2VcbiAgICAgKiB7XFxAZXhhbXBsZSBjb3JlL3RzL21ldGFkYXRhL2xpZmVjeWNsZV9ob29rc19zcGVjLnRzIHJlZ2lvbj0nQWZ0ZXJDb250ZW50SW5pdCd9XG4gICAgICpcbiAgICAgKiBcXEBkZXNjcmlwdGlvblxuICAgICAqIFNlZSB7XFxAbGlua0RvY3MgZ3VpZGUvbGlmZWN5Y2xlLWhvb2tzI2FmdGVyY29udGVudCBcIkxpZmVjeWNsZSBIb29rcyBHdWlkZVwifS5cbiAgICAgKlxuICAgICAqIFxcQHN0YWJsZVxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICAgIHZhciBBZnRlckNvbnRlbnRJbml0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBZnRlckNvbnRlbnRJbml0LnByb3RvdHlwZS5uZ0FmdGVyQ29udGVudEluaXQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIHJldHVybiBBZnRlckNvbnRlbnRJbml0O1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogXFxAd2hhdEl0RG9lcyBMaWZlY3ljbGUgaG9vayB0aGF0IGlzIGNhbGxlZCBhZnRlciBldmVyeSBjaGVjayBvZiBhIGRpcmVjdGl2ZSdzIGNvbnRlbnQuXG4gICAgICogXFxAaG93VG9Vc2VcbiAgICAgKiB7XFxAZXhhbXBsZSBjb3JlL3RzL21ldGFkYXRhL2xpZmVjeWNsZV9ob29rc19zcGVjLnRzIHJlZ2lvbj0nQWZ0ZXJDb250ZW50Q2hlY2tlZCd9XG4gICAgICpcbiAgICAgKiBcXEBkZXNjcmlwdGlvblxuICAgICAqIFNlZSB7XFxAbGlua0RvY3MgZ3VpZGUvbGlmZWN5Y2xlLWhvb2tzI2FmdGVyY29udGVudCBcIkxpZmVjeWNsZSBIb29rcyBHdWlkZVwifS5cbiAgICAgKlxuICAgICAqIFxcQHN0YWJsZVxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICAgIHZhciBBZnRlckNvbnRlbnRDaGVja2VkID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQWZ0ZXJDb250ZW50Q2hlY2tlZCgpIHtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBZnRlckNvbnRlbnRDaGVja2VkLnByb3RvdHlwZS5uZ0FmdGVyQ29udGVudENoZWNrZWQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIHJldHVybiBBZnRlckNvbnRlbnRDaGVja2VkO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogXFxAd2hhdEl0RG9lcyBMaWZlY3ljbGUgaG9vayB0aGF0IGlzIGNhbGxlZCBhZnRlciBhIGNvbXBvbmVudCdzIHZpZXcgaGFzIGJlZW4gZnVsbHlcbiAgICAgKiBpbml0aWFsaXplZC5cbiAgICAgKiBcXEBob3dUb1VzZVxuICAgICAqIHtcXEBleGFtcGxlIGNvcmUvdHMvbWV0YWRhdGEvbGlmZWN5Y2xlX2hvb2tzX3NwZWMudHMgcmVnaW9uPSdBZnRlclZpZXdJbml0J31cbiAgICAgKlxuICAgICAqIFxcQGRlc2NyaXB0aW9uXG4gICAgICogU2VlIHtcXEBsaW5rRG9jcyBndWlkZS9saWZlY3ljbGUtaG9va3MjYWZ0ZXJ2aWV3IFwiTGlmZWN5Y2xlIEhvb2tzIEd1aWRlXCJ9LlxuICAgICAqXG4gICAgICogXFxAc3RhYmxlXG4gICAgICogQGFic3RyYWN0XG4gICAgICovXG4gICAgdmFyIEFmdGVyVmlld0luaXQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBBZnRlclZpZXdJbml0KCkge1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAYWJzdHJhY3RcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEFmdGVyVmlld0luaXQucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgcmV0dXJuIEFmdGVyVmlld0luaXQ7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBcXEB3aGF0SXREb2VzIExpZmVjeWNsZSBob29rIHRoYXQgaXMgY2FsbGVkIGFmdGVyIGV2ZXJ5IGNoZWNrIG9mIGEgY29tcG9uZW50J3Mgdmlldy5cbiAgICAgKiBcXEBob3dUb1VzZVxuICAgICAqIHtcXEBleGFtcGxlIGNvcmUvdHMvbWV0YWRhdGEvbGlmZWN5Y2xlX2hvb2tzX3NwZWMudHMgcmVnaW9uPSdBZnRlclZpZXdDaGVja2VkJ31cbiAgICAgKlxuICAgICAqIFxcQGRlc2NyaXB0aW9uXG4gICAgICogU2VlIHtcXEBsaW5rRG9jcyBndWlkZS9saWZlY3ljbGUtaG9va3MjYWZ0ZXJ2aWV3IFwiTGlmZWN5Y2xlIEhvb2tzIEd1aWRlXCJ9LlxuICAgICAqXG4gICAgICogXFxAc3RhYmxlXG4gICAgICogQGFic3RyYWN0XG4gICAgICovXG4gICAgdmFyIEFmdGVyVmlld0NoZWNrZWQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBBZnRlclZpZXdDaGVja2VkKCkge1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAYWJzdHJhY3RcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEFmdGVyVmlld0NoZWNrZWQucHJvdG90eXBlLm5nQWZ0ZXJWaWV3Q2hlY2tlZCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgcmV0dXJuIEFmdGVyVmlld0NoZWNrZWQ7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIERlZmluZXMgYSBzY2hlbWEgdGhhdCB3aWxsIGFsbG93OlxuICAgICAqIC0gYW55IG5vbi1Bbmd1bGFyIGVsZW1lbnRzIHdpdGggYSBgLWAgaW4gdGhlaXIgbmFtZSxcbiAgICAgKiAtIGFueSBwcm9wZXJ0aWVzIG9uIGVsZW1lbnRzIHdpdGggYSBgLWAgaW4gdGhlaXIgbmFtZSB3aGljaCBpcyB0aGUgY29tbW9uIHJ1bGUgZm9yIGN1c3RvbVxuICAgICAqIGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIENVU1RPTV9FTEVNRU5UU19TQ0hFTUEgPSB7XG4gICAgICAgIG5hbWU6ICdjdXN0b20tZWxlbWVudHMnXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIGEgc2NoZW1hIHRoYXQgd2lsbCBhbGxvdyBhbnkgcHJvcGVydHkgb24gYW55IGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gTk9fRVJST1JTX1NDSEVNQSA9IHtcbiAgICAgICAgbmFtZTogJ25vLWVycm9ycy1zY2hlbWEnXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBOZ01vZHVsZSBkZWNvcmF0b3IgYW5kIG1ldGFkYXRhLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqIEBBbm5vdGF0aW9uXG4gICAgICovXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gTmdNb2R1bGUgPSAobWFrZURlY29yYXRvcignTmdNb2R1bGUnLCB7XG4gICAgICAgIHByb3ZpZGVyczogdW5kZWZpbmVkLFxuICAgICAgICBkZWNsYXJhdGlvbnM6IHVuZGVmaW5lZCxcbiAgICAgICAgaW1wb3J0czogdW5kZWZpbmVkLFxuICAgICAgICBleHBvcnRzOiB1bmRlZmluZWQsXG4gICAgICAgIGVudHJ5Q29tcG9uZW50czogdW5kZWZpbmVkLFxuICAgICAgICBib290c3RyYXA6IHVuZGVmaW5lZCxcbiAgICAgICAgc2NoZW1hczogdW5kZWZpbmVkLFxuICAgICAgICBpZDogdW5kZWZpbmVkLFxuICAgIH0pKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgVmlld0VuY2Fwc3VsYXRpb24gPSB7fTtcbiAgICBWaWV3RW5jYXBzdWxhdGlvbi5FbXVsYXRlZCA9IDA7XG4gICAgVmlld0VuY2Fwc3VsYXRpb24uTmF0aXZlID0gMTtcbiAgICBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lID0gMjtcbiAgICBWaWV3RW5jYXBzdWxhdGlvbltWaWV3RW5jYXBzdWxhdGlvbi5FbXVsYXRlZF0gPSBcIkVtdWxhdGVkXCI7XG4gICAgVmlld0VuY2Fwc3VsYXRpb25bVmlld0VuY2Fwc3VsYXRpb24uTmF0aXZlXSA9IFwiTmF0aXZlXCI7XG4gICAgVmlld0VuY2Fwc3VsYXRpb25bVmlld0VuY2Fwc3VsYXRpb24uTm9uZV0gPSBcIk5vbmVcIjtcbiAgICAvKipcbiAgICAgKiBNZXRhZGF0YSBwcm9wZXJ0aWVzIGF2YWlsYWJsZSBmb3IgY29uZmlndXJpbmcgVmlld3MuXG4gICAgICpcbiAgICAgKiBGb3IgZGV0YWlscyBvbiB0aGUgYFxcQENvbXBvbmVudGAgYW5ub3RhdGlvbiwgc2VlIHtcXEBsaW5rIENvbXBvbmVudH0uXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogXFxAQ29tcG9uZW50KHtcbiAgICAgKiAgIHNlbGVjdG9yOiAnZ3JlZXQnLFxuICAgICAqICAgdGVtcGxhdGU6ICdIZWxsbyB7e25hbWV9fSEnLFxuICAgICAqIH0pXG4gICAgICogY2xhc3MgR3JlZXQge1xuICAgICAqICAgbmFtZTogc3RyaW5nO1xuICAgICAqXG4gICAgICogICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgKiAgICAgdGhpcy5uYW1lID0gJ1dvcmxkJztcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgQ29tcG9uZW50IGluc3RlYWQuXG4gICAgICpcbiAgICAgKiB7XFxAbGluayBDb21wb25lbnR9XG4gICAgICovXG4gICAgdmFyIFZpZXdNZXRhZGF0YSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez89fSBfXzBcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIFZpZXdNZXRhZGF0YShfYSkge1xuICAgICAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIHRlbXBsYXRlVXJsID0gX2IudGVtcGxhdGVVcmwsIHRlbXBsYXRlID0gX2IudGVtcGxhdGUsIGVuY2Fwc3VsYXRpb24gPSBfYi5lbmNhcHN1bGF0aW9uLCBzdHlsZXMgPSBfYi5zdHlsZXMsIHN0eWxlVXJscyA9IF9iLnN0eWxlVXJscywgYW5pbWF0aW9ucyA9IF9iLmFuaW1hdGlvbnMsIGludGVycG9sYXRpb24gPSBfYi5pbnRlcnBvbGF0aW9uO1xuICAgICAgICAgICAgdGhpcy50ZW1wbGF0ZVVybCA9IHRlbXBsYXRlVXJsO1xuICAgICAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgICAgICAgICAgdGhpcy5zdHlsZVVybHMgPSBzdHlsZVVybHM7XG4gICAgICAgICAgICB0aGlzLnN0eWxlcyA9IHN0eWxlcztcbiAgICAgICAgICAgIHRoaXMuZW5jYXBzdWxhdGlvbiA9IGVuY2Fwc3VsYXRpb247XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbnMgPSBhbmltYXRpb25zO1xuICAgICAgICAgICAgdGhpcy5pbnRlcnBvbGF0aW9uID0gaW50ZXJwb2xhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVmlld01ldGFkYXRhO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBcXEB3aGF0SXREb2VzIFJlcHJlc2VudHMgdGhlIHZlcnNpb24gb2YgQW5ndWxhclxuICAgICAqXG4gICAgICogXFxAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIFZlcnNpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBmdWxsXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBWZXJzaW9uKGZ1bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZnVsbCA9IGZ1bGw7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZlcnNpb24ucHJvdG90eXBlLCBcIm1ham9yXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmZ1bGwuc3BsaXQoJy4nKVswXTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWZXJzaW9uLnByb3RvdHlwZSwgXCJtaW5vclwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5mdWxsLnNwbGl0KCcuJylbMV07IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVmVyc2lvbi5wcm90b3R5cGUsIFwicGF0Y2hcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZnVsbC5zcGxpdCgnLicpLnNsaWNlKDIpLmpvaW4oJy4nKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBWZXJzaW9uO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIFZFUlNJT04gPSBuZXcgVmVyc2lvbignMi40LjUnKTtcblxuICAgIC8qKlxuICAgICAqIEFsbG93cyB0byByZWZlciB0byByZWZlcmVuY2VzIHdoaWNoIGFyZSBub3QgeWV0IGRlZmluZWQuXG4gICAgICpcbiAgICAgKiBGb3IgaW5zdGFuY2UsIGBmb3J3YXJkUmVmYCBpcyB1c2VkIHdoZW4gdGhlIGB0b2tlbmAgd2hpY2ggd2UgbmVlZCB0byByZWZlciB0byBmb3IgdGhlIHB1cnBvc2VzIG9mXG4gICAgICogREkgaXMgZGVjbGFyZWQsXG4gICAgICogYnV0IG5vdCB5ZXQgZGVmaW5lZC4gSXQgaXMgYWxzbyB1c2VkIHdoZW4gdGhlIGB0b2tlbmAgd2hpY2ggd2UgdXNlIHdoZW4gY3JlYXRpbmcgYSBxdWVyeSBpcyBub3RcbiAgICAgKiB5ZXQgZGVmaW5lZC5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICoge1xcQGV4YW1wbGUgY29yZS9kaS90cy9mb3J3YXJkX3JlZi9mb3J3YXJkX3JlZl9zcGVjLnRzIHJlZ2lvbj0nZm9yd2FyZF9yZWYnfVxuICAgICAqIFxcQGV4cGVyaW1lbnRhbFxuICAgICAqIEBwYXJhbSB7P30gZm9yd2FyZFJlZkZuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3J3YXJkUmVmKGZvcndhcmRSZWZGbikge1xuICAgICAgICAoKGZvcndhcmRSZWZGbikpLl9fZm9yd2FyZF9yZWZfXyA9IGZvcndhcmRSZWY7XG4gICAgICAgICgoZm9yd2FyZFJlZkZuKSkudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBzdHJpbmdpZnkodGhpcygpKTsgfTtcbiAgICAgICAgcmV0dXJuICgoKGZvcndhcmRSZWZGbikpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGF6aWx5IHJldHJpZXZlcyB0aGUgcmVmZXJlbmNlIHZhbHVlIGZyb20gYSBmb3J3YXJkUmVmLlxuICAgICAqXG4gICAgICogQWN0cyBhcyB0aGUgaWRlbnRpdHkgZnVuY3Rpb24gd2hlbiBnaXZlbiBhIG5vbi1mb3J3YXJkLXJlZiB2YWx1ZS5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9HVTcybUpyazFmaW9kQ2hjbWlEUj9wPXByZXZpZXcpKVxuICAgICAqXG4gICAgICoge1xcQGV4YW1wbGUgY29yZS9kaS90cy9mb3J3YXJkX3JlZi9mb3J3YXJkX3JlZl9zcGVjLnRzIHJlZ2lvbj0ncmVzb2x2ZV9mb3J3YXJkX3JlZid9XG4gICAgICpcbiAgICAgKiBTZWU6IHtcXEBsaW5rIGZvcndhcmRSZWZ9XG4gICAgICogXFxAZXhwZXJpbWVudGFsXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXNvbHZlRm9yd2FyZFJlZih0eXBlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlLmhhc093blByb3BlcnR5KCdfX2ZvcndhcmRfcmVmX18nKSAmJlxuICAgICAgICAgICAgdHlwZS5fX2ZvcndhcmRfcmVmX18gPT09IGZvcndhcmRSZWYpIHtcbiAgICAgICAgICAgIHJldHVybiAoKHR5cGUpKSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2UgdG8gdGhyb3cgYW4gRXJyb3Igd2l0aCAndW5pbXBsZW1lbnRlZCcgYXMgdGhlIG1lc3NhZ2UuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmltcGxlbWVudGVkKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuaW1wbGVtZW50ZWQnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogXFxAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEJhc2VFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhCYXNlRXJyb3IsIF9zdXBlcik7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IG1lc3NhZ2VcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIEJhc2VFcnJvcihtZXNzYWdlKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIC8vIEVycm9ycyBkb24ndCB1c2UgY3VycmVudCB0aGlzLCBpbnN0ZWFkIHRoZXkgY3JlYXRlIGEgbmV3IGluc3RhbmNlLlxuICAgICAgICAgICAgLy8gV2UgaGF2ZSB0byBkbyBmb3J3YXJkIGFsbCBvZiBvdXIgYXBpIHRvIHRoZSBuYXRpdmVJbnN0YW5jZS5cbiAgICAgICAgICAgIC8vIFRPRE8oYnJhZGZvcmRjc21pdGgpOiBSZW1vdmUgdGhpcyBoYWNrIHdoZW5cbiAgICAgICAgICAgIC8vICAgICBnb29nbGUvY2xvc3VyZS1jb21waWxlci9pc3N1ZXMvMjEwMiBpcyBmaXhlZC5cbiAgICAgICAgICAgIHZhciBuYXRpdmVFcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICAgIHRoaXMuX25hdGl2ZUVycm9yID0gbmF0aXZlRXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2VFcnJvci5wcm90b3R5cGUsIFwibWVzc2FnZVwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbmF0aXZlRXJyb3IubWVzc2FnZTsgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBtZXNzYWdlXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChtZXNzYWdlKSB7IHRoaXMuX25hdGl2ZUVycm9yLm1lc3NhZ2UgPSBtZXNzYWdlOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2VFcnJvci5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbmF0aXZlRXJyb3IubmFtZTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlRXJyb3IucHJvdG90eXBlLCBcInN0YWNrXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiAoKHRoaXMuX25hdGl2ZUVycm9yKSkuc3RhY2s7IH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7ICgodGhpcy5fbmF0aXZlRXJyb3IpKS5zdGFjayA9IHZhbHVlOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBCYXNlRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbmF0aXZlRXJyb3IudG9TdHJpbmcoKTsgfTtcbiAgICAgICAgcmV0dXJuIEJhc2VFcnJvcjtcbiAgICB9KEVycm9yKSk7XG4gICAgLyoqXG4gICAgICogXFxAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIFdyYXBwZWRFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhXcmFwcGVkRXJyb3IsIF9zdXBlcik7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IG1lc3NhZ2VcbiAgICAgICAgICogQHBhcmFtIHs/fSBlcnJvclxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gV3JhcHBlZEVycm9yKG1lc3NhZ2UsIGVycm9yKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlICsgXCIgY2F1c2VkIGJ5OiBcIiArIChlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IGVycm9yKSk7XG4gICAgICAgICAgICB0aGlzLm9yaWdpbmFsRXJyb3IgPSBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JhcHBlZEVycm9yLnByb3RvdHlwZSwgXCJzdGFja1wiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoKCh0aGlzLm9yaWdpbmFsRXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IHRoaXMub3JpZ2luYWxFcnJvciA6IHRoaXMuX25hdGl2ZUVycm9yKSkpXG4gICAgICAgICAgICAgICAgICAgIC5zdGFjaztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gV3JhcHBlZEVycm9yO1xuICAgIH0oQmFzZUVycm9yKSk7XG5cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBfVEhST1dfSUZfTk9UX0ZPVU5EID0gbmV3IE9iamVjdCgpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIFRIUk9XX0lGX05PVF9GT1VORCA9IF9USFJPV19JRl9OT1RfRk9VTkQ7XG4gICAgdmFyIF9OdWxsSW5qZWN0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBfTnVsbEluamVjdG9yKCkge1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHRva2VuXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IG5vdEZvdW5kVmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIF9OdWxsSW5qZWN0b3IucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh0b2tlbiwgbm90Rm91bmRWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKG5vdEZvdW5kVmFsdWUgPT09IHZvaWQgMCkgeyBub3RGb3VuZFZhbHVlID0gX1RIUk9XX0lGX05PVF9GT1VORDsgfVxuICAgICAgICAgICAgaWYgKG5vdEZvdW5kVmFsdWUgPT09IF9USFJPV19JRl9OT1RfRk9VTkQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBwcm92aWRlciBmb3IgXCIgKyBzdHJpbmdpZnkodG9rZW4pICsgXCIhXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5vdEZvdW5kVmFsdWU7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfTnVsbEluamVjdG9yO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogXFxAd2hhdEl0RG9lcyBJbmplY3RvciBpbnRlcmZhY2VcbiAgICAgKiBcXEBob3dUb1VzZVxuICAgICAqIGBgYFxuICAgICAqIGNvbnN0IGluamVjdG9yOiBJbmplY3RvciA9IC4uLjtcbiAgICAgKiBpbmplY3Rvci5nZXQoLi4uKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFxcQGRlc2NyaXB0aW9uXG4gICAgICogRm9yIG1vcmUgZGV0YWlscywgc2VlIHRoZSB7XFxAbGlua0RvY3MgZ3VpZGUvZGVwZW5kZW5jeS1pbmplY3Rpb24gXCJEZXBlbmRlbmN5IEluamVjdGlvbiBHdWlkZVwifS5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiB7XFxAZXhhbXBsZSBjb3JlL2RpL3RzL2luamVjdG9yX3NwZWMudHMgcmVnaW9uPSdJbmplY3Rvcid9XG4gICAgICpcbiAgICAgKiBgSW5qZWN0b3JgIHJldHVybnMgaXRzZWxmIHdoZW4gZ2l2ZW4gYEluamVjdG9yYCBhcyBhIHRva2VuOlxuICAgICAqIHtcXEBleGFtcGxlIGNvcmUvZGkvdHMvaW5qZWN0b3Jfc3BlYy50cyByZWdpb249J2luamVjdEluamVjdG9yJ31cbiAgICAgKlxuICAgICAqIFxcQHN0YWJsZVxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICAgIHZhciBJbmplY3RvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEluamVjdG9yKCkge1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXRyaWV2ZXMgYW4gaW5zdGFuY2UgZnJvbSB0aGUgaW5qZWN0b3IgYmFzZWQgb24gdGhlIHByb3ZpZGVkIHRva2VuLlxuICAgICAgICAgKiBJZiBub3QgZm91bmQ6XG4gICAgICAgICAqIC0gVGhyb3dzIHtcXEBsaW5rIE5vUHJvdmlkZXJFcnJvcn0gaWYgbm8gYG5vdEZvdW5kVmFsdWVgIHRoYXQgaXMgbm90IGVxdWFsIHRvXG4gICAgICAgICAqIEluamVjdG9yLlRIUk9XX0lGX05PVF9GT1VORCBpcyBnaXZlblxuICAgICAgICAgKiAtIFJldHVybnMgdGhlIGBub3RGb3VuZFZhbHVlYCBvdGhlcndpc2VcbiAgICAgICAgICogQHBhcmFtIHs/fSB0b2tlblxuICAgICAgICAgKiBAcGFyYW0gez89fSBub3RGb3VuZFZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBJbmplY3Rvci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHRva2VuLCBub3RGb3VuZFZhbHVlKSB7IHJldHVybiB1bmltcGxlbWVudGVkKCk7IH07XG4gICAgICAgIEluamVjdG9yLlRIUk9XX0lGX05PVF9GT1VORCA9IF9USFJPV19JRl9OT1RfRk9VTkQ7XG4gICAgICAgIEluamVjdG9yLk5VTEwgPSBuZXcgX051bGxJbmplY3RvcigpO1xuICAgICAgICByZXR1cm4gSW5qZWN0b3I7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDEgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGtleXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRGaXJzdENsb3NlZEN5Y2xlKGtleXMpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzID0gW107XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAocmVzLmluZGV4T2Yoa2V5c1tpXSkgPiAtMSkge1xuICAgICAgICAgICAgICAgIHJlcy5wdXNoKGtleXNbaV0pO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXMucHVzaChrZXlzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGtleXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbnN0cnVjdFJlc29sdmluZ1BhdGgoa2V5cykge1xuICAgICAgICBpZiAoa2V5cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXZlcnNlZCA9IGZpbmRGaXJzdENsb3NlZEN5Y2xlKGtleXMuc2xpY2UoKS5yZXZlcnNlKCkpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdG9rZW5TdHJzID0gcmV2ZXJzZWQubWFwKGZ1bmN0aW9uIChrKSB7IHJldHVybiBzdHJpbmdpZnkoay50b2tlbik7IH0pO1xuICAgICAgICAgICAgcmV0dXJuICcgKCcgKyB0b2tlblN0cnMuam9pbignIC0+ICcpICsgJyknO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmFzZSBjbGFzcyBmb3IgYWxsIGVycm9ycyBhcmlzaW5nIGZyb20gbWlzY29uZmlndXJlZCBwcm92aWRlcnMuXG4gICAgICogXFxAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEFic3RyYWN0UHJvdmlkZXJFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQxKEFic3RyYWN0UHJvdmlkZXJFcnJvciwgX3N1cGVyKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gaW5qZWN0b3JcbiAgICAgICAgICogQHBhcmFtIHs/fSBrZXlcbiAgICAgICAgICogQHBhcmFtIHs/fSBjb25zdHJ1Y3RSZXNvbHZpbmdNZXNzYWdlXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBBYnN0cmFjdFByb3ZpZGVyRXJyb3IoaW5qZWN0b3IsIGtleSwgY29uc3RydWN0UmVzb2x2aW5nTWVzc2FnZSkge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgJ0RJIEVycm9yJyk7XG4gICAgICAgICAgICB0aGlzLmtleXMgPSBba2V5XTtcbiAgICAgICAgICAgIHRoaXMuaW5qZWN0b3JzID0gW2luamVjdG9yXTtcbiAgICAgICAgICAgIHRoaXMuY29uc3RydWN0UmVzb2x2aW5nTWVzc2FnZSA9IGNvbnN0cnVjdFJlc29sdmluZ01lc3NhZ2U7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSB0aGlzLmNvbnN0cnVjdFJlc29sdmluZ01lc3NhZ2UodGhpcy5rZXlzKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBpbmplY3RvclxuICAgICAgICAgKiBAcGFyYW0gez99IGtleVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQWJzdHJhY3RQcm92aWRlckVycm9yLnByb3RvdHlwZS5hZGRLZXkgPSBmdW5jdGlvbiAoaW5qZWN0b3IsIGtleSkge1xuICAgICAgICAgICAgdGhpcy5pbmplY3RvcnMucHVzaChpbmplY3Rvcik7XG4gICAgICAgICAgICB0aGlzLmtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gdGhpcy5jb25zdHJ1Y3RSZXNvbHZpbmdNZXNzYWdlKHRoaXMua2V5cyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBBYnN0cmFjdFByb3ZpZGVyRXJyb3I7XG4gICAgfShCYXNlRXJyb3IpKTtcbiAgICAvKipcbiAgICAgKiBUaHJvd24gd2hlbiB0cnlpbmcgdG8gcmV0cmlldmUgYSBkZXBlbmRlbmN5IGJ5IGtleSBmcm9tIHtcXEBsaW5rIEluamVjdG9yfSwgYnV0IHRoZVxuICAgICAqIHtcXEBsaW5rIEluamVjdG9yfSBkb2VzIG5vdCBoYXZlIGEge1xcQGxpbmsgUHJvdmlkZXJ9IGZvciB0aGUgZ2l2ZW4ga2V5LlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L3ZxOEQzRlJCOWFHYm5XSnF0RVBFP3A9cHJldmlldykpXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY2xhc3MgQSB7XG4gICAgICogICBjb25zdHJ1Y3RvcihiOkIpIHt9XG4gICAgICogfVxuICAgICAqXG4gICAgICogZXhwZWN0KCgpID0+IEluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW0FdKSkudG9UaHJvd0Vycm9yKCk7XG4gICAgICogYGBgXG4gICAgICogXFxAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIE5vUHJvdmlkZXJFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQxKE5vUHJvdmlkZXJFcnJvciwgX3N1cGVyKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gaW5qZWN0b3JcbiAgICAgICAgICogQHBhcmFtIHs/fSBrZXlcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIE5vUHJvdmlkZXJFcnJvcihpbmplY3Rvciwga2V5KSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBpbmplY3Rvciwga2V5LCBmdW5jdGlvbiAoa2V5cykge1xuICAgICAgICAgICAgICAgIHZhciBmaXJzdCA9IHN0cmluZ2lmeShrZXlzWzBdLnRva2VuKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJObyBwcm92aWRlciBmb3IgXCIgKyBmaXJzdCArIFwiIVwiICsgY29uc3RydWN0UmVzb2x2aW5nUGF0aChrZXlzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBOb1Byb3ZpZGVyRXJyb3I7XG4gICAgfShBYnN0cmFjdFByb3ZpZGVyRXJyb3IpKTtcbiAgICAvKipcbiAgICAgKiBUaHJvd24gd2hlbiBkZXBlbmRlbmNpZXMgZm9ybSBhIGN5Y2xlLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L3dZUWROb3MwVHpxbDNlaTFFVjlqP3A9aW5mbykpXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdmFyIGluamVjdG9yID0gSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbXG4gICAgICogICB7cHJvdmlkZTogXCJvbmVcIiwgdXNlRmFjdG9yeTogKHR3bykgPT4gXCJ0d29cIiwgZGVwczogW1tuZXcgSW5qZWN0KFwidHdvXCIpXV19LFxuICAgICAqICAge3Byb3ZpZGU6IFwidHdvXCIsIHVzZUZhY3Rvcnk6IChvbmUpID0+IFwib25lXCIsIGRlcHM6IFtbbmV3IEluamVjdChcIm9uZVwiKV1dfVxuICAgICAqIF0pO1xuICAgICAqXG4gICAgICogZXhwZWN0KCgpID0+IGluamVjdG9yLmdldChcIm9uZVwiKSkudG9UaHJvd0Vycm9yKCk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBSZXRyaWV2aW5nIGBBYCBvciBgQmAgdGhyb3dzIGEgYEN5Y2xpY0RlcGVuZGVuY3lFcnJvcmAgYXMgdGhlIGdyYXBoIGFib3ZlIGNhbm5vdCBiZSBjb25zdHJ1Y3RlZC5cbiAgICAgKiBcXEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgQ3ljbGljRGVwZW5kZW5jeUVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDEoQ3ljbGljRGVwZW5kZW5jeUVycm9yLCBfc3VwZXIpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBpbmplY3RvclxuICAgICAgICAgKiBAcGFyYW0gez99IGtleVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gQ3ljbGljRGVwZW5kZW5jeUVycm9yKGluamVjdG9yLCBrZXkpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGluamVjdG9yLCBrZXksIGZ1bmN0aW9uIChrZXlzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiQ2Fubm90IGluc3RhbnRpYXRlIGN5Y2xpYyBkZXBlbmRlbmN5IVwiICsgY29uc3RydWN0UmVzb2x2aW5nUGF0aChrZXlzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBDeWNsaWNEZXBlbmRlbmN5RXJyb3I7XG4gICAgfShBYnN0cmFjdFByb3ZpZGVyRXJyb3IpKTtcbiAgICAvKipcbiAgICAgKiBUaHJvd24gd2hlbiBhIGNvbnN0cnVjdGluZyB0eXBlIHJldHVybnMgd2l0aCBhbiBFcnJvci5cbiAgICAgKlxuICAgICAqIFRoZSBgSW5zdGFudGlhdGlvbkVycm9yYCBjbGFzcyBjb250YWlucyB0aGUgb3JpZ2luYWwgZXJyb3IgcGx1cyB0aGUgZGVwZW5kZW5jeSBncmFwaCB3aGljaCBjYXVzZWRcbiAgICAgKiB0aGlzIG9iamVjdCB0byBiZSBpbnN0YW50aWF0ZWQuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvN2FXWWRjcVRRc1AwZU5xRWRVQWY/cD1wcmV2aWV3KSlcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjbGFzcyBBIHtcbiAgICAgKiAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAqICAgICB0aHJvdyBuZXcgRXJyb3IoJ21lc3NhZ2UnKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgaW5qZWN0b3IgPSBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtBXSk7XG4gICAgICogdHJ5IHtcbiAgICAgKiAgIGluamVjdG9yLmdldChBKTtcbiAgICAgKiB9IGNhdGNoIChlKSB7XG4gICAgICogICBleHBlY3QoZSBpbnN0YW5jZW9mIEluc3RhbnRpYXRpb25FcnJvcikudG9CZSh0cnVlKTtcbiAgICAgKiAgIGV4cGVjdChlLm9yaWdpbmFsRXhjZXB0aW9uLm1lc3NhZ2UpLnRvRXF1YWwoXCJtZXNzYWdlXCIpO1xuICAgICAqICAgZXhwZWN0KGUub3JpZ2luYWxTdGFjaykudG9CZURlZmluZWQoKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICogXFxAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEluc3RhbnRpYXRpb25FcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQxKEluc3RhbnRpYXRpb25FcnJvciwgX3N1cGVyKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gaW5qZWN0b3JcbiAgICAgICAgICogQHBhcmFtIHs/fSBvcmlnaW5hbEV4Y2VwdGlvblxuICAgICAgICAgKiBAcGFyYW0gez99IG9yaWdpbmFsU3RhY2tcbiAgICAgICAgICogQHBhcmFtIHs/fSBrZXlcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIEluc3RhbnRpYXRpb25FcnJvcihpbmplY3Rvciwgb3JpZ2luYWxFeGNlcHRpb24sIG9yaWdpbmFsU3RhY2ssIGtleSkge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgJ0RJIEVycm9yJywgb3JpZ2luYWxFeGNlcHRpb24pO1xuICAgICAgICAgICAgdGhpcy5rZXlzID0gW2tleV07XG4gICAgICAgICAgICB0aGlzLmluamVjdG9ycyA9IFtpbmplY3Rvcl07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gaW5qZWN0b3JcbiAgICAgICAgICogQHBhcmFtIHs/fSBrZXlcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEluc3RhbnRpYXRpb25FcnJvci5wcm90b3R5cGUuYWRkS2V5ID0gZnVuY3Rpb24gKGluamVjdG9yLCBrZXkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5qZWN0b3JzLnB1c2goaW5qZWN0b3IpO1xuICAgICAgICAgICAgdGhpcy5rZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEluc3RhbnRpYXRpb25FcnJvci5wcm90b3R5cGUsIFwibWVzc2FnZVwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZpcnN0ID0gc3RyaW5naWZ5KHRoaXMua2V5c1swXS50b2tlbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3JpZ2luYWxFcnJvci5tZXNzYWdlICsgXCI6IEVycm9yIGR1cmluZyBpbnN0YW50aWF0aW9uIG9mIFwiICsgZmlyc3QgKyBcIiFcIiArIGNvbnN0cnVjdFJlc29sdmluZ1BhdGgodGhpcy5rZXlzKSArIFwiLlwiO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbnN0YW50aWF0aW9uRXJyb3IucHJvdG90eXBlLCBcImNhdXNlS2V5XCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmtleXNbMF07IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gSW5zdGFudGlhdGlvbkVycm9yO1xuICAgIH0oV3JhcHBlZEVycm9yKSk7XG4gICAgLyoqXG4gICAgICogVGhyb3duIHdoZW4gYW4gb2JqZWN0IG90aGVyIHRoZW4ge1xcQGxpbmsgUHJvdmlkZXJ9IChvciBgVHlwZWApIGlzIHBhc3NlZCB0byB7XFxAbGluayBJbmplY3Rvcn1cbiAgICAgKiBjcmVhdGlvbi5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9ZYXRDRmJQQU1DTDBKU1NRNG12SD9wPXByZXZpZXcpKVxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGV4cGVjdCgoKSA9PiBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtcIm5vdCBhIHR5cGVcIl0pKS50b1Rocm93RXJyb3IoKTtcbiAgICAgKiBgYGBcbiAgICAgKiBcXEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgSW52YWxpZFByb3ZpZGVyRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMShJbnZhbGlkUHJvdmlkZXJFcnJvciwgX3N1cGVyKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gcHJvdmlkZXJcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIEludmFsaWRQcm92aWRlckVycm9yKHByb3ZpZGVyKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBcIkludmFsaWQgcHJvdmlkZXIgLSBvbmx5IGluc3RhbmNlcyBvZiBQcm92aWRlciBhbmQgVHlwZSBhcmUgYWxsb3dlZCwgZ290OiBcIiArIHByb3ZpZGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSW52YWxpZFByb3ZpZGVyRXJyb3I7XG4gICAgfShCYXNlRXJyb3IpKTtcbiAgICAvKipcbiAgICAgKiBUaHJvd24gd2hlbiB0aGUgY2xhc3MgaGFzIG5vIGFubm90YXRpb24gaW5mb3JtYXRpb24uXG4gICAgICpcbiAgICAgKiBMYWNrIG9mIGFubm90YXRpb24gaW5mb3JtYXRpb24gcHJldmVudHMgdGhlIHtcXEBsaW5rIEluamVjdG9yfSBmcm9tIGRldGVybWluaW5nIHdoaWNoIGRlcGVuZGVuY2llc1xuICAgICAqIG5lZWQgdG8gYmUgaW5qZWN0ZWQgaW50byB0aGUgY29uc3RydWN0b3IuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvckhuWnRsTlM3dkpPUFE2cGNWa20/cD1wcmV2aWV3KSlcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjbGFzcyBBIHtcbiAgICAgKiAgIGNvbnN0cnVjdG9yKGIpIHt9XG4gICAgICogfVxuICAgICAqXG4gICAgICogZXhwZWN0KCgpID0+IEluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW0FdKSkudG9UaHJvd0Vycm9yKCk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBUaGlzIGVycm9yIGlzIGFsc28gdGhyb3duIHdoZW4gdGhlIGNsYXNzIG5vdCBtYXJrZWQgd2l0aCB7XFxAbGluayBJbmplY3RhYmxlfSBoYXMgcGFyYW1ldGVyIHR5cGVzLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNsYXNzIEIge31cbiAgICAgKlxuICAgICAqIGNsYXNzIEEge1xuICAgICAqICAgY29uc3RydWN0b3IoYjpCKSB7fSAvLyBubyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcGFyYW1ldGVyIHR5cGVzIG9mIEEgaXMgYXZhaWxhYmxlIGF0IHJ1bnRpbWUuXG4gICAgICogfVxuICAgICAqXG4gICAgICogZXhwZWN0KCgpID0+IEluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW0EsQl0pKS50b1Rocm93RXJyb3IoKTtcbiAgICAgKiBgYGBcbiAgICAgKiBcXEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgTm9Bbm5vdGF0aW9uRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMShOb0Fubm90YXRpb25FcnJvciwgX3N1cGVyKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdHlwZU9yRnVuY1xuICAgICAgICAgKiBAcGFyYW0gez99IHBhcmFtc1xuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gTm9Bbm5vdGF0aW9uRXJyb3IodHlwZU9yRnVuYywgcGFyYW1zKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBOb0Fubm90YXRpb25FcnJvci5fZ2VuTWVzc2FnZSh0eXBlT3JGdW5jLCBwYXJhbXMpKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB0eXBlT3JGdW5jXG4gICAgICAgICAqIEBwYXJhbSB7P30gcGFyYW1zXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBOb0Fubm90YXRpb25FcnJvci5fZ2VuTWVzc2FnZSA9IGZ1bmN0aW9uICh0eXBlT3JGdW5jLCBwYXJhbXMpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNpZ25hdHVyZSA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMCwgLyoqIEB0eXBlIHs/fSAqLyBpaSA9IHBhcmFtcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyYW1ldGVyID0gcGFyYW1zW2ldO1xuICAgICAgICAgICAgICAgIGlmICghcGFyYW1ldGVyIHx8IHBhcmFtZXRlci5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmUucHVzaCgnPycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlLnB1c2gocGFyYW1ldGVyLm1hcChzdHJpbmdpZnkpLmpvaW4oJyAnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICdDYW5ub3QgcmVzb2x2ZSBhbGwgcGFyYW1ldGVycyBmb3IgXFwnJyArIHN0cmluZ2lmeSh0eXBlT3JGdW5jKSArICdcXCcoJyArXG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlLmpvaW4oJywgJykgKyAnKS4gJyArXG4gICAgICAgICAgICAgICAgJ01ha2Ugc3VyZSB0aGF0IGFsbCB0aGUgcGFyYW1ldGVycyBhcmUgZGVjb3JhdGVkIHdpdGggSW5qZWN0IG9yIGhhdmUgdmFsaWQgdHlwZSBhbm5vdGF0aW9ucyBhbmQgdGhhdCBcXCcnICtcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkodHlwZU9yRnVuYykgKyAnXFwnIGlzIGRlY29yYXRlZCB3aXRoIEluamVjdGFibGUuJztcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE5vQW5ub3RhdGlvbkVycm9yO1xuICAgIH0oQmFzZUVycm9yKSk7XG4gICAgLyoqXG4gICAgICogVGhyb3duIHdoZW4gZ2V0dGluZyBhbiBvYmplY3QgYnkgaW5kZXguXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvYlJzMFNYMk9UUWlKenF2amdsOFA/cD1wcmV2aWV3KSlcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjbGFzcyBBIHt9XG4gICAgICpcbiAgICAgKiB2YXIgaW5qZWN0b3IgPSBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtBXSk7XG4gICAgICpcbiAgICAgKiBleHBlY3QoKCkgPT4gaW5qZWN0b3IuZ2V0QXQoMTAwKSkudG9UaHJvd0Vycm9yKCk7XG4gICAgICogYGBgXG4gICAgICogXFxAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIE91dE9mQm91bmRzRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMShPdXRPZkJvdW5kc0Vycm9yLCBfc3VwZXIpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBpbmRleFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gT3V0T2ZCb3VuZHNFcnJvcihpbmRleCkge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgXCJJbmRleCBcIiArIGluZGV4ICsgXCIgaXMgb3V0LW9mLWJvdW5kcy5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE91dE9mQm91bmRzRXJyb3I7XG4gICAgfShCYXNlRXJyb3IpKTtcbiAgICAvKipcbiAgICAgKiBUaHJvd24gd2hlbiBhIG11bHRpIHByb3ZpZGVyIGFuZCBhIHJlZ3VsYXIgcHJvdmlkZXIgYXJlIGJvdW5kIHRvIHRoZSBzYW1lIHRva2VuLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBleHBlY3QoKCkgPT4gSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbXG4gICAgICogICB7IHByb3ZpZGU6IFwiU3RyaW5nc1wiLCB1c2VWYWx1ZTogXCJzdHJpbmcxXCIsIG11bHRpOiB0cnVlfSxcbiAgICAgKiAgIHsgcHJvdmlkZTogXCJTdHJpbmdzXCIsIHVzZVZhbHVlOiBcInN0cmluZzJcIiwgbXVsdGk6IGZhbHNlfVxuICAgICAqIF0pKS50b1Rocm93RXJyb3IoKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICB2YXIgTWl4aW5nTXVsdGlQcm92aWRlcnNXaXRoUmVndWxhclByb3ZpZGVyc0Vycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDEoTWl4aW5nTXVsdGlQcm92aWRlcnNXaXRoUmVndWxhclByb3ZpZGVyc0Vycm9yLCBfc3VwZXIpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBwcm92aWRlcjFcbiAgICAgICAgICogQHBhcmFtIHs/fSBwcm92aWRlcjJcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIE1peGluZ011bHRpUHJvdmlkZXJzV2l0aFJlZ3VsYXJQcm92aWRlcnNFcnJvcihwcm92aWRlcjEsIHByb3ZpZGVyMikge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgJ0Nhbm5vdCBtaXggbXVsdGkgcHJvdmlkZXJzIGFuZCByZWd1bGFyIHByb3ZpZGVycywgZ290OiAnICsgcHJvdmlkZXIxLnRvU3RyaW5nKCkgKyAnICcgK1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyMi50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTWl4aW5nTXVsdGlQcm92aWRlcnNXaXRoUmVndWxhclByb3ZpZGVyc0Vycm9yO1xuICAgIH0oQmFzZUVycm9yKSk7XG5cbiAgICAvKipcbiAgICAgKiBBIHVuaXF1ZSBvYmplY3QgdXNlZCBmb3IgcmV0cmlldmluZyBpdGVtcyBmcm9tIHRoZSB7XFxAbGluayBSZWZsZWN0aXZlSW5qZWN0b3J9LlxuICAgICAqXG4gICAgICogS2V5cyBoYXZlOlxuICAgICAqIC0gYSBzeXN0ZW0td2lkZSB1bmlxdWUgYGlkYC5cbiAgICAgKiAtIGEgYHRva2VuYC5cbiAgICAgKlxuICAgICAqIGBLZXlgIGlzIHVzZWQgaW50ZXJuYWxseSBieSB7XFxAbGluayBSZWZsZWN0aXZlSW5qZWN0b3J9IGJlY2F1c2UgaXRzIHN5c3RlbS13aWRlIHVuaXF1ZSBgaWRgIGFsbG93c1xuICAgICAqIHRoZVxuICAgICAqIGluamVjdG9yIHRvIHN0b3JlIGNyZWF0ZWQgb2JqZWN0cyBpbiBhIG1vcmUgZWZmaWNpZW50IHdheS5cbiAgICAgKlxuICAgICAqIGBLZXlgIHNob3VsZCBub3QgYmUgY3JlYXRlZCBkaXJlY3RseS4ge1xcQGxpbmsgUmVmbGVjdGl2ZUluamVjdG9yfSBjcmVhdGVzIGtleXMgYXV0b21hdGljYWxseSB3aGVuXG4gICAgICogcmVzb2x2aW5nXG4gICAgICogcHJvdmlkZXJzLlxuICAgICAqIFxcQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBSZWZsZWN0aXZlS2V5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByaXZhdGVcbiAgICAgICAgICogQHBhcmFtIHs/fSB0b2tlblxuICAgICAgICAgKiBAcGFyYW0gez99IGlkXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBSZWZsZWN0aXZlS2V5KHRva2VuLCBpZCkge1xuICAgICAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICAgICAgaWYgKCF0b2tlbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVG9rZW4gbXVzdCBiZSBkZWZpbmVkIScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWZsZWN0aXZlS2V5LnByb3RvdHlwZSwgXCJkaXNwbGF5TmFtZVwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHVybnMgYSBzdHJpbmdpZmllZCB0b2tlbi5cbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RyaW5naWZ5KHRoaXMudG9rZW4pOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHJpZXZlcyBhIGBLZXlgIGZvciBhIHRva2VuLlxuICAgICAgICAgKiBAcGFyYW0gez99IHRva2VuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBSZWZsZWN0aXZlS2V5LmdldCA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICAgICAgcmV0dXJuIF9nbG9iYWxLZXlSZWdpc3RyeS5nZXQocmVzb2x2ZUZvcndhcmRSZWYodG9rZW4pKTtcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlZmxlY3RpdmVLZXksIFwibnVtYmVyT2ZLZXlzXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P30gdGhlIG51bWJlciBvZiBrZXlzIHJlZ2lzdGVyZWQgaW4gdGhlIHN5c3RlbS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBfZ2xvYmFsS2V5UmVnaXN0cnkubnVtYmVyT2ZLZXlzOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFJlZmxlY3RpdmVLZXk7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBcXEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHZhciBLZXlSZWdpc3RyeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEtleVJlZ2lzdHJ5KCkge1xuICAgICAgICAgICAgdGhpcy5fYWxsS2V5cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB0b2tlblxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgS2V5UmVnaXN0cnkucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICAgICAgaWYgKHRva2VuIGluc3RhbmNlb2YgUmVmbGVjdGl2ZUtleSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICBpZiAodGhpcy5fYWxsS2V5cy5oYXModG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FsbEtleXMuZ2V0KHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5ld0tleSA9IG5ldyBSZWZsZWN0aXZlS2V5KHRva2VuLCBSZWZsZWN0aXZlS2V5Lm51bWJlck9mS2V5cyk7XG4gICAgICAgICAgICB0aGlzLl9hbGxLZXlzLnNldCh0b2tlbiwgbmV3S2V5KTtcbiAgICAgICAgICAgIHJldHVybiBuZXdLZXk7XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShLZXlSZWdpc3RyeS5wcm90b3R5cGUsIFwibnVtYmVyT2ZLZXlzXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9hbGxLZXlzLnNpemU7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gS2V5UmVnaXN0cnk7XG4gICAgfSgpKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBfZ2xvYmFsS2V5UmVnaXN0cnkgPSBuZXcgS2V5UmVnaXN0cnkoKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAd2hhdEl0RG9lcyBSZXByZXNlbnRzIGEgdHlwZSB0aGF0IGEgQ29tcG9uZW50IG9yIG90aGVyIG9iamVjdCBpcyBpbnN0YW5jZXMgb2YuXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIEFuIGV4YW1wbGUgb2YgYSBgVHlwZWAgaXMgYE15Q3VzdG9tQ29tcG9uZW50YCBjbGFzcywgd2hpY2ggaW4gSmF2YVNjcmlwdCBpcyBiZSByZXByZXNlbnRlZCBieVxuICAgICAqIHRoZSBgTXlDdXN0b21Db21wb25lbnRgIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIFR5cGUgPSBGdW5jdGlvbjtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzVHlwZSh2KSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdiA9PT0gJ2Z1bmN0aW9uJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBdHRlbnRpb246IFRoaXMgcmVnZXggaGFzIHRvIGhvbGQgZXZlbiBpZiB0aGUgY29kZSBpcyBtaW5pZmllZCFcbiAgICAgKi9cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBERUxFR0FURV9DVE9SID0gL15mdW5jdGlvblxccytcXFMrXFwoXFwpXFxzKntcXHMqKFwidXNlIHN0cmljdFwiOyk/XFxzKihyZXR1cm5cXHMrKT9cXFMrXFwuYXBwbHlcXCh0aGlzLFxccyphcmd1bWVudHNcXCkvO1xuICAgIHZhciBSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IHJlZmxlY3RcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMocmVmbGVjdCkge1xuICAgICAgICAgICAgdGhpcy5fcmVmbGVjdCA9IHJlZmxlY3QgfHwgZ2xvYmFsJDEuUmVmbGVjdDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLmlzUmVmbGVjdGlvbkVuYWJsZWQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB0XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnByb3RvdHlwZS5mYWN0b3J5ID0gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIGFyZ3NbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3ICh0LmJpbmQuYXBwbHkodCwgW3ZvaWQgMF0uY29uY2F0KGFyZ3MpKSkoKTtcbiAgICAgICAgfTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxcQGludGVybmFsXG4gICAgICAgICAqIEBwYXJhbSB7P30gcGFyYW1UeXBlc1xuICAgICAgICAgKiBAcGFyYW0gez99IHBhcmFtQW5ub3RhdGlvbnNcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLl96aXBUeXBlc0FuZEFubm90YXRpb25zID0gZnVuY3Rpb24gKHBhcmFtVHlwZXMsIHBhcmFtQW5ub3RhdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFyYW1UeXBlcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgQXJyYXkocGFyYW1Bbm5vdGF0aW9ucy5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEFycmF5KHBhcmFtVHlwZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBUUyBvdXRwdXRzIE9iamVjdCBmb3IgcGFyYW1ldGVycyB3aXRob3V0IHR5cGVzLCB3aGlsZSBUcmFjZXVyIG9taXRzXG4gICAgICAgICAgICAgICAgLy8gdGhlIGFubm90YXRpb25zLiBGb3Igbm93IHdlIHByZXNlcnZlIHRoZSBUcmFjZXVyIGJlaGF2aW9yIHRvIGFpZFxuICAgICAgICAgICAgICAgIC8vIG1pZ3JhdGlvbiwgYnV0IHRoaXMgY2FuIGJlIHJldmlzaXRlZC5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBhcmFtVHlwZXMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJhbVR5cGVzW2ldICE9IE9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSBbcGFyYW1UeXBlc1tpXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtQW5ub3RhdGlvbnMgJiYgaXNQcmVzZW50KHBhcmFtQW5ub3RhdGlvbnNbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IHJlc3VsdFtpXS5jb25jYXQocGFyYW1Bbm5vdGF0aW9uc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAgICAgKiBAcGFyYW0gez99IHBhcmVudEN0b3JcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLl9vd25QYXJhbWV0ZXJzID0gZnVuY3Rpb24gKHR5cGUsIHBhcmVudEN0b3IpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgbm8gZGVjb3JhdG9ycywgd2Ugb25seSBoYXZlIGZ1bmN0aW9uLmxlbmd0aCBhcyBtZXRhZGF0YS5cbiAgICAgICAgICAgIC8vIEluIHRoYXQgY2FzZSwgdG8gZGV0ZWN0IHdoZXRoZXIgYSBjaGlsZCBjbGFzcyBkZWNsYXJlZCBhbiBvd24gY29uc3RydWN0b3Igb3Igbm90LFxuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBsb29rIGluc2lkZSBvZiB0aGF0IGNvbnN0cnVjdG9yIHRvIGNoZWNrIHdoZXRoZXIgaXQgaXNcbiAgICAgICAgICAgIC8vIGp1c3QgY2FsbGluZyB0aGUgcGFyZW50LlxuICAgICAgICAgICAgLy8gVGhpcyBhbHNvIGhlbHBzIHRvIHdvcmsgYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzEyNDM5XG4gICAgICAgICAgICAvLyB0aGF0IHNldHMgJ2Rlc2lnbjpwYXJhbXR5cGVzJyB0byBbXVxuICAgICAgICAgICAgLy8gaWYgYSBjbGFzcyBpbmhlcml0cyBmcm9tIGFub3RoZXIgY2xhc3MgYnV0IGhhcyBubyBjdG9yIGRlY2xhcmVkIGl0c2VsZi5cbiAgICAgICAgICAgIGlmIChERUxFR0FURV9DVE9SLmV4ZWModHlwZS50b1N0cmluZygpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUHJlZmVyIHRoZSBkaXJlY3QgQVBJLlxuICAgICAgICAgICAgaWYgKCgodHlwZSkpLnBhcmFtZXRlcnMgJiYgKCh0eXBlKSkucGFyYW1ldGVycyAhPT0gcGFyZW50Q3Rvci5wYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgodHlwZSkpLnBhcmFtZXRlcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBUEkgb2YgdHNpY2tsZSBmb3IgbG93ZXJpbmcgZGVjb3JhdG9ycyB0byBwcm9wZXJ0aWVzIG9uIHRoZSBjbGFzcy5cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRzaWNrbGVDdG9yUGFyYW1zID0gKCh0eXBlKSkuY3RvclBhcmFtZXRlcnM7XG4gICAgICAgICAgICBpZiAodHNpY2tsZUN0b3JQYXJhbXMgJiYgdHNpY2tsZUN0b3JQYXJhbXMgIT09IHBhcmVudEN0b3IuY3RvclBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgICAgICAvLyBOZXdlciB0c2lja2xlIHVzZXMgYSBmdW5jdGlvbiBjbG9zdXJlXG4gICAgICAgICAgICAgICAgLy8gUmV0YWluIHRoZSBub24tZnVuY3Rpb24gY2FzZSBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG9sZGVyIHRzaWNrbGVcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjdG9yUGFyYW1ldGVycyA9IHR5cGVvZiB0c2lja2xlQ3RvclBhcmFtcyA9PT0gJ2Z1bmN0aW9uJyA/IHRzaWNrbGVDdG9yUGFyYW1zKCkgOiB0c2lja2xlQ3RvclBhcmFtcztcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJhbVR5cGVzID0gY3RvclBhcmFtZXRlcnMubWFwKGZ1bmN0aW9uIChjdG9yUGFyYW0pIHsgcmV0dXJuIGN0b3JQYXJhbSAmJiBjdG9yUGFyYW0udHlwZTsgfSk7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyYW1Bbm5vdGF0aW9ucyA9IGN0b3JQYXJhbWV0ZXJzLm1hcChmdW5jdGlvbiAoY3RvclBhcmFtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjdG9yUGFyYW0gJiYgY29udmVydFRzaWNrbGVEZWNvcmF0b3JJbnRvTWV0YWRhdGEoY3RvclBhcmFtLmRlY29yYXRvcnMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl96aXBUeXBlc0FuZEFubm90YXRpb25zKHBhcmFtVHlwZXMsIHBhcmFtQW5ub3RhdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQVBJIGZvciBtZXRhZGF0YSBjcmVhdGVkIGJ5IGludm9raW5nIHRoZSBkZWNvcmF0b3JzLlxuICAgICAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLl9yZWZsZWN0KSAmJiBpc1ByZXNlbnQodGhpcy5fcmVmbGVjdC5nZXRPd25NZXRhZGF0YSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJhbUFubm90YXRpb25zID0gdGhpcy5fcmVmbGVjdC5nZXRPd25NZXRhZGF0YSgncGFyYW1ldGVycycsIHR5cGUpO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcmFtVHlwZXMgPSB0aGlzLl9yZWZsZWN0LmdldE93bk1ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIHR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbVR5cGVzIHx8IHBhcmFtQW5ub3RhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ppcFR5cGVzQW5kQW5ub3RhdGlvbnMocGFyYW1UeXBlcywgcGFyYW1Bbm5vdGF0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgYSBjbGFzcyBoYXMgbm8gZGVjb3JhdG9ycywgYXQgbGVhc3QgY3JlYXRlIG1ldGFkYXRhXG4gICAgICAgICAgICAvLyBiYXNlZCBvbiBmdW5jdGlvbi5sZW5ndGguXG4gICAgICAgICAgICAvLyBOb3RlOiBXZSBrbm93IHRoYXQgdGhpcyBpcyBhIHJlYWwgY29uc3RydWN0b3IgYXMgd2UgY2hlY2tlZFxuICAgICAgICAgICAgLy8gdGhlIGNvbnRlbnQgb2YgdGhlIGNvbnN0cnVjdG9yIGFib3ZlLlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBcnJheSgoKHR5cGUubGVuZ3RoKSkpLmZpbGwodW5kZWZpbmVkKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgUmVmbGVjdGlvbkNhcGFiaWxpdGllcy5wcm90b3R5cGUucGFyYW1ldGVycyA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICAvLyBOb3RlOiBvbmx5IHJlcG9ydCBtZXRhZGF0YSBpZiB3ZSBoYXZlIGF0IGxlYXN0IG9uZSBjbGFzcyBkZWNvcmF0b3JcbiAgICAgICAgICAgIC8vIHRvIHN0YXkgaW4gc3luYyB3aXRoIHRoZSBzdGF0aWMgcmVmbGVjdG9yLlxuICAgICAgICAgICAgaWYgKCFpc1R5cGUodHlwZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJlbnRDdG9yID0gZ2V0UGFyZW50Q3Rvcih0eXBlKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcmFtZXRlcnMgPSB0aGlzLl9vd25QYXJhbWV0ZXJzKHR5cGUsIHBhcmVudEN0b3IpO1xuICAgICAgICAgICAgaWYgKCFwYXJhbWV0ZXJzICYmIHBhcmVudEN0b3IgIT09IE9iamVjdCkge1xuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMgPSB0aGlzLnBhcmFtZXRlcnMocGFyZW50Q3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGFyYW1ldGVycyB8fCBbXTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdHlwZU9yRnVuY1xuICAgICAgICAgKiBAcGFyYW0gez99IHBhcmVudEN0b3JcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLl9vd25Bbm5vdGF0aW9ucyA9IGZ1bmN0aW9uICh0eXBlT3JGdW5jLCBwYXJlbnRDdG9yKSB7XG4gICAgICAgICAgICAvLyBQcmVmZXIgdGhlIGRpcmVjdCBBUEkuXG4gICAgICAgICAgICBpZiAoKCh0eXBlT3JGdW5jKSkuYW5ub3RhdGlvbnMgJiYgKCh0eXBlT3JGdW5jKSkuYW5ub3RhdGlvbnMgIT09IHBhcmVudEN0b3IuYW5ub3RhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhbm5vdGF0aW9ucyA9ICgodHlwZU9yRnVuYykpLmFubm90YXRpb25zO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYW5ub3RhdGlvbnMgPT09ICdmdW5jdGlvbicgJiYgYW5ub3RhdGlvbnMuYW5ub3RhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9ucy5hbm5vdGF0aW9ucztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFubm90YXRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQVBJIG9mIHRzaWNrbGUgZm9yIGxvd2VyaW5nIGRlY29yYXRvcnMgdG8gcHJvcGVydGllcyBvbiB0aGUgY2xhc3MuXG4gICAgICAgICAgICBpZiAoKCh0eXBlT3JGdW5jKSkuZGVjb3JhdG9ycyAmJiAoKHR5cGVPckZ1bmMpKS5kZWNvcmF0b3JzICE9PSBwYXJlbnRDdG9yLmRlY29yYXRvcnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udmVydFRzaWNrbGVEZWNvcmF0b3JJbnRvTWV0YWRhdGEoKCh0eXBlT3JGdW5jKSkuZGVjb3JhdG9ycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBUEkgZm9yIG1ldGFkYXRhIGNyZWF0ZWQgYnkgaW52b2tpbmcgdGhlIGRlY29yYXRvcnMuXG4gICAgICAgICAgICBpZiAodGhpcy5fcmVmbGVjdCAmJiB0aGlzLl9yZWZsZWN0LmdldE93bk1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlZmxlY3QuZ2V0T3duTWV0YWRhdGEoJ2Fubm90YXRpb25zJywgdHlwZU9yRnVuYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHR5cGVPckZ1bmNcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLmFubm90YXRpb25zID0gZnVuY3Rpb24gKHR5cGVPckZ1bmMpIHtcbiAgICAgICAgICAgIGlmICghaXNUeXBlKHR5cGVPckZ1bmMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyZW50Q3RvciA9IGdldFBhcmVudEN0b3IodHlwZU9yRnVuYyk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvd25Bbm5vdGF0aW9ucyA9IHRoaXMuX293bkFubm90YXRpb25zKHR5cGVPckZ1bmMsIHBhcmVudEN0b3IpIHx8IFtdO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyZW50QW5ub3RhdGlvbnMgPSBwYXJlbnRDdG9yICE9PSBPYmplY3QgPyB0aGlzLmFubm90YXRpb25zKHBhcmVudEN0b3IpIDogW107XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50QW5ub3RhdGlvbnMuY29uY2F0KG93bkFubm90YXRpb25zKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdHlwZU9yRnVuY1xuICAgICAgICAgKiBAcGFyYW0gez99IHBhcmVudEN0b3JcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLl9vd25Qcm9wTWV0YWRhdGEgPSBmdW5jdGlvbiAodHlwZU9yRnVuYywgcGFyZW50Q3Rvcikge1xuICAgICAgICAgICAgLy8gUHJlZmVyIHRoZSBkaXJlY3QgQVBJLlxuICAgICAgICAgICAgaWYgKCgodHlwZU9yRnVuYykpLnByb3BNZXRhZGF0YSAmJlxuICAgICAgICAgICAgICAgICgodHlwZU9yRnVuYykpLnByb3BNZXRhZGF0YSAhPT0gcGFyZW50Q3Rvci5wcm9wTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm9wTWV0YWRhdGEgPSAoKHR5cGVPckZ1bmMpKS5wcm9wTWV0YWRhdGE7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wTWV0YWRhdGEgPT09ICdmdW5jdGlvbicgJiYgcHJvcE1ldGFkYXRhLnByb3BNZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBwcm9wTWV0YWRhdGEgPSBwcm9wTWV0YWRhdGEucHJvcE1ldGFkYXRhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvcE1ldGFkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQVBJIG9mIHRzaWNrbGUgZm9yIGxvd2VyaW5nIGRlY29yYXRvcnMgdG8gcHJvcGVydGllcyBvbiB0aGUgY2xhc3MuXG4gICAgICAgICAgICBpZiAoKCh0eXBlT3JGdW5jKSkucHJvcERlY29yYXRvcnMgJiZcbiAgICAgICAgICAgICAgICAoKHR5cGVPckZ1bmMpKS5wcm9wRGVjb3JhdG9ycyAhPT0gcGFyZW50Q3Rvci5wcm9wRGVjb3JhdG9ycykge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByb3BEZWNvcmF0b3JzXzEgPSAoKHR5cGVPckZ1bmMpKS5wcm9wRGVjb3JhdG9ycztcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm9wTWV0YWRhdGFfMSA9ICh7fSk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMocHJvcERlY29yYXRvcnNfMSkuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgICAgICAgICBwcm9wTWV0YWRhdGFfMVtwcm9wXSA9IGNvbnZlcnRUc2lja2xlRGVjb3JhdG9ySW50b01ldGFkYXRhKHByb3BEZWNvcmF0b3JzXzFbcHJvcF0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9wTWV0YWRhdGFfMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFQSSBmb3IgbWV0YWRhdGEgY3JlYXRlZCBieSBpbnZva2luZyB0aGUgZGVjb3JhdG9ycy5cbiAgICAgICAgICAgIGlmICh0aGlzLl9yZWZsZWN0ICYmIHRoaXMuX3JlZmxlY3QuZ2V0T3duTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVmbGVjdC5nZXRPd25NZXRhZGF0YSgncHJvcE1ldGFkYXRhJywgdHlwZU9yRnVuYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHR5cGVPckZ1bmNcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLnByb3BNZXRhZGF0YSA9IGZ1bmN0aW9uICh0eXBlT3JGdW5jKSB7XG4gICAgICAgICAgICBpZiAoIWlzVHlwZSh0eXBlT3JGdW5jKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcmVudEN0b3IgPSBnZXRQYXJlbnRDdG9yKHR5cGVPckZ1bmMpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvcE1ldGFkYXRhID0ge307XG4gICAgICAgICAgICBpZiAocGFyZW50Q3RvciAhPT0gT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyZW50UHJvcE1ldGFkYXRhXzEgPSB0aGlzLnByb3BNZXRhZGF0YShwYXJlbnRDdG9yKTtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhwYXJlbnRQcm9wTWV0YWRhdGFfMSkuZm9yRWFjaChmdW5jdGlvbiAocHJvcE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcE1ldGFkYXRhW3Byb3BOYW1lXSA9IHBhcmVudFByb3BNZXRhZGF0YV8xW3Byb3BOYW1lXTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG93blByb3BNZXRhZGF0YSA9IHRoaXMuX293blByb3BNZXRhZGF0YSh0eXBlT3JGdW5jLCBwYXJlbnRDdG9yKTtcbiAgICAgICAgICAgIGlmIChvd25Qcm9wTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhvd25Qcm9wTWV0YWRhdGEpLmZvckVhY2goZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlY29yYXRvcnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BNZXRhZGF0YS5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY29yYXRvcnMucHVzaC5hcHBseShkZWNvcmF0b3JzLCBwcm9wTWV0YWRhdGFbcHJvcE5hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWNvcmF0b3JzLnB1c2guYXBwbHkoZGVjb3JhdG9ycywgb3duUHJvcE1ldGFkYXRhW3Byb3BOYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgIHByb3BNZXRhZGF0YVtwcm9wTmFtZV0gPSBkZWNvcmF0b3JzO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByb3BNZXRhZGF0YTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAgICAgKiBAcGFyYW0gez99IGxjUHJvcGVydHlcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLmhhc0xpZmVjeWNsZUhvb2sgPSBmdW5jdGlvbiAodHlwZSwgbGNQcm9wZXJ0eSkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGUgaW5zdGFuY2VvZiBUeXBlICYmIGxjUHJvcGVydHkgaW4gdHlwZS5wcm90b3R5cGU7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLmdldHRlciA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiAoKG5ldyBGdW5jdGlvbignbycsICdyZXR1cm4gby4nICsgbmFtZSArICc7JykpKTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgUmVmbGVjdGlvbkNhcGFiaWxpdGllcy5wcm90b3R5cGUuc2V0dGVyID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiAoKG5ldyBGdW5jdGlvbignbycsICd2JywgJ3JldHVybiBvLicgKyBuYW1lICsgJyA9IHY7JykpKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgUmVmbGVjdGlvbkNhcGFiaWxpdGllcy5wcm90b3R5cGUubWV0aG9kID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZ1bmN0aW9uQm9keSA9IFwiaWYgKCFvLlwiICsgbmFtZSArIFwiKSB0aHJvdyBuZXcgRXJyb3IoJ1xcXCJcIiArIG5hbWUgKyBcIlxcXCIgaXMgdW5kZWZpbmVkJyk7XFxuICAgICAgICByZXR1cm4gby5cIiArIG5hbWUgKyBcIi5hcHBseShvLCBhcmdzKTtcIjtcbiAgICAgICAgICAgIHJldHVybiAoKG5ldyBGdW5jdGlvbignbycsICdhcmdzJywgZnVuY3Rpb25Cb2R5KSkpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnByb3RvdHlwZS5pbXBvcnRVcmkgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgLy8gU3RhdGljU3ltYm9sXG4gICAgICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGVbJ2ZpbGVQYXRoJ10pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZVsnZmlsZVBhdGgnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJ1bnRpbWUgdHlwZVxuICAgICAgICAgICAgcmV0dXJuIFwiLi9cIiArIHN0cmluZ2lmeSh0eXBlKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAgICAgKiBAcGFyYW0gez99IG1vZHVsZVVybFxuICAgICAgICAgKiBAcGFyYW0gez99IHJ1bnRpbWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLnJlc29sdmVJZGVudGlmaWVyID0gZnVuY3Rpb24gKG5hbWUsIG1vZHVsZVVybCwgcnVudGltZSkgeyByZXR1cm4gcnVudGltZTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gZW51bUlkZW50aWZpZXJcbiAgICAgICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnByb3RvdHlwZS5yZXNvbHZlRW51bSA9IGZ1bmN0aW9uIChlbnVtSWRlbnRpZmllciwgbmFtZSkgeyByZXR1cm4gZW51bUlkZW50aWZpZXJbbmFtZV07IH07XG4gICAgICAgIHJldHVybiBSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkZWNvcmF0b3JJbnZvY2F0aW9uc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gY29udmVydFRzaWNrbGVEZWNvcmF0b3JJbnRvTWV0YWRhdGEoZGVjb3JhdG9ySW52b2NhdGlvbnMpIHtcbiAgICAgICAgaWYgKCFkZWNvcmF0b3JJbnZvY2F0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWNvcmF0b3JJbnZvY2F0aW9ucy5tYXAoZnVuY3Rpb24gKGRlY29yYXRvckludm9jYXRpb24pIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlY29yYXRvclR5cGUgPSBkZWNvcmF0b3JJbnZvY2F0aW9uLnR5cGU7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhbm5vdGF0aW9uQ2xzID0gZGVjb3JhdG9yVHlwZS5hbm5vdGF0aW9uQ2xzO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYW5ub3RhdGlvbkFyZ3MgPSBkZWNvcmF0b3JJbnZvY2F0aW9uLmFyZ3MgPyBkZWNvcmF0b3JJbnZvY2F0aW9uLmFyZ3MgOiBbXTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgKGFubm90YXRpb25DbHMuYmluZC5hcHBseShhbm5vdGF0aW9uQ2xzLCBbdm9pZCAwXS5jb25jYXQoYW5ub3RhdGlvbkFyZ3MpKSkoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY3RvclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0UGFyZW50Q3RvcihjdG9yKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcmVudFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGN0b3IucHJvdG90eXBlKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyZW50Q3RvciA9IHBhcmVudFByb3RvID8gcGFyZW50UHJvdG8uY29uc3RydWN0b3IgOiBudWxsO1xuICAgICAgICAvLyBOb3RlOiBXZSBhbHdheXMgdXNlIGBPYmplY3RgIGFzIHRoZSBudWxsIHZhbHVlXG4gICAgICAgIC8vIHRvIHNpbXBsaWZ5IGNoZWNraW5nIGxhdGVyIG9uLlxuICAgICAgICByZXR1cm4gcGFyZW50Q3RvciB8fCBPYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgcmVhZC1vbmx5IGFjY2VzcyB0byByZWZsZWN0aW9uIGRhdGEgYWJvdXQgc3ltYm9scy4gVXNlZCBpbnRlcm5hbGx5IGJ5IEFuZ3VsYXJcbiAgICAgKiB0byBwb3dlciBkZXBlbmRlbmN5IGluamVjdGlvbiBhbmQgY29tcGlsYXRpb24uXG4gICAgICogQGFic3RyYWN0XG4gICAgICovXG4gICAgdmFyIFJlZmxlY3RvclJlYWRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFJlZmxlY3RvclJlYWRlcigpIHtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqIEBwYXJhbSB7P30gdHlwZU9yRnVuY1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgUmVmbGVjdG9yUmVhZGVyLnByb3RvdHlwZS5wYXJhbWV0ZXJzID0gZnVuY3Rpb24gKHR5cGVPckZ1bmMpIHsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBhYnN0cmFjdFxuICAgICAgICAgKiBAcGFyYW0gez99IHR5cGVPckZ1bmNcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFJlZmxlY3RvclJlYWRlci5wcm90b3R5cGUuYW5ub3RhdGlvbnMgPSBmdW5jdGlvbiAodHlwZU9yRnVuYykgeyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqIEBwYXJhbSB7P30gdHlwZU9yRnVuY1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgUmVmbGVjdG9yUmVhZGVyLnByb3RvdHlwZS5wcm9wTWV0YWRhdGEgPSBmdW5jdGlvbiAodHlwZU9yRnVuYykgeyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqIEBwYXJhbSB7P30gdHlwZU9yRnVuY1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgUmVmbGVjdG9yUmVhZGVyLnByb3RvdHlwZS5pbXBvcnRVcmkgPSBmdW5jdGlvbiAodHlwZU9yRnVuYykgeyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAgICAgKiBAcGFyYW0gez99IG1vZHVsZVVybFxuICAgICAgICAgKiBAcGFyYW0gez99IHJ1bnRpbWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFJlZmxlY3RvclJlYWRlci5wcm90b3R5cGUucmVzb2x2ZUlkZW50aWZpZXIgPSBmdW5jdGlvbiAobmFtZSwgbW9kdWxlVXJsLCBydW50aW1lKSB7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAYWJzdHJhY3RcbiAgICAgICAgICogQHBhcmFtIHs/fSBpZGVudGlmaWVyXG4gICAgICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgUmVmbGVjdG9yUmVhZGVyLnByb3RvdHlwZS5yZXNvbHZlRW51bSA9IGZ1bmN0aW9uIChpZGVudGlmaWVyLCBuYW1lKSB7IH07XG4gICAgICAgIHJldHVybiBSZWZsZWN0b3JSZWFkZXI7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDIgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyBhY2Nlc3MgdG8gcmVmbGVjdGlvbiBkYXRhIGFib3V0IHN5bWJvbHMuIFVzZWQgaW50ZXJuYWxseSBieSBBbmd1bGFyXG4gICAgICogdG8gcG93ZXIgZGVwZW5kZW5jeSBpbmplY3Rpb24gYW5kIGNvbXBpbGF0aW9uLlxuICAgICAqL1xuICAgIHZhciBSZWZsZWN0b3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMihSZWZsZWN0b3IsIF9zdXBlcik7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHJlZmxlY3Rpb25DYXBhYmlsaXRpZXNcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIFJlZmxlY3RvcihyZWZsZWN0aW9uQ2FwYWJpbGl0aWVzKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMucmVmbGVjdGlvbkNhcGFiaWxpdGllcyA9IHJlZmxlY3Rpb25DYXBhYmlsaXRpZXM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gY2Fwc1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgUmVmbGVjdG9yLnByb3RvdHlwZS51cGRhdGVDYXBhYmlsaXRpZXMgPSBmdW5jdGlvbiAoY2FwcykgeyB0aGlzLnJlZmxlY3Rpb25DYXBhYmlsaXRpZXMgPSBjYXBzOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBSZWZsZWN0b3IucHJvdG90eXBlLmZhY3RvcnkgPSBmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gdGhpcy5yZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLmZhY3RvcnkodHlwZSk7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHR5cGVPckZ1bmNcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFJlZmxlY3Rvci5wcm90b3R5cGUucGFyYW1ldGVycyA9IGZ1bmN0aW9uICh0eXBlT3JGdW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnBhcmFtZXRlcnModHlwZU9yRnVuYyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHR5cGVPckZ1bmNcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFJlZmxlY3Rvci5wcm90b3R5cGUuYW5ub3RhdGlvbnMgPSBmdW5jdGlvbiAodHlwZU9yRnVuYykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVmbGVjdGlvbkNhcGFiaWxpdGllcy5hbm5vdGF0aW9ucyh0eXBlT3JGdW5jKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdHlwZU9yRnVuY1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgUmVmbGVjdG9yLnByb3RvdHlwZS5wcm9wTWV0YWRhdGEgPSBmdW5jdGlvbiAodHlwZU9yRnVuYykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVmbGVjdGlvbkNhcGFiaWxpdGllcy5wcm9wTWV0YWRhdGEodHlwZU9yRnVuYyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgICAgICogQHBhcmFtIHs/fSBsY1Byb3BlcnR5XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBSZWZsZWN0b3IucHJvdG90eXBlLmhhc0xpZmVjeWNsZUhvb2sgPSBmdW5jdGlvbiAodHlwZSwgbGNQcm9wZXJ0eSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVmbGVjdGlvbkNhcGFiaWxpdGllcy5oYXNMaWZlY3ljbGVIb29rKHR5cGUsIGxjUHJvcGVydHkpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBSZWZsZWN0b3IucHJvdG90eXBlLmdldHRlciA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiB0aGlzLnJlZmxlY3Rpb25DYXBhYmlsaXRpZXMuZ2V0dGVyKG5hbWUpOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBSZWZsZWN0b3IucHJvdG90eXBlLnNldHRlciA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiB0aGlzLnJlZmxlY3Rpb25DYXBhYmlsaXRpZXMuc2V0dGVyKG5hbWUpOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBSZWZsZWN0b3IucHJvdG90eXBlLm1ldGhvZCA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiB0aGlzLnJlZmxlY3Rpb25DYXBhYmlsaXRpZXMubWV0aG9kKG5hbWUpOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBSZWZsZWN0b3IucHJvdG90eXBlLmltcG9ydFVyaSA9IGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiB0aGlzLnJlZmxlY3Rpb25DYXBhYmlsaXRpZXMuaW1wb3J0VXJpKHR5cGUpOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICAgICAqIEBwYXJhbSB7P30gbW9kdWxlVXJsXG4gICAgICAgICAqIEBwYXJhbSB7P30gcnVudGltZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgUmVmbGVjdG9yLnByb3RvdHlwZS5yZXNvbHZlSWRlbnRpZmllciA9IGZ1bmN0aW9uIChuYW1lLCBtb2R1bGVVcmwsIHJ1bnRpbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZmxlY3Rpb25DYXBhYmlsaXRpZXMucmVzb2x2ZUlkZW50aWZpZXIobmFtZSwgbW9kdWxlVXJsLCBydW50aW1lKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gaWRlbnRpZmllclxuICAgICAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFJlZmxlY3Rvci5wcm90b3R5cGUucmVzb2x2ZUVudW0gPSBmdW5jdGlvbiAoaWRlbnRpZmllciwgbmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVmbGVjdGlvbkNhcGFiaWxpdGllcy5yZXNvbHZlRW51bShpZGVudGlmaWVyLCBuYW1lKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFJlZmxlY3RvcjtcbiAgICB9KFJlZmxlY3RvclJlYWRlcikpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHtAbGluayBSZWZsZWN0b3J9IHVzZWQgaW50ZXJuYWxseSBpbiBBbmd1bGFyIHRvIGFjY2VzcyBtZXRhZGF0YVxuICAgICAqIGFib3V0IHN5bWJvbHMuXG4gICAgICovXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVmbGVjdG9yID0gbmV3IFJlZmxlY3RvcihuZXcgUmVmbGVjdGlvbkNhcGFiaWxpdGllcygpKTtcblxuICAgIC8qKlxuICAgICAqIGBEZXBlbmRlbmN5YCBpcyB1c2VkIGJ5IHRoZSBmcmFtZXdvcmsgdG8gZXh0ZW5kIERJLlxuICAgICAqIFRoaXMgaXMgaW50ZXJuYWwgdG8gQW5ndWxhciBhbmQgc2hvdWxkIG5vdCBiZSB1c2VkIGRpcmVjdGx5LlxuICAgICAqL1xuICAgIHZhciBSZWZsZWN0aXZlRGVwZW5kZW5jeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGtleVxuICAgICAgICAgKiBAcGFyYW0gez99IG9wdGlvbmFsXG4gICAgICAgICAqIEBwYXJhbSB7P30gbG93ZXJCb3VuZFZpc2liaWxpdHlcbiAgICAgICAgICogQHBhcmFtIHs/fSB1cHBlckJvdW5kVmlzaWJpbGl0eVxuICAgICAgICAgKiBAcGFyYW0gez99IHByb3BlcnRpZXNcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIFJlZmxlY3RpdmVEZXBlbmRlbmN5KGtleSwgb3B0aW9uYWwsIGxvd2VyQm91bmRWaXNpYmlsaXR5LCB1cHBlckJvdW5kVmlzaWJpbGl0eSwgcHJvcGVydGllcykge1xuICAgICAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbmFsID0gb3B0aW9uYWw7XG4gICAgICAgICAgICB0aGlzLmxvd2VyQm91bmRWaXNpYmlsaXR5ID0gbG93ZXJCb3VuZFZpc2liaWxpdHk7XG4gICAgICAgICAgICB0aGlzLnVwcGVyQm91bmRWaXNpYmlsaXR5ID0gdXBwZXJCb3VuZFZpc2liaWxpdHk7XG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGtleVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgUmVmbGVjdGl2ZURlcGVuZGVuY3kuZnJvbUtleSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVmbGVjdGl2ZURlcGVuZGVuY3koa2V5LCBmYWxzZSwgbnVsbCwgbnVsbCwgW10pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUmVmbGVjdGl2ZURlcGVuZGVuY3k7XG4gICAgfSgpKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBfRU1QVFlfTElTVCA9IFtdO1xuICAgIHZhciBSZXNvbHZlZFJlZmxlY3RpdmVQcm92aWRlcl8gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBrZXlcbiAgICAgICAgICogQHBhcmFtIHs/fSByZXNvbHZlZEZhY3Rvcmllc1xuICAgICAgICAgKiBAcGFyYW0gez99IG11bHRpUHJvdmlkZXJcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIFJlc29sdmVkUmVmbGVjdGl2ZVByb3ZpZGVyXyhrZXksIHJlc29sdmVkRmFjdG9yaWVzLCBtdWx0aVByb3ZpZGVyKSB7XG4gICAgICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZWRGYWN0b3JpZXMgPSByZXNvbHZlZEZhY3RvcmllcztcbiAgICAgICAgICAgIHRoaXMubXVsdGlQcm92aWRlciA9IG11bHRpUHJvdmlkZXI7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlc29sdmVkUmVmbGVjdGl2ZVByb3ZpZGVyXy5wcm90b3R5cGUsIFwicmVzb2x2ZWRGYWN0b3J5XCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnJlc29sdmVkRmFjdG9yaWVzWzBdOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFJlc29sdmVkUmVmbGVjdGl2ZVByb3ZpZGVyXztcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIEFuIGludGVybmFsIHJlc29sdmVkIHJlcHJlc2VudGF0aW9uIG9mIGEgZmFjdG9yeSBmdW5jdGlvbiBjcmVhdGVkIGJ5IHJlc29sdmluZyB7XFxAbGlua1xuICAgICAqIFByb3ZpZGVyfS5cbiAgICAgKiBcXEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgUmVzb2x2ZWRSZWZsZWN0aXZlRmFjdG9yeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGZhY3RvcnlcbiAgICAgICAgICogQHBhcmFtIHs/fSBkZXBlbmRlbmNpZXNcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIFJlc29sdmVkUmVmbGVjdGl2ZUZhY3RvcnkoZmFjdG9yeSwgZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgICB0aGlzLmZhY3RvcnkgPSBmYWN0b3J5O1xuICAgICAgICAgICAgdGhpcy5kZXBlbmRlbmNpZXMgPSBkZXBlbmRlbmNpZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFJlc29sdmVkUmVmbGVjdGl2ZUZhY3Rvcnk7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBSZXNvbHZlIGEgc2luZ2xlIHByb3ZpZGVyLlxuICAgICAqIEBwYXJhbSB7P30gcHJvdmlkZXJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc29sdmVSZWZsZWN0aXZlRmFjdG9yeShwcm92aWRlcikge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmYWN0b3J5Rm47XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc29sdmVkRGVwcztcbiAgICAgICAgaWYgKHByb3ZpZGVyLnVzZUNsYXNzKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB1c2VDbGFzcyA9IHJlc29sdmVGb3J3YXJkUmVmKHByb3ZpZGVyLnVzZUNsYXNzKTtcbiAgICAgICAgICAgIGZhY3RvcnlGbiA9IHJlZmxlY3Rvci5mYWN0b3J5KHVzZUNsYXNzKTtcbiAgICAgICAgICAgIHJlc29sdmVkRGVwcyA9IF9kZXBlbmRlbmNpZXNGb3IodXNlQ2xhc3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb3ZpZGVyLnVzZUV4aXN0aW5nKSB7XG4gICAgICAgICAgICBmYWN0b3J5Rm4gPSBmdW5jdGlvbiAoYWxpYXNJbnN0YW5jZSkgeyByZXR1cm4gYWxpYXNJbnN0YW5jZTsgfTtcbiAgICAgICAgICAgIHJlc29sdmVkRGVwcyA9IFtSZWZsZWN0aXZlRGVwZW5kZW5jeS5mcm9tS2V5KFJlZmxlY3RpdmVLZXkuZ2V0KHByb3ZpZGVyLnVzZUV4aXN0aW5nKSldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb3ZpZGVyLnVzZUZhY3RvcnkpIHtcbiAgICAgICAgICAgIGZhY3RvcnlGbiA9IHByb3ZpZGVyLnVzZUZhY3Rvcnk7XG4gICAgICAgICAgICByZXNvbHZlZERlcHMgPSBjb25zdHJ1Y3REZXBlbmRlbmNpZXMocHJvdmlkZXIudXNlRmFjdG9yeSwgcHJvdmlkZXIuZGVwcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmYWN0b3J5Rm4gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm92aWRlci51c2VWYWx1ZTsgfTtcbiAgICAgICAgICAgIHJlc29sdmVkRGVwcyA9IF9FTVBUWV9MSVNUO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUmVzb2x2ZWRSZWZsZWN0aXZlRmFjdG9yeShmYWN0b3J5Rm4sIHJlc29sdmVkRGVwcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSB7XFxAbGluayBQcm92aWRlcn0gaW50byB7XFxAbGluayBSZXNvbHZlZFByb3ZpZGVyfS5cbiAgICAgKlxuICAgICAqIHtcXEBsaW5rIEluamVjdG9yfSBpbnRlcm5hbGx5IG9ubHkgdXNlcyB7XFxAbGluayBSZXNvbHZlZFByb3ZpZGVyfSwge1xcQGxpbmsgUHJvdmlkZXJ9IGNvbnRhaW5zXG4gICAgICogY29udmVuaWVuY2UgcHJvdmlkZXIgc3ludGF4LlxuICAgICAqIEBwYXJhbSB7P30gcHJvdmlkZXJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc29sdmVSZWZsZWN0aXZlUHJvdmlkZXIocHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXNvbHZlZFJlZmxlY3RpdmVQcm92aWRlcl8oUmVmbGVjdGl2ZUtleS5nZXQocHJvdmlkZXIucHJvdmlkZSksIFtyZXNvbHZlUmVmbGVjdGl2ZUZhY3RvcnkocHJvdmlkZXIpXSwgcHJvdmlkZXIubXVsdGkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlIGEgbGlzdCBvZiBQcm92aWRlcnMuXG4gICAgICogQHBhcmFtIHs/fSBwcm92aWRlcnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc29sdmVSZWZsZWN0aXZlUHJvdmlkZXJzKHByb3ZpZGVycykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBub3JtYWxpemVkID0gX25vcm1hbGl6ZVByb3ZpZGVycyhwcm92aWRlcnMsIFtdKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzb2x2ZWQgPSBub3JtYWxpemVkLm1hcChyZXNvbHZlUmVmbGVjdGl2ZVByb3ZpZGVyKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzb2x2ZWRQcm92aWRlck1hcCA9IG1lcmdlUmVzb2x2ZWRSZWZsZWN0aXZlUHJvdmlkZXJzKHJlc29sdmVkLCBuZXcgTWFwKCkpO1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShyZXNvbHZlZFByb3ZpZGVyTWFwLnZhbHVlcygpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWVyZ2VzIGEgbGlzdCBvZiBSZXNvbHZlZFByb3ZpZGVycyBpbnRvIGEgbGlzdCB3aGVyZVxuICAgICAqIGVhY2gga2V5IGlzIGNvbnRhaW5lZCBleGFjdGx5IG9uY2UgYW5kIG11bHRpIHByb3ZpZGVyc1xuICAgICAqIGhhdmUgYmVlbiBtZXJnZWQuXG4gICAgICogQHBhcmFtIHs/fSBwcm92aWRlcnNcbiAgICAgKiBAcGFyYW0gez99IG5vcm1hbGl6ZWRQcm92aWRlcnNNYXBcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lcmdlUmVzb2x2ZWRSZWZsZWN0aXZlUHJvdmlkZXJzKHByb3ZpZGVycywgbm9ybWFsaXplZFByb3ZpZGVyc01hcCkge1xuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgcHJvdmlkZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm92aWRlciA9IHByb3ZpZGVyc1tpXTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4aXN0aW5nID0gbm9ybWFsaXplZFByb3ZpZGVyc01hcC5nZXQocHJvdmlkZXIua2V5LmlkKTtcbiAgICAgICAgICAgIGlmIChleGlzdGluZykge1xuICAgICAgICAgICAgICAgIGlmIChwcm92aWRlci5tdWx0aVByb3ZpZGVyICE9PSBleGlzdGluZy5tdWx0aVByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBNaXhpbmdNdWx0aVByb3ZpZGVyc1dpdGhSZWd1bGFyUHJvdmlkZXJzRXJyb3IoZXhpc3RpbmcsIHByb3ZpZGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByb3ZpZGVyLm11bHRpUHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBqID0gMDsgaiA8IHByb3ZpZGVyLnJlc29sdmVkRmFjdG9yaWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5yZXNvbHZlZEZhY3Rvcmllcy5wdXNoKHByb3ZpZGVyLnJlc29sdmVkRmFjdG9yaWVzW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZFByb3ZpZGVyc01hcC5zZXQocHJvdmlkZXIua2V5LmlkLCBwcm92aWRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzb2x2ZWRQcm92aWRlciA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBpZiAocHJvdmlkZXIubXVsdGlQcm92aWRlcikge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlZFByb3ZpZGVyID0gbmV3IFJlc29sdmVkUmVmbGVjdGl2ZVByb3ZpZGVyXyhwcm92aWRlci5rZXksIHByb3ZpZGVyLnJlc29sdmVkRmFjdG9yaWVzLnNsaWNlKCksIHByb3ZpZGVyLm11bHRpUHJvdmlkZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRQcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub3JtYWxpemVkUHJvdmlkZXJzTWFwLnNldChwcm92aWRlci5rZXkuaWQsIHJlc29sdmVkUHJvdmlkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub3JtYWxpemVkUHJvdmlkZXJzTWFwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHByb3ZpZGVyc1xuICAgICAqIEBwYXJhbSB7P30gcmVzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfbm9ybWFsaXplUHJvdmlkZXJzKHByb3ZpZGVycywgcmVzKSB7XG4gICAgICAgIHByb3ZpZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgICBpZiAoYiBpbnN0YW5jZW9mIFR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXMucHVzaCh7IHByb3ZpZGU6IGIsIHVzZUNsYXNzOiBiIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYiAmJiB0eXBlb2YgYiA9PSAnb2JqZWN0JyAmJiAoKGIpKS5wcm92aWRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXMucHVzaCgvKiogQHR5cGUgez99ICovIChiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBfbm9ybWFsaXplUHJvdmlkZXJzKGIsIHJlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFByb3ZpZGVyRXJyb3IoYik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVPckZ1bmNcbiAgICAgKiBAcGFyYW0gez99IGRlcGVuZGVuY2llc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uc3RydWN0RGVwZW5kZW5jaWVzKHR5cGVPckZ1bmMsIGRlcGVuZGVuY2llcykge1xuICAgICAgICBpZiAoIWRlcGVuZGVuY2llcykge1xuICAgICAgICAgICAgcmV0dXJuIF9kZXBlbmRlbmNpZXNGb3IodHlwZU9yRnVuYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJhbXNfMSA9IGRlcGVuZGVuY2llcy5tYXAoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIFt0XTsgfSk7XG4gICAgICAgICAgICByZXR1cm4gZGVwZW5kZW5jaWVzLm1hcChmdW5jdGlvbiAodCkgeyByZXR1cm4gX2V4dHJhY3RUb2tlbih0eXBlT3JGdW5jLCB0LCBwYXJhbXNfMSk7IH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZU9yRnVuY1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gX2RlcGVuZGVuY2llc0Zvcih0eXBlT3JGdW5jKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcmFtcyA9IHJlZmxlY3Rvci5wYXJhbWV0ZXJzKHR5cGVPckZ1bmMpO1xuICAgICAgICBpZiAoIXBhcmFtcylcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgaWYgKHBhcmFtcy5zb21lKGZ1bmN0aW9uIChwKSB7IHJldHVybiBwID09IG51bGw7IH0pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTm9Bbm5vdGF0aW9uRXJyb3IodHlwZU9yRnVuYywgcGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyYW1zLm1hcChmdW5jdGlvbiAocCkgeyByZXR1cm4gX2V4dHJhY3RUb2tlbih0eXBlT3JGdW5jLCBwLCBwYXJhbXMpOyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0eXBlT3JGdW5jXG4gICAgICogQHBhcmFtIHs/fSBtZXRhZGF0YVxuICAgICAqIEBwYXJhbSB7P30gcGFyYW1zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfZXh0cmFjdFRva2VuKHR5cGVPckZ1bmMsIG1ldGFkYXRhLCBwYXJhbXMpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVwUHJvcHMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdG9rZW4gPSBudWxsO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvcHRpb25hbCA9IGZhbHNlO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWV0YWRhdGEpKSB7XG4gICAgICAgICAgICBpZiAobWV0YWRhdGEgaW5zdGFuY2VvZiBJbmplY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NyZWF0ZURlcGVuZGVuY3kobWV0YWRhdGEudG9rZW4sIG9wdGlvbmFsLCBudWxsLCBudWxsLCBkZXBQcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NyZWF0ZURlcGVuZGVuY3kobWV0YWRhdGEsIG9wdGlvbmFsLCBudWxsLCBudWxsLCBkZXBQcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbG93ZXJCb3VuZFZpc2liaWxpdHkgPSBudWxsO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB1cHBlckJvdW5kVmlzaWJpbGl0eSA9IG51bGw7XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBtZXRhZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyYW1NZXRhZGF0YSA9IG1ldGFkYXRhW2ldO1xuICAgICAgICAgICAgaWYgKHBhcmFtTWV0YWRhdGEgaW5zdGFuY2VvZiBUeXBlKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4gPSBwYXJhbU1ldGFkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyYW1NZXRhZGF0YSBpbnN0YW5jZW9mIEluamVjdCkge1xuICAgICAgICAgICAgICAgIHRva2VuID0gcGFyYW1NZXRhZGF0YS50b2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtTWV0YWRhdGEgaW5zdGFuY2VvZiBPcHRpb25hbCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbmFsID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtTWV0YWRhdGEgaW5zdGFuY2VvZiBTZWxmKSB7XG4gICAgICAgICAgICAgICAgdXBwZXJCb3VuZFZpc2liaWxpdHkgPSBwYXJhbU1ldGFkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyYW1NZXRhZGF0YSBpbnN0YW5jZW9mIEhvc3QpIHtcbiAgICAgICAgICAgICAgICB1cHBlckJvdW5kVmlzaWJpbGl0eSA9IHBhcmFtTWV0YWRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJhbU1ldGFkYXRhIGluc3RhbmNlb2YgU2tpcFNlbGYpIHtcbiAgICAgICAgICAgICAgICBsb3dlckJvdW5kVmlzaWJpbGl0eSA9IHBhcmFtTWV0YWRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdG9rZW4gPSByZXNvbHZlRm9yd2FyZFJlZih0b2tlbik7XG4gICAgICAgIGlmICh0b2tlbiAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gX2NyZWF0ZURlcGVuZGVuY3kodG9rZW4sIG9wdGlvbmFsLCBsb3dlckJvdW5kVmlzaWJpbGl0eSwgdXBwZXJCb3VuZFZpc2liaWxpdHksIGRlcFByb3BzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOb0Fubm90YXRpb25FcnJvcih0eXBlT3JGdW5jLCBwYXJhbXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdG9rZW5cbiAgICAgKiBAcGFyYW0gez99IG9wdGlvbmFsXG4gICAgICogQHBhcmFtIHs/fSBsb3dlckJvdW5kVmlzaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7P30gdXBwZXJCb3VuZFZpc2liaWxpdHlcbiAgICAgKiBAcGFyYW0gez99IGRlcFByb3BzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfY3JlYXRlRGVwZW5kZW5jeSh0b2tlbiwgb3B0aW9uYWwsIGxvd2VyQm91bmRWaXNpYmlsaXR5LCB1cHBlckJvdW5kVmlzaWJpbGl0eSwgZGVwUHJvcHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWZsZWN0aXZlRGVwZW5kZW5jeShSZWZsZWN0aXZlS2V5LmdldCh0b2tlbiksIG9wdGlvbmFsLCBsb3dlckJvdW5kVmlzaWJpbGl0eSwgdXBwZXJCb3VuZFZpc2liaWxpdHksIGRlcFByb3BzKTtcbiAgICB9XG5cbiAgICAvLyBUaHJlc2hvbGQgZm9yIHRoZSBkeW5hbWljIHZlcnNpb25cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBfTUFYX0NPTlNUUlVDVElPTl9DT1VOVEVSID0gMTA7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gVU5ERUZJTkVEID0gbmV3IE9iamVjdCgpO1xuICAgIHZhciBSZWZsZWN0aXZlUHJvdG9JbmplY3RvcklubGluZVN0cmF0ZWd5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gcHJvdG9FSVxuICAgICAgICAgKiBAcGFyYW0gez99IHByb3ZpZGVyc1xuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gUmVmbGVjdGl2ZVByb3RvSW5qZWN0b3JJbmxpbmVTdHJhdGVneShwcm90b0VJLCBwcm92aWRlcnMpIHtcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXIwID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXIxID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXIyID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXIzID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXI0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXI1ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXI2ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXI3ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXI4ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXI5ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMua2V5SWQwID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMua2V5SWQxID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMua2V5SWQyID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMua2V5SWQzID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMua2V5SWQ0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMua2V5SWQ1ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMua2V5SWQ2ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMua2V5SWQ3ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMua2V5SWQ4ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMua2V5SWQ5ID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBwcm92aWRlcnMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3ZpZGVyMCA9IHByb3ZpZGVyc1swXTtcbiAgICAgICAgICAgICAgICB0aGlzLmtleUlkMCA9IHByb3ZpZGVyc1swXS5rZXkuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvdmlkZXIxID0gcHJvdmlkZXJzWzFdO1xuICAgICAgICAgICAgICAgIHRoaXMua2V5SWQxID0gcHJvdmlkZXJzWzFdLmtleS5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlcjIgPSBwcm92aWRlcnNbMl07XG4gICAgICAgICAgICAgICAgdGhpcy5rZXlJZDIgPSBwcm92aWRlcnNbMl0ua2V5LmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlbmd0aCA+IDMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3ZpZGVyMyA9IHByb3ZpZGVyc1szXTtcbiAgICAgICAgICAgICAgICB0aGlzLmtleUlkMyA9IHByb3ZpZGVyc1szXS5rZXkuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGVuZ3RoID4gNCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvdmlkZXI0ID0gcHJvdmlkZXJzWzRdO1xuICAgICAgICAgICAgICAgIHRoaXMua2V5SWQ0ID0gcHJvdmlkZXJzWzRdLmtleS5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZW5ndGggPiA1KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlcjUgPSBwcm92aWRlcnNbNV07XG4gICAgICAgICAgICAgICAgdGhpcy5rZXlJZDUgPSBwcm92aWRlcnNbNV0ua2V5LmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlbmd0aCA+IDYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3ZpZGVyNiA9IHByb3ZpZGVyc1s2XTtcbiAgICAgICAgICAgICAgICB0aGlzLmtleUlkNiA9IHByb3ZpZGVyc1s2XS5rZXkuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGVuZ3RoID4gNykge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvdmlkZXI3ID0gcHJvdmlkZXJzWzddO1xuICAgICAgICAgICAgICAgIHRoaXMua2V5SWQ3ID0gcHJvdmlkZXJzWzddLmtleS5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZW5ndGggPiA4KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlcjggPSBwcm92aWRlcnNbOF07XG4gICAgICAgICAgICAgICAgdGhpcy5rZXlJZDggPSBwcm92aWRlcnNbOF0ua2V5LmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlbmd0aCA+IDkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3ZpZGVyOSA9IHByb3ZpZGVyc1s5XTtcbiAgICAgICAgICAgICAgICB0aGlzLmtleUlkOSA9IHByb3ZpZGVyc1s5XS5rZXkuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gaW5kZXhcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFJlZmxlY3RpdmVQcm90b0luamVjdG9ySW5saW5lU3RyYXRlZ3kucHJvdG90eXBlLmdldFByb3ZpZGVyQXRJbmRleCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIwO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIxO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IDIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIyO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IDMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIzO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IDQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXI0O1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IDUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXI1O1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IDYpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXI2O1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IDcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXI3O1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IDgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXI4O1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IDkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXI5O1xuICAgICAgICAgICAgdGhyb3cgbmV3IE91dE9mQm91bmRzRXJyb3IoaW5kZXgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBpbmplY3RvclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgUmVmbGVjdGl2ZVByb3RvSW5qZWN0b3JJbmxpbmVTdHJhdGVneS5wcm90b3R5cGUuY3JlYXRlSW5qZWN0b3JTdHJhdGVneSA9IGZ1bmN0aW9uIChpbmplY3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWZsZWN0aXZlSW5qZWN0b3JJbmxpbmVTdHJhdGVneShpbmplY3RvciwgdGhpcyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBSZWZsZWN0aXZlUHJvdG9JbmplY3RvcklubGluZVN0cmF0ZWd5O1xuICAgIH0oKSk7XG4gICAgdmFyIFJlZmxlY3RpdmVQcm90b0luamVjdG9yRHluYW1pY1N0cmF0ZWd5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gcHJvdG9JbmpcbiAgICAgICAgICogQHBhcmFtIHs/fSBwcm92aWRlcnNcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIFJlZmxlY3RpdmVQcm90b0luamVjdG9yRHluYW1pY1N0cmF0ZWd5KHByb3RvSW5qLCBwcm92aWRlcnMpIHtcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXJzID0gcHJvdmlkZXJzO1xuICAgICAgICAgICAgdmFyIGxlbiA9IHByb3ZpZGVycy5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLmtleUlkcyA9IG5ldyBBcnJheShsZW4pO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMua2V5SWRzW2ldID0gcHJvdmlkZXJzW2ldLmtleS5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBpbmRleFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgUmVmbGVjdGl2ZVByb3RvSW5qZWN0b3JEeW5hbWljU3RyYXRlZ3kucHJvdG90eXBlLmdldFByb3ZpZGVyQXRJbmRleCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLnByb3ZpZGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgT3V0T2ZCb3VuZHNFcnJvcihpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlcnNbaW5kZXhdO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBlaVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgUmVmbGVjdGl2ZVByb3RvSW5qZWN0b3JEeW5hbWljU3RyYXRlZ3kucHJvdG90eXBlLmNyZWF0ZUluamVjdG9yU3RyYXRlZ3kgPSBmdW5jdGlvbiAoZWkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVmbGVjdGl2ZUluamVjdG9yRHluYW1pY1N0cmF0ZWd5KHRoaXMsIGVpKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFJlZmxlY3RpdmVQcm90b0luamVjdG9yRHluYW1pY1N0cmF0ZWd5O1xuICAgIH0oKSk7XG4gICAgdmFyIFJlZmxlY3RpdmVQcm90b0luamVjdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gcHJvdmlkZXJzXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBSZWZsZWN0aXZlUHJvdG9JbmplY3Rvcihwcm92aWRlcnMpIHtcbiAgICAgICAgICAgIHRoaXMubnVtYmVyT2ZQcm92aWRlcnMgPSBwcm92aWRlcnMubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5fc3RyYXRlZ3kgPSBwcm92aWRlcnMubGVuZ3RoID4gX01BWF9DT05TVFJVQ1RJT05fQ09VTlRFUiA/XG4gICAgICAgICAgICAgICAgbmV3IFJlZmxlY3RpdmVQcm90b0luamVjdG9yRHluYW1pY1N0cmF0ZWd5KHRoaXMsIHByb3ZpZGVycykgOlxuICAgICAgICAgICAgICAgIG5ldyBSZWZsZWN0aXZlUHJvdG9JbmplY3RvcklubGluZVN0cmF0ZWd5KHRoaXMsIHByb3ZpZGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gcHJvdmlkZXJzXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBSZWZsZWN0aXZlUHJvdG9JbmplY3Rvci5mcm9tUmVzb2x2ZWRQcm92aWRlcnMgPSBmdW5jdGlvbiAocHJvdmlkZXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZmxlY3RpdmVQcm90b0luamVjdG9yKHByb3ZpZGVycyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGluZGV4XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBSZWZsZWN0aXZlUHJvdG9JbmplY3Rvci5wcm90b3R5cGUuZ2V0UHJvdmlkZXJBdEluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RyYXRlZ3kuZ2V0UHJvdmlkZXJBdEluZGV4KGluZGV4KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFJlZmxlY3RpdmVQcm90b0luamVjdG9yO1xuICAgIH0oKSk7XG4gICAgdmFyIFJlZmxlY3RpdmVJbmplY3RvcklubGluZVN0cmF0ZWd5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gaW5qZWN0b3JcbiAgICAgICAgICogQHBhcmFtIHs/fSBwcm90b1N0cmF0ZWd5XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBSZWZsZWN0aXZlSW5qZWN0b3JJbmxpbmVTdHJhdGVneShpbmplY3RvciwgcHJvdG9TdHJhdGVneSkge1xuICAgICAgICAgICAgdGhpcy5pbmplY3RvciA9IGluamVjdG9yO1xuICAgICAgICAgICAgdGhpcy5wcm90b1N0cmF0ZWd5ID0gcHJvdG9TdHJhdGVneTtcbiAgICAgICAgICAgIHRoaXMub2JqMCA9IFVOREVGSU5FRDtcbiAgICAgICAgICAgIHRoaXMub2JqMSA9IFVOREVGSU5FRDtcbiAgICAgICAgICAgIHRoaXMub2JqMiA9IFVOREVGSU5FRDtcbiAgICAgICAgICAgIHRoaXMub2JqMyA9IFVOREVGSU5FRDtcbiAgICAgICAgICAgIHRoaXMub2JqNCA9IFVOREVGSU5FRDtcbiAgICAgICAgICAgIHRoaXMub2JqNSA9IFVOREVGSU5FRDtcbiAgICAgICAgICAgIHRoaXMub2JqNiA9IFVOREVGSU5FRDtcbiAgICAgICAgICAgIHRoaXMub2JqNyA9IFVOREVGSU5FRDtcbiAgICAgICAgICAgIHRoaXMub2JqOCA9IFVOREVGSU5FRDtcbiAgICAgICAgICAgIHRoaXMub2JqOSA9IFVOREVGSU5FRDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFJlZmxlY3RpdmVJbmplY3RvcklubGluZVN0cmF0ZWd5LnByb3RvdHlwZS5yZXNldENvbnN0cnVjdGlvbkNvdW50ZXIgPSBmdW5jdGlvbiAoKSB7IHRoaXMuaW5qZWN0b3IuX2NvbnN0cnVjdGlvbkNvdW50ZXIgPSAwOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBwcm92aWRlclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgUmVmbGVjdGl2ZUluamVjdG9ySW5saW5lU3RyYXRlZ3kucHJvdG90eXBlLmluc3RhbnRpYXRlUHJvdmlkZXIgPSBmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluamVjdG9yLl9uZXcocHJvdmlkZXIpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBrZXlJZFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgUmVmbGVjdGl2ZUluamVjdG9ySW5saW5lU3RyYXRlZ3kucHJvdG90eXBlLmdldE9iakJ5S2V5SWQgPSBmdW5jdGlvbiAoa2V5SWQpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHAgPSB0aGlzLnByb3RvU3RyYXRlZ3k7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbmogPSB0aGlzLmluamVjdG9yO1xuICAgICAgICAgICAgaWYgKHAua2V5SWQwID09PSBrZXlJZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9iajAgPT09IFVOREVGSU5FRCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9iajAgPSBpbmouX25ldyhwLnByb3ZpZGVyMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9iajA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocC5rZXlJZDEgPT09IGtleUlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub2JqMSA9PT0gVU5ERUZJTkVEKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2JqMSA9IGluai5fbmV3KHAucHJvdmlkZXIxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwLmtleUlkMiA9PT0ga2V5SWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vYmoyID09PSBVTkRFRklORUQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vYmoyID0gaW5qLl9uZXcocC5wcm92aWRlcjIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vYmoyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHAua2V5SWQzID09PSBrZXlJZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9iajMgPT09IFVOREVGSU5FRCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9iajMgPSBpbmouX25ldyhwLnByb3ZpZGVyMyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9iajM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocC5rZXlJZDQgPT09IGtleUlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub2JqNCA9PT0gVU5ERUZJTkVEKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2JqNCA9IGluai5fbmV3KHAucHJvdmlkZXI0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwLmtleUlkNSA9PT0ga2V5SWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vYmo1ID09PSBVTkRFRklORUQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vYmo1ID0gaW5qLl9uZXcocC5wcm92aWRlcjUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vYmo1O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHAua2V5SWQ2ID09PSBrZXlJZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9iajYgPT09IFVOREVGSU5FRCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9iajYgPSBpbmouX25ldyhwLnByb3ZpZGVyNik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9iajY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocC5rZXlJZDcgPT09IGtleUlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub2JqNyA9PT0gVU5ERUZJTkVEKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2JqNyA9IGluai5fbmV3KHAucHJvdmlkZXI3KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqNztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwLmtleUlkOCA9PT0ga2V5SWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vYmo4ID09PSBVTkRFRklORUQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vYmo4ID0gaW5qLl9uZXcocC5wcm92aWRlcjgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vYmo4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHAua2V5SWQ5ID09PSBrZXlJZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9iajkgPT09IFVOREVGSU5FRCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9iajkgPSBpbmouX25ldyhwLnByb3ZpZGVyOSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9iajk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gVU5ERUZJTkVEO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBpbmRleFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgUmVmbGVjdGl2ZUluamVjdG9ySW5saW5lU3RyYXRlZ3kucHJvdG90eXBlLmdldE9iakF0SW5kZXggPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9iajA7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vYmoxO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IDIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqMjtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PSAzKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9iajM7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT0gNClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vYmo0O1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IDUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqNTtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PSA2KVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9iajY7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT0gNylcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vYmo3O1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IDgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqODtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PSA5KVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9iajk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT3V0T2ZCb3VuZHNFcnJvcihpbmRleCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgUmVmbGVjdGl2ZUluamVjdG9ySW5saW5lU3RyYXRlZ3kucHJvdG90eXBlLmdldE1heE51bWJlck9mT2JqZWN0cyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9NQVhfQ09OU1RSVUNUSU9OX0NPVU5URVI7IH07XG4gICAgICAgIHJldHVybiBSZWZsZWN0aXZlSW5qZWN0b3JJbmxpbmVTdHJhdGVneTtcbiAgICB9KCkpO1xuICAgIHZhciBSZWZsZWN0aXZlSW5qZWN0b3JEeW5hbWljU3RyYXRlZ3kgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBwcm90b1N0cmF0ZWd5XG4gICAgICAgICAqIEBwYXJhbSB7P30gaW5qZWN0b3JcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIFJlZmxlY3RpdmVJbmplY3RvckR5bmFtaWNTdHJhdGVneShwcm90b1N0cmF0ZWd5LCBpbmplY3Rvcikge1xuICAgICAgICAgICAgdGhpcy5wcm90b1N0cmF0ZWd5ID0gcHJvdG9TdHJhdGVneTtcbiAgICAgICAgICAgIHRoaXMuaW5qZWN0b3IgPSBpbmplY3RvcjtcbiAgICAgICAgICAgIHRoaXMub2JqcyA9IG5ldyBBcnJheShwcm90b1N0cmF0ZWd5LnByb3ZpZGVycy5sZW5ndGgpLmZpbGwoVU5ERUZJTkVEKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFJlZmxlY3RpdmVJbmplY3RvckR5bmFtaWNTdHJhdGVneS5wcm90b3R5cGUucmVzZXRDb25zdHJ1Y3Rpb25Db3VudGVyID0gZnVuY3Rpb24gKCkgeyB0aGlzLmluamVjdG9yLl9jb25zdHJ1Y3Rpb25Db3VudGVyID0gMDsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gcHJvdmlkZXJcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFJlZmxlY3RpdmVJbmplY3RvckR5bmFtaWNTdHJhdGVneS5wcm90b3R5cGUuaW5zdGFudGlhdGVQcm92aWRlciA9IGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5qZWN0b3IuX25ldyhwcm92aWRlcik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGtleUlkXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBSZWZsZWN0aXZlSW5qZWN0b3JEeW5hbWljU3RyYXRlZ3kucHJvdG90eXBlLmdldE9iakJ5S2V5SWQgPSBmdW5jdGlvbiAoa2V5SWQpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHAgPSB0aGlzLnByb3RvU3RyYXRlZ3k7XG4gICAgICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgcC5rZXlJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAocC5rZXlJZHNbaV0gPT09IGtleUlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9ianNbaV0gPT09IFVOREVGSU5FRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vYmpzW2ldID0gdGhpcy5pbmplY3Rvci5fbmV3KHAucHJvdmlkZXJzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vYmpzW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBVTkRFRklORUQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGluZGV4XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBSZWZsZWN0aXZlSW5qZWN0b3JEeW5hbWljU3RyYXRlZ3kucHJvdG90eXBlLmdldE9iakF0SW5kZXggPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5vYmpzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBPdXRPZkJvdW5kc0Vycm9yKGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9ianNbaW5kZXhdO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFJlZmxlY3RpdmVJbmplY3RvckR5bmFtaWNTdHJhdGVneS5wcm90b3R5cGUuZ2V0TWF4TnVtYmVyT2ZPYmplY3RzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5vYmpzLmxlbmd0aDsgfTtcbiAgICAgICAgcmV0dXJuIFJlZmxlY3RpdmVJbmplY3RvckR5bmFtaWNTdHJhdGVneTtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIEEgUmVmbGVjdGl2ZURlcGVuZGVuY3kgaW5qZWN0aW9uIGNvbnRhaW5lciB1c2VkIGZvciBpbnN0YW50aWF0aW5nIG9iamVjdHMgYW5kIHJlc29sdmluZ1xuICAgICAqIGRlcGVuZGVuY2llcy5cbiAgICAgKlxuICAgICAqIEFuIGBJbmplY3RvcmAgaXMgYSByZXBsYWNlbWVudCBmb3IgYSBgbmV3YCBvcGVyYXRvciwgd2hpY2ggY2FuIGF1dG9tYXRpY2FsbHkgcmVzb2x2ZSB0aGVcbiAgICAgKiBjb25zdHJ1Y3RvciBkZXBlbmRlbmNpZXMuXG4gICAgICpcbiAgICAgKiBJbiB0eXBpY2FsIHVzZSwgYXBwbGljYXRpb24gY29kZSBhc2tzIGZvciB0aGUgZGVwZW5kZW5jaWVzIGluIHRoZSBjb25zdHJ1Y3RvciBhbmQgdGhleSBhcmVcbiAgICAgKiByZXNvbHZlZCBieSB0aGUgYEluamVjdG9yYC5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9qemplYzA/cD1wcmV2aWV3KSlcbiAgICAgKlxuICAgICAqIFRoZSBmb2xsb3dpbmcgZXhhbXBsZSBjcmVhdGVzIGFuIGBJbmplY3RvcmAgY29uZmlndXJlZCB0byBjcmVhdGUgYEVuZ2luZWAgYW5kIGBDYXJgLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIFxcQEluamVjdGFibGUoKVxuICAgICAqIGNsYXNzIEVuZ2luZSB7XG4gICAgICogfVxuICAgICAqXG4gICAgICogXFxASW5qZWN0YWJsZSgpXG4gICAgICogY2xhc3MgQ2FyIHtcbiAgICAgKiAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbmdpbmU6RW5naW5lKSB7fVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBpbmplY3RvciA9IFJlZmxlY3RpdmVJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtDYXIsIEVuZ2luZV0pO1xuICAgICAqIHZhciBjYXIgPSBpbmplY3Rvci5nZXQoQ2FyKTtcbiAgICAgKiBleHBlY3QoY2FyIGluc3RhbmNlb2YgQ2FyKS50b0JlKHRydWUpO1xuICAgICAqIGV4cGVjdChjYXIuZW5naW5lIGluc3RhbmNlb2YgRW5naW5lKS50b0JlKHRydWUpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogTm90aWNlLCB3ZSBkb24ndCB1c2UgdGhlIGBuZXdgIG9wZXJhdG9yIGJlY2F1c2Ugd2UgZXhwbGljaXRseSB3YW50IHRvIGhhdmUgdGhlIGBJbmplY3RvcmBcbiAgICAgKiByZXNvbHZlIGFsbCBvZiB0aGUgb2JqZWN0J3MgZGVwZW5kZW5jaWVzIGF1dG9tYXRpY2FsbHkuXG4gICAgICpcbiAgICAgKiBcXEBzdGFibGVcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICB2YXIgUmVmbGVjdGl2ZUluamVjdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUmVmbGVjdGl2ZUluamVjdG9yKCkge1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUdXJucyBhbiBhcnJheSBvZiBwcm92aWRlciBkZWZpbml0aW9ucyBpbnRvIGFuIGFycmF5IG9mIHJlc29sdmVkIHByb3ZpZGVycy5cbiAgICAgICAgICpcbiAgICAgICAgICogQSByZXNvbHV0aW9uIGlzIGEgcHJvY2VzcyBvZiBmbGF0dGVuaW5nIG11bHRpcGxlIG5lc3RlZCBhcnJheXMgYW5kIGNvbnZlcnRpbmcgaW5kaXZpZHVhbFxuICAgICAgICAgKiBwcm92aWRlcnMgaW50byBhbiBhcnJheSBvZiB7XFxAbGluayBSZXNvbHZlZFJlZmxlY3RpdmVQcm92aWRlcn1zLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvQWlYVEhpP3A9cHJldmlldykpXG4gICAgICAgICAqXG4gICAgICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgICAgICogXFxASW5qZWN0YWJsZSgpXG4gICAgICAgICAqIGNsYXNzIEVuZ2luZSB7XG4gICAgICAgICAqIH1cbiAgICAgICAgICpcbiAgICAgICAgICogXFxASW5qZWN0YWJsZSgpXG4gICAgICAgICAqIGNsYXNzIENhciB7XG4gICAgICAgICAqICAgY29uc3RydWN0b3IocHVibGljIGVuZ2luZTpFbmdpbmUpIHt9XG4gICAgICAgICAqIH1cbiAgICAgICAgICpcbiAgICAgICAgICogdmFyIHByb3ZpZGVycyA9IFJlZmxlY3RpdmVJbmplY3Rvci5yZXNvbHZlKFtDYXIsIFtbRW5naW5lXV1dKTtcbiAgICAgICAgICpcbiAgICAgICAgICogZXhwZWN0KHByb3ZpZGVycy5sZW5ndGgpLnRvRXF1YWwoMik7XG4gICAgICAgICAqXG4gICAgICAgICAqIGV4cGVjdChwcm92aWRlcnNbMF0gaW5zdGFuY2VvZiBSZXNvbHZlZFJlZmxlY3RpdmVQcm92aWRlcikudG9CZSh0cnVlKTtcbiAgICAgICAgICogZXhwZWN0KHByb3ZpZGVyc1swXS5rZXkuZGlzcGxheU5hbWUpLnRvQmUoXCJDYXJcIik7XG4gICAgICAgICAqIGV4cGVjdChwcm92aWRlcnNbMF0uZGVwZW5kZW5jaWVzLmxlbmd0aCkudG9FcXVhbCgxKTtcbiAgICAgICAgICogZXhwZWN0KHByb3ZpZGVyc1swXS5mYWN0b3J5KS50b0JlRGVmaW5lZCgpO1xuICAgICAgICAgKlxuICAgICAgICAgKiBleHBlY3QocHJvdmlkZXJzWzFdLmtleS5kaXNwbGF5TmFtZSkudG9CZShcIkVuZ2luZVwiKTtcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKlxuICAgICAgICAgKiBTZWUge1xcQGxpbmsgUmVmbGVjdGl2ZUluamVjdG9yI2Zyb21SZXNvbHZlZFByb3ZpZGVyc30gZm9yIG1vcmUgaW5mby5cbiAgICAgICAgICogQHBhcmFtIHs/fSBwcm92aWRlcnNcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFJlZmxlY3RpdmVJbmplY3Rvci5yZXNvbHZlID0gZnVuY3Rpb24gKHByb3ZpZGVycykge1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVSZWZsZWN0aXZlUHJvdmlkZXJzKHByb3ZpZGVycyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXNvbHZlcyBhbiBhcnJheSBvZiBwcm92aWRlcnMgYW5kIGNyZWF0ZXMgYW4gaW5qZWN0b3IgZnJvbSB0aG9zZSBwcm92aWRlcnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBwYXNzZWQtaW4gcHJvdmlkZXJzIGNhbiBiZSBhbiBhcnJheSBvZiBgVHlwZWAsIHtcXEBsaW5rIFByb3ZpZGVyfSxcbiAgICAgICAgICogb3IgYSByZWN1cnNpdmUgYXJyYXkgb2YgbW9yZSBwcm92aWRlcnMuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9lUE9jY0E/cD1wcmV2aWV3KSlcbiAgICAgICAgICpcbiAgICAgICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAgICAgKiBcXEBJbmplY3RhYmxlKClcbiAgICAgICAgICogY2xhc3MgRW5naW5lIHtcbiAgICAgICAgICogfVxuICAgICAgICAgKlxuICAgICAgICAgKiBcXEBJbmplY3RhYmxlKClcbiAgICAgICAgICogY2xhc3MgQ2FyIHtcbiAgICAgICAgICogICBjb25zdHJ1Y3RvcihwdWJsaWMgZW5naW5lOkVuZ2luZSkge31cbiAgICAgICAgICogfVxuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgaW5qZWN0b3IgPSBSZWZsZWN0aXZlSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbQ2FyLCBFbmdpbmVdKTtcbiAgICAgICAgICogZXhwZWN0KGluamVjdG9yLmdldChDYXIpIGluc3RhbmNlb2YgQ2FyKS50b0JlKHRydWUpO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBmdW5jdGlvbiBpcyBzbG93ZXIgdGhhbiB0aGUgY29ycmVzcG9uZGluZyBgZnJvbVJlc29sdmVkUHJvdmlkZXJzYFxuICAgICAgICAgKiBiZWNhdXNlIGl0IG5lZWRzIHRvIHJlc29sdmUgdGhlIHBhc3NlZC1pbiBwcm92aWRlcnMgZmlyc3QuXG4gICAgICAgICAqIFNlZSB7XFxAbGluayBJbmplY3RvciNyZXNvbHZlfSBhbmQge1xcQGxpbmsgSW5qZWN0b3IjZnJvbVJlc29sdmVkUHJvdmlkZXJzfS5cbiAgICAgICAgICogQHBhcmFtIHs/fSBwcm92aWRlcnNcbiAgICAgICAgICogQHBhcmFtIHs/PX0gcGFyZW50XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBSZWZsZWN0aXZlSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZSA9IGZ1bmN0aW9uIChwcm92aWRlcnMsIHBhcmVudCkge1xuICAgICAgICAgICAgaWYgKHBhcmVudCA9PT0gdm9pZCAwKSB7IHBhcmVudCA9IG51bGw7IH1cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIFJlc29sdmVkUmVmbGVjdGl2ZVByb3ZpZGVycyA9IFJlZmxlY3RpdmVJbmplY3Rvci5yZXNvbHZlKHByb3ZpZGVycyk7XG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdGl2ZUluamVjdG9yLmZyb21SZXNvbHZlZFByb3ZpZGVycyhSZXNvbHZlZFJlZmxlY3RpdmVQcm92aWRlcnMsIHBhcmVudCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGFuIGluamVjdG9yIGZyb20gcHJldmlvdXNseSByZXNvbHZlZCBwcm92aWRlcnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgQVBJIGlzIHRoZSByZWNvbW1lbmRlZCB3YXkgdG8gY29uc3RydWN0IGluamVjdG9ycyBpbiBwZXJmb3JtYW5jZS1zZW5zaXRpdmUgcGFydHMuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9LclNNY2k/cD1wcmV2aWV3KSlcbiAgICAgICAgICpcbiAgICAgICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAgICAgKiBcXEBJbmplY3RhYmxlKClcbiAgICAgICAgICogY2xhc3MgRW5naW5lIHtcbiAgICAgICAgICogfVxuICAgICAgICAgKlxuICAgICAgICAgKiBcXEBJbmplY3RhYmxlKClcbiAgICAgICAgICogY2xhc3MgQ2FyIHtcbiAgICAgICAgICogICBjb25zdHJ1Y3RvcihwdWJsaWMgZW5naW5lOkVuZ2luZSkge31cbiAgICAgICAgICogfVxuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgcHJvdmlkZXJzID0gUmVmbGVjdGl2ZUluamVjdG9yLnJlc29sdmUoW0NhciwgRW5naW5lXSk7XG4gICAgICAgICAqIHZhciBpbmplY3RvciA9IFJlZmxlY3RpdmVJbmplY3Rvci5mcm9tUmVzb2x2ZWRQcm92aWRlcnMocHJvdmlkZXJzKTtcbiAgICAgICAgICogZXhwZWN0KGluamVjdG9yLmdldChDYXIpIGluc3RhbmNlb2YgQ2FyKS50b0JlKHRydWUpO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICogXFxAZXhwZXJpbWVudGFsXG4gICAgICAgICAqIEBwYXJhbSB7P30gcHJvdmlkZXJzXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IHBhcmVudFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgUmVmbGVjdGl2ZUluamVjdG9yLmZyb21SZXNvbHZlZFByb3ZpZGVycyA9IGZ1bmN0aW9uIChwcm92aWRlcnMsIHBhcmVudCkge1xuICAgICAgICAgICAgaWYgKHBhcmVudCA9PT0gdm9pZCAwKSB7IHBhcmVudCA9IG51bGw7IH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVmbGVjdGl2ZUluamVjdG9yXyhSZWZsZWN0aXZlUHJvdG9JbmplY3Rvci5mcm9tUmVzb2x2ZWRQcm92aWRlcnMocHJvdmlkZXJzKSwgcGFyZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlZmxlY3RpdmVJbmplY3Rvci5wcm90b3R5cGUsIFwicGFyZW50XCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUGFyZW50IG9mIHRoaXMgaW5qZWN0b3IuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogPCEtLSBUT0RPOiBBZGQgYSBsaW5rIHRvIHRoZSBzZWN0aW9uIG9mIHRoZSB1c2VyIGd1aWRlIHRhbGtpbmcgYWJvdXQgaGllcmFyY2hpY2FsIGluamVjdGlvbi5cbiAgICAgICAgICAgICAqIC0tPlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9lb3NNR28/cD1wcmV2aWV3KSlcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICAgICAgICAgKiB2YXIgcGFyZW50ID0gUmVmbGVjdGl2ZUluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW10pO1xuICAgICAgICAgICAgICogdmFyIGNoaWxkID0gcGFyZW50LnJlc29sdmVBbmRDcmVhdGVDaGlsZChbXSk7XG4gICAgICAgICAgICAgKiBleHBlY3QoY2hpbGQucGFyZW50KS50b0JlKHBhcmVudCk7XG4gICAgICAgICAgICAgKiBgYGBcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc29sdmVzIGFuIGFycmF5IG9mIHByb3ZpZGVycyBhbmQgY3JlYXRlcyBhIGNoaWxkIGluamVjdG9yIGZyb20gdGhvc2UgcHJvdmlkZXJzLlxuICAgICAgICAgKlxuICAgICAgICAgKiA8IS0tIFRPRE86IEFkZCBhIGxpbmsgdG8gdGhlIHNlY3Rpb24gb2YgdGhlIHVzZXIgZ3VpZGUgdGFsa2luZyBhYm91dCBoaWVyYXJjaGljYWwgaW5qZWN0aW9uLlxuICAgICAgICAgKiAtLT5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIHBhc3NlZC1pbiBwcm92aWRlcnMgY2FuIGJlIGFuIGFycmF5IG9mIGBUeXBlYCwge1xcQGxpbmsgUHJvdmlkZXJ9LFxuICAgICAgICAgKiBvciBhIHJlY3Vyc2l2ZSBhcnJheSBvZiBtb3JlIHByb3ZpZGVycy5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L29wQjNUND9wPXByZXZpZXcpKVxuICAgICAgICAgKlxuICAgICAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICAgICAqIGNsYXNzIFBhcmVudFByb3ZpZGVyIHt9XG4gICAgICAgICAqIGNsYXNzIENoaWxkUHJvdmlkZXIge31cbiAgICAgICAgICpcbiAgICAgICAgICogdmFyIHBhcmVudCA9IFJlZmxlY3RpdmVJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtQYXJlbnRQcm92aWRlcl0pO1xuICAgICAgICAgKiB2YXIgY2hpbGQgPSBwYXJlbnQucmVzb2x2ZUFuZENyZWF0ZUNoaWxkKFtDaGlsZFByb3ZpZGVyXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIGV4cGVjdChjaGlsZC5nZXQoUGFyZW50UHJvdmlkZXIpIGluc3RhbmNlb2YgUGFyZW50UHJvdmlkZXIpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAqIGV4cGVjdChjaGlsZC5nZXQoQ2hpbGRQcm92aWRlcikgaW5zdGFuY2VvZiBDaGlsZFByb3ZpZGVyKS50b0JlKHRydWUpO1xuICAgICAgICAgKiBleHBlY3QoY2hpbGQuZ2V0KFBhcmVudFByb3ZpZGVyKSkudG9CZShwYXJlbnQuZ2V0KFBhcmVudFByb3ZpZGVyKSk7XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIHNsb3dlciB0aGFuIHRoZSBjb3JyZXNwb25kaW5nIGBjcmVhdGVDaGlsZEZyb21SZXNvbHZlZGBcbiAgICAgICAgICogYmVjYXVzZSBpdCBuZWVkcyB0byByZXNvbHZlIHRoZSBwYXNzZWQtaW4gcHJvdmlkZXJzIGZpcnN0LlxuICAgICAgICAgKiBTZWUge1xcQGxpbmsgSW5qZWN0b3IjcmVzb2x2ZX0gYW5kIHtcXEBsaW5rIEluamVjdG9yI2NyZWF0ZUNoaWxkRnJvbVJlc29sdmVkfS5cbiAgICAgICAgICogQHBhcmFtIHs/fSBwcm92aWRlcnNcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFJlZmxlY3RpdmVJbmplY3Rvci5wcm90b3R5cGUucmVzb2x2ZUFuZENyZWF0ZUNoaWxkID0gZnVuY3Rpb24gKHByb3ZpZGVycykgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCgpOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIGNoaWxkIGluamVjdG9yIGZyb20gcHJldmlvdXNseSByZXNvbHZlZCBwcm92aWRlcnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIDwhLS0gVE9ETzogQWRkIGEgbGluayB0byB0aGUgc2VjdGlvbiBvZiB0aGUgdXNlciBndWlkZSB0YWxraW5nIGFib3V0IGhpZXJhcmNoaWNhbCBpbmplY3Rpb24uXG4gICAgICAgICAqIC0tPlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIEFQSSBpcyB0aGUgcmVjb21tZW5kZWQgd2F5IHRvIGNvbnN0cnVjdCBpbmplY3RvcnMgaW4gcGVyZm9ybWFuY2Utc2Vuc2l0aXZlIHBhcnRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvVmh5ZmpOP3A9cHJldmlldykpXG4gICAgICAgICAqXG4gICAgICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgICAgICogY2xhc3MgUGFyZW50UHJvdmlkZXIge31cbiAgICAgICAgICogY2xhc3MgQ2hpbGRQcm92aWRlciB7fVxuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgcGFyZW50UHJvdmlkZXJzID0gUmVmbGVjdGl2ZUluamVjdG9yLnJlc29sdmUoW1BhcmVudFByb3ZpZGVyXSk7XG4gICAgICAgICAqIHZhciBjaGlsZFByb3ZpZGVycyA9IFJlZmxlY3RpdmVJbmplY3Rvci5yZXNvbHZlKFtDaGlsZFByb3ZpZGVyXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIHZhciBwYXJlbnQgPSBSZWZsZWN0aXZlSW5qZWN0b3IuZnJvbVJlc29sdmVkUHJvdmlkZXJzKHBhcmVudFByb3ZpZGVycyk7XG4gICAgICAgICAqIHZhciBjaGlsZCA9IHBhcmVudC5jcmVhdGVDaGlsZEZyb21SZXNvbHZlZChjaGlsZFByb3ZpZGVycyk7XG4gICAgICAgICAqXG4gICAgICAgICAqIGV4cGVjdChjaGlsZC5nZXQoUGFyZW50UHJvdmlkZXIpIGluc3RhbmNlb2YgUGFyZW50UHJvdmlkZXIpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAqIGV4cGVjdChjaGlsZC5nZXQoQ2hpbGRQcm92aWRlcikgaW5zdGFuY2VvZiBDaGlsZFByb3ZpZGVyKS50b0JlKHRydWUpO1xuICAgICAgICAgKiBleHBlY3QoY2hpbGQuZ2V0KFBhcmVudFByb3ZpZGVyKSkudG9CZShwYXJlbnQuZ2V0KFBhcmVudFByb3ZpZGVyKSk7XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKiBAcGFyYW0gez99IHByb3ZpZGVyc1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgUmVmbGVjdGl2ZUluamVjdG9yLnByb3RvdHlwZS5jcmVhdGVDaGlsZEZyb21SZXNvbHZlZCA9IGZ1bmN0aW9uIChwcm92aWRlcnMpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmltcGxlbWVudGVkKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXNvbHZlcyBhIHByb3ZpZGVyIGFuZCBpbnN0YW50aWF0ZXMgYW4gb2JqZWN0IGluIHRoZSBjb250ZXh0IG9mIHRoZSBpbmplY3Rvci5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGNyZWF0ZWQgb2JqZWN0IGRvZXMgbm90IGdldCBjYWNoZWQgYnkgdGhlIGluamVjdG9yLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQveXZWWG9CP3A9cHJldmlldykpXG4gICAgICAgICAqXG4gICAgICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgICAgICogXFxASW5qZWN0YWJsZSgpXG4gICAgICAgICAqIGNsYXNzIEVuZ2luZSB7XG4gICAgICAgICAqIH1cbiAgICAgICAgICpcbiAgICAgICAgICogXFxASW5qZWN0YWJsZSgpXG4gICAgICAgICAqIGNsYXNzIENhciB7XG4gICAgICAgICAqICAgY29uc3RydWN0b3IocHVibGljIGVuZ2luZTpFbmdpbmUpIHt9XG4gICAgICAgICAqIH1cbiAgICAgICAgICpcbiAgICAgICAgICogdmFyIGluamVjdG9yID0gUmVmbGVjdGl2ZUluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW0VuZ2luZV0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgY2FyID0gaW5qZWN0b3IucmVzb2x2ZUFuZEluc3RhbnRpYXRlKENhcik7XG4gICAgICAgICAqIGV4cGVjdChjYXIuZW5naW5lKS50b0JlKGluamVjdG9yLmdldChFbmdpbmUpKTtcbiAgICAgICAgICogZXhwZWN0KGNhcikubm90LnRvQmUoaW5qZWN0b3IucmVzb2x2ZUFuZEluc3RhbnRpYXRlKENhcikpO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICogQHBhcmFtIHs/fSBwcm92aWRlclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgUmVmbGVjdGl2ZUluamVjdG9yLnByb3RvdHlwZS5yZXNvbHZlQW5kSW5zdGFudGlhdGUgPSBmdW5jdGlvbiAocHJvdmlkZXIpIHsgcmV0dXJuIHVuaW1wbGVtZW50ZWQoKTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluc3RhbnRpYXRlcyBhbiBvYmplY3QgdXNpbmcgYSByZXNvbHZlZCBwcm92aWRlciBpbiB0aGUgY29udGV4dCBvZiB0aGUgaW5qZWN0b3IuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBjcmVhdGVkIG9iamVjdCBkb2VzIG5vdCBnZXQgY2FjaGVkIGJ5IHRoZSBpbmplY3Rvci5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L3B0Q0ltUT9wPXByZXZpZXcpKVxuICAgICAgICAgKlxuICAgICAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICAgICAqIFxcQEluamVjdGFibGUoKVxuICAgICAgICAgKiBjbGFzcyBFbmdpbmUge1xuICAgICAgICAgKiB9XG4gICAgICAgICAqXG4gICAgICAgICAqIFxcQEluamVjdGFibGUoKVxuICAgICAgICAgKiBjbGFzcyBDYXIge1xuICAgICAgICAgKiAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbmdpbmU6RW5naW5lKSB7fVxuICAgICAgICAgKiB9XG4gICAgICAgICAqXG4gICAgICAgICAqIHZhciBpbmplY3RvciA9IFJlZmxlY3RpdmVJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtFbmdpbmVdKTtcbiAgICAgICAgICogdmFyIGNhclByb3ZpZGVyID0gUmVmbGVjdGl2ZUluamVjdG9yLnJlc29sdmUoW0Nhcl0pWzBdO1xuICAgICAgICAgKiB2YXIgY2FyID0gaW5qZWN0b3IuaW5zdGFudGlhdGVSZXNvbHZlZChjYXJQcm92aWRlcik7XG4gICAgICAgICAqIGV4cGVjdChjYXIuZW5naW5lKS50b0JlKGluamVjdG9yLmdldChFbmdpbmUpKTtcbiAgICAgICAgICogZXhwZWN0KGNhcikubm90LnRvQmUoaW5qZWN0b3IuaW5zdGFudGlhdGVSZXNvbHZlZChjYXJQcm92aWRlcikpO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICogQHBhcmFtIHs/fSBwcm92aWRlclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgUmVmbGVjdGl2ZUluamVjdG9yLnByb3RvdHlwZS5pbnN0YW50aWF0ZVJlc29sdmVkID0gZnVuY3Rpb24gKHByb3ZpZGVyKSB7IHJldHVybiB1bmltcGxlbWVudGVkKCk7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAYWJzdHJhY3RcbiAgICAgICAgICogQHBhcmFtIHs/fSB0b2tlblxuICAgICAgICAgKiBAcGFyYW0gez89fSBub3RGb3VuZFZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBSZWZsZWN0aXZlSW5qZWN0b3IucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh0b2tlbiwgbm90Rm91bmRWYWx1ZSkgeyB9O1xuICAgICAgICByZXR1cm4gUmVmbGVjdGl2ZUluamVjdG9yO1xuICAgIH0oKSk7XG4gICAgdmFyIFJlZmxlY3RpdmVJbmplY3Rvcl8gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0gez99IF9wcm90b1xuICAgICAgICAgKiBAcGFyYW0gez89fSBfcGFyZW50XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBSZWZsZWN0aXZlSW5qZWN0b3JfKF9wcm90byAvKiBQcm90b0luamVjdG9yICovLCBfcGFyZW50KSB7XG4gICAgICAgICAgICBpZiAoX3BhcmVudCA9PT0gdm9pZCAwKSB7IF9wYXJlbnQgPSBudWxsOyB9XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9jb25zdHJ1Y3Rpb25Db3VudGVyID0gMDtcbiAgICAgICAgICAgIHRoaXMuX3Byb3RvID0gX3Byb3RvO1xuICAgICAgICAgICAgdGhpcy5fcGFyZW50ID0gX3BhcmVudDtcbiAgICAgICAgICAgIHRoaXMuX3N0cmF0ZWd5ID0gX3Byb3RvLl9zdHJhdGVneS5jcmVhdGVJbmplY3RvclN0cmF0ZWd5KHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHRva2VuXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IG5vdEZvdW5kVmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFJlZmxlY3RpdmVJbmplY3Rvcl8ucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh0b2tlbiwgbm90Rm91bmRWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKG5vdEZvdW5kVmFsdWUgPT09IHZvaWQgMCkgeyBub3RGb3VuZFZhbHVlID0gVEhST1dfSUZfTk9UX0ZPVU5EOyB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0QnlLZXkoUmVmbGVjdGl2ZUtleS5nZXQodG9rZW4pLCBudWxsLCBudWxsLCBub3RGb3VuZFZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gaW5kZXhcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFJlZmxlY3RpdmVJbmplY3Rvcl8ucHJvdG90eXBlLmdldEF0ID0gZnVuY3Rpb24gKGluZGV4KSB7IHJldHVybiB0aGlzLl9zdHJhdGVneS5nZXRPYmpBdEluZGV4KGluZGV4KTsgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlZmxlY3RpdmVJbmplY3Rvcl8ucHJvdG90eXBlLCBcInBhcmVudFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcGFyZW50OyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlZmxlY3RpdmVJbmplY3Rvcl8ucHJvdG90eXBlLCBcImludGVybmFsU3RyYXRlZ3lcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBcXEBpbnRlcm5hbFxuICAgICAgICAgICAgICogSW50ZXJuYWwuIERvIG5vdCB1c2UuXG4gICAgICAgICAgICAgKiBXZSByZXR1cm4gYGFueWAgbm90IHRvIGV4cG9ydCB0aGUgSW5qZWN0b3JTdHJhdGVneSB0eXBlLlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zdHJhdGVneTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHByb3ZpZGVyc1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgUmVmbGVjdGl2ZUluamVjdG9yXy5wcm90b3R5cGUucmVzb2x2ZUFuZENyZWF0ZUNoaWxkID0gZnVuY3Rpb24gKHByb3ZpZGVycykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gUmVzb2x2ZWRSZWZsZWN0aXZlUHJvdmlkZXJzID0gUmVmbGVjdGl2ZUluamVjdG9yLnJlc29sdmUocHJvdmlkZXJzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUNoaWxkRnJvbVJlc29sdmVkKFJlc29sdmVkUmVmbGVjdGl2ZVByb3ZpZGVycyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHByb3ZpZGVyc1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgUmVmbGVjdGl2ZUluamVjdG9yXy5wcm90b3R5cGUuY3JlYXRlQ2hpbGRGcm9tUmVzb2x2ZWQgPSBmdW5jdGlvbiAocHJvdmlkZXJzKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm90byA9IG5ldyBSZWZsZWN0aXZlUHJvdG9JbmplY3Rvcihwcm92aWRlcnMpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5qID0gbmV3IFJlZmxlY3RpdmVJbmplY3Rvcl8ocHJvdG8pO1xuICAgICAgICAgICAgaW5qLl9wYXJlbnQgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIGluajtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gcHJvdmlkZXJcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFJlZmxlY3RpdmVJbmplY3Rvcl8ucHJvdG90eXBlLnJlc29sdmVBbmRJbnN0YW50aWF0ZSA9IGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFudGlhdGVSZXNvbHZlZChSZWZsZWN0aXZlSW5qZWN0b3IucmVzb2x2ZShbcHJvdmlkZXJdKVswXSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHByb3ZpZGVyXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBSZWZsZWN0aXZlSW5qZWN0b3JfLnByb3RvdHlwZS5pbnN0YW50aWF0ZVJlc29sdmVkID0gZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW5zdGFudGlhdGVQcm92aWRlcihwcm92aWRlcik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBcXEBpbnRlcm5hbFxuICAgICAgICAgKiBAcGFyYW0gez99IHByb3ZpZGVyXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBSZWZsZWN0aXZlSW5qZWN0b3JfLnByb3RvdHlwZS5fbmV3ID0gZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY29uc3RydWN0aW9uQ291bnRlcisrID4gdGhpcy5fc3RyYXRlZ3kuZ2V0TWF4TnVtYmVyT2ZPYmplY3RzKCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQ3ljbGljRGVwZW5kZW5jeUVycm9yKHRoaXMsIHByb3ZpZGVyLmtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW5zdGFudGlhdGVQcm92aWRlcihwcm92aWRlcik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHByb3ZpZGVyXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBSZWZsZWN0aXZlSW5qZWN0b3JfLnByb3RvdHlwZS5faW5zdGFudGlhdGVQcm92aWRlciA9IGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgICAgICAgaWYgKHByb3ZpZGVyLm11bHRpUHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXMgPSBuZXcgQXJyYXkocHJvdmlkZXIucmVzb2x2ZWRGYWN0b3JpZXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgcHJvdmlkZXIucmVzb2x2ZWRGYWN0b3JpZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzW2ldID0gdGhpcy5faW5zdGFudGlhdGUocHJvdmlkZXIsIHByb3ZpZGVyLnJlc29sdmVkRmFjdG9yaWVzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnN0YW50aWF0ZShwcm92aWRlciwgcHJvdmlkZXIucmVzb2x2ZWRGYWN0b3JpZXNbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBwcm92aWRlclxuICAgICAgICAgKiBAcGFyYW0gez99IFJlc29sdmVkUmVmbGVjdGl2ZUZhY3RvcnlcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFJlZmxlY3RpdmVJbmplY3Rvcl8ucHJvdG90eXBlLl9pbnN0YW50aWF0ZSA9IGZ1bmN0aW9uIChwcm92aWRlciwgUmVzb2x2ZWRSZWZsZWN0aXZlRmFjdG9yeSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZmFjdG9yeSA9IFJlc29sdmVkUmVmbGVjdGl2ZUZhY3RvcnkuZmFjdG9yeTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlcHMgPSBSZXNvbHZlZFJlZmxlY3RpdmVGYWN0b3J5LmRlcGVuZGVuY2llcztcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxlbmd0aCA9IGRlcHMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZDA7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkMTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGQyO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZDM7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkNDtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGQ1O1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZDY7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkNztcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGQ4O1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZDk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkMTA7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkMTE7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkMTI7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkMTM7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkMTQ7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkMTU7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkMTY7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkMTc7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkMTg7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkMTk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGQwID0gbGVuZ3RoID4gMCA/IHRoaXMuX2dldEJ5UmVmbGVjdGl2ZURlcGVuZGVuY3kocHJvdmlkZXIsIGRlcHNbMF0pIDogbnVsbDtcbiAgICAgICAgICAgICAgICBkMSA9IGxlbmd0aCA+IDEgPyB0aGlzLl9nZXRCeVJlZmxlY3RpdmVEZXBlbmRlbmN5KHByb3ZpZGVyLCBkZXBzWzFdKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgZDIgPSBsZW5ndGggPiAyID8gdGhpcy5fZ2V0QnlSZWZsZWN0aXZlRGVwZW5kZW5jeShwcm92aWRlciwgZGVwc1syXSkgOiBudWxsO1xuICAgICAgICAgICAgICAgIGQzID0gbGVuZ3RoID4gMyA/IHRoaXMuX2dldEJ5UmVmbGVjdGl2ZURlcGVuZGVuY3kocHJvdmlkZXIsIGRlcHNbM10pIDogbnVsbDtcbiAgICAgICAgICAgICAgICBkNCA9IGxlbmd0aCA+IDQgPyB0aGlzLl9nZXRCeVJlZmxlY3RpdmVEZXBlbmRlbmN5KHByb3ZpZGVyLCBkZXBzWzRdKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgZDUgPSBsZW5ndGggPiA1ID8gdGhpcy5fZ2V0QnlSZWZsZWN0aXZlRGVwZW5kZW5jeShwcm92aWRlciwgZGVwc1s1XSkgOiBudWxsO1xuICAgICAgICAgICAgICAgIGQ2ID0gbGVuZ3RoID4gNiA/IHRoaXMuX2dldEJ5UmVmbGVjdGl2ZURlcGVuZGVuY3kocHJvdmlkZXIsIGRlcHNbNl0pIDogbnVsbDtcbiAgICAgICAgICAgICAgICBkNyA9IGxlbmd0aCA+IDcgPyB0aGlzLl9nZXRCeVJlZmxlY3RpdmVEZXBlbmRlbmN5KHByb3ZpZGVyLCBkZXBzWzddKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgZDggPSBsZW5ndGggPiA4ID8gdGhpcy5fZ2V0QnlSZWZsZWN0aXZlRGVwZW5kZW5jeShwcm92aWRlciwgZGVwc1s4XSkgOiBudWxsO1xuICAgICAgICAgICAgICAgIGQ5ID0gbGVuZ3RoID4gOSA/IHRoaXMuX2dldEJ5UmVmbGVjdGl2ZURlcGVuZGVuY3kocHJvdmlkZXIsIGRlcHNbOV0pIDogbnVsbDtcbiAgICAgICAgICAgICAgICBkMTAgPSBsZW5ndGggPiAxMCA/IHRoaXMuX2dldEJ5UmVmbGVjdGl2ZURlcGVuZGVuY3kocHJvdmlkZXIsIGRlcHNbMTBdKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgZDExID0gbGVuZ3RoID4gMTEgPyB0aGlzLl9nZXRCeVJlZmxlY3RpdmVEZXBlbmRlbmN5KHByb3ZpZGVyLCBkZXBzWzExXSkgOiBudWxsO1xuICAgICAgICAgICAgICAgIGQxMiA9IGxlbmd0aCA+IDEyID8gdGhpcy5fZ2V0QnlSZWZsZWN0aXZlRGVwZW5kZW5jeShwcm92aWRlciwgZGVwc1sxMl0pIDogbnVsbDtcbiAgICAgICAgICAgICAgICBkMTMgPSBsZW5ndGggPiAxMyA/IHRoaXMuX2dldEJ5UmVmbGVjdGl2ZURlcGVuZGVuY3kocHJvdmlkZXIsIGRlcHNbMTNdKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgZDE0ID0gbGVuZ3RoID4gMTQgPyB0aGlzLl9nZXRCeVJlZmxlY3RpdmVEZXBlbmRlbmN5KHByb3ZpZGVyLCBkZXBzWzE0XSkgOiBudWxsO1xuICAgICAgICAgICAgICAgIGQxNSA9IGxlbmd0aCA+IDE1ID8gdGhpcy5fZ2V0QnlSZWZsZWN0aXZlRGVwZW5kZW5jeShwcm92aWRlciwgZGVwc1sxNV0pIDogbnVsbDtcbiAgICAgICAgICAgICAgICBkMTYgPSBsZW5ndGggPiAxNiA/IHRoaXMuX2dldEJ5UmVmbGVjdGl2ZURlcGVuZGVuY3kocHJvdmlkZXIsIGRlcHNbMTZdKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgZDE3ID0gbGVuZ3RoID4gMTcgPyB0aGlzLl9nZXRCeVJlZmxlY3RpdmVEZXBlbmRlbmN5KHByb3ZpZGVyLCBkZXBzWzE3XSkgOiBudWxsO1xuICAgICAgICAgICAgICAgIGQxOCA9IGxlbmd0aCA+IDE4ID8gdGhpcy5fZ2V0QnlSZWZsZWN0aXZlRGVwZW5kZW5jeShwcm92aWRlciwgZGVwc1sxOF0pIDogbnVsbDtcbiAgICAgICAgICAgICAgICBkMTkgPSBsZW5ndGggPiAxOSA/IHRoaXMuX2dldEJ5UmVmbGVjdGl2ZURlcGVuZGVuY3kocHJvdmlkZXIsIGRlcHNbMTldKSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgQWJzdHJhY3RQcm92aWRlckVycm9yIHx8IGUgaW5zdGFuY2VvZiBJbnN0YW50aWF0aW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5hZGRLZXkodGhpcywgcHJvdmlkZXIua2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9iajtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gZmFjdG9yeSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IGZhY3RvcnkoZDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IGZhY3RvcnkoZDAsIGQxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBmYWN0b3J5KGQwLCBkMSwgZDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IGZhY3RvcnkoZDAsIGQxLCBkMiwgZDMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IGZhY3RvcnkoZDAsIGQxLCBkMiwgZDMsIGQ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBmYWN0b3J5KGQwLCBkMSwgZDIsIGQzLCBkNCwgZDUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IGZhY3RvcnkoZDAsIGQxLCBkMiwgZDMsIGQ0LCBkNSwgZDYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IGZhY3RvcnkoZDAsIGQxLCBkMiwgZDMsIGQ0LCBkNSwgZDYsIGQ3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBmYWN0b3J5KGQwLCBkMSwgZDIsIGQzLCBkNCwgZDUsIGQ2LCBkNywgZDgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBmYWN0b3J5KGQwLCBkMSwgZDIsIGQzLCBkNCwgZDUsIGQ2LCBkNywgZDgsIGQ5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gZmFjdG9yeShkMCwgZDEsIGQyLCBkMywgZDQsIGQ1LCBkNiwgZDcsIGQ4LCBkOSwgZDEwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gZmFjdG9yeShkMCwgZDEsIGQyLCBkMywgZDQsIGQ1LCBkNiwgZDcsIGQ4LCBkOSwgZDEwLCBkMTEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBmYWN0b3J5KGQwLCBkMSwgZDIsIGQzLCBkNCwgZDUsIGQ2LCBkNywgZDgsIGQ5LCBkMTAsIGQxMSwgZDEyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gZmFjdG9yeShkMCwgZDEsIGQyLCBkMywgZDQsIGQ1LCBkNiwgZDcsIGQ4LCBkOSwgZDEwLCBkMTEsIGQxMiwgZDEzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gZmFjdG9yeShkMCwgZDEsIGQyLCBkMywgZDQsIGQ1LCBkNiwgZDcsIGQ4LCBkOSwgZDEwLCBkMTEsIGQxMiwgZDEzLCBkMTQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBmYWN0b3J5KGQwLCBkMSwgZDIsIGQzLCBkNCwgZDUsIGQ2LCBkNywgZDgsIGQ5LCBkMTAsIGQxMSwgZDEyLCBkMTMsIGQxNCwgZDE1KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gZmFjdG9yeShkMCwgZDEsIGQyLCBkMywgZDQsIGQ1LCBkNiwgZDcsIGQ4LCBkOSwgZDEwLCBkMTEsIGQxMiwgZDEzLCBkMTQsIGQxNSwgZDE2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gZmFjdG9yeShkMCwgZDEsIGQyLCBkMywgZDQsIGQ1LCBkNiwgZDcsIGQ4LCBkOSwgZDEwLCBkMTEsIGQxMiwgZDEzLCBkMTQsIGQxNSwgZDE2LCBkMTcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBmYWN0b3J5KGQwLCBkMSwgZDIsIGQzLCBkNCwgZDUsIGQ2LCBkNywgZDgsIGQ5LCBkMTAsIGQxMSwgZDEyLCBkMTMsIGQxNCwgZDE1LCBkMTYsIGQxNywgZDE4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gZmFjdG9yeShkMCwgZDEsIGQyLCBkMywgZDQsIGQ1LCBkNiwgZDcsIGQ4LCBkOSwgZDEwLCBkMTEsIGQxMiwgZDEzLCBkMTQsIGQxNSwgZDE2LCBkMTcsIGQxOCwgZDE5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGluc3RhbnRpYXRlICdcIiArIHByb3ZpZGVyLmtleS5kaXNwbGF5TmFtZSArIFwiJyBiZWNhdXNlIGl0IGhhcyBtb3JlIHRoYW4gMjAgZGVwZW5kZW5jaWVzXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEluc3RhbnRpYXRpb25FcnJvcih0aGlzLCBlLCBlLnN0YWNrLCBwcm92aWRlci5rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gcHJvdmlkZXJcbiAgICAgICAgICogQHBhcmFtIHs/fSBkZXBcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFJlZmxlY3RpdmVJbmplY3Rvcl8ucHJvdG90eXBlLl9nZXRCeVJlZmxlY3RpdmVEZXBlbmRlbmN5ID0gZnVuY3Rpb24gKHByb3ZpZGVyLCBkZXApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRCeUtleShkZXAua2V5LCBkZXAubG93ZXJCb3VuZFZpc2liaWxpdHksIGRlcC51cHBlckJvdW5kVmlzaWJpbGl0eSwgZGVwLm9wdGlvbmFsID8gbnVsbCA6IFRIUk9XX0lGX05PVF9GT1VORCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGtleVxuICAgICAgICAgKiBAcGFyYW0gez99IGxvd2VyQm91bmRWaXNpYmlsaXR5XG4gICAgICAgICAqIEBwYXJhbSB7P30gdXBwZXJCb3VuZFZpc2liaWxpdHlcbiAgICAgICAgICogQHBhcmFtIHs/fSBub3RGb3VuZFZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBSZWZsZWN0aXZlSW5qZWN0b3JfLnByb3RvdHlwZS5fZ2V0QnlLZXkgPSBmdW5jdGlvbiAoa2V5LCBsb3dlckJvdW5kVmlzaWJpbGl0eSwgdXBwZXJCb3VuZFZpc2liaWxpdHksIG5vdEZvdW5kVmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IElOSkVDVE9SX0tFWSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVwcGVyQm91bmRWaXNpYmlsaXR5IGluc3RhbmNlb2YgU2VsZikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRCeUtleVNlbGYoa2V5LCBub3RGb3VuZFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRCeUtleURlZmF1bHQoa2V5LCBub3RGb3VuZFZhbHVlLCBsb3dlckJvdW5kVmlzaWJpbGl0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBcXEBpbnRlcm5hbFxuICAgICAgICAgKiBAcGFyYW0gez99IGtleVxuICAgICAgICAgKiBAcGFyYW0gez99IG5vdEZvdW5kVmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFJlZmxlY3RpdmVJbmplY3Rvcl8ucHJvdG90eXBlLl90aHJvd09yTnVsbCA9IGZ1bmN0aW9uIChrZXksIG5vdEZvdW5kVmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChub3RGb3VuZFZhbHVlICE9PSBUSFJPV19JRl9OT1RfRk9VTkQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm90Rm91bmRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb1Byb3ZpZGVyRXJyb3IodGhpcywga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxcQGludGVybmFsXG4gICAgICAgICAqIEBwYXJhbSB7P30ga2V5XG4gICAgICAgICAqIEBwYXJhbSB7P30gbm90Rm91bmRWYWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgUmVmbGVjdGl2ZUluamVjdG9yXy5wcm90b3R5cGUuX2dldEJ5S2V5U2VsZiA9IGZ1bmN0aW9uIChrZXksIG5vdEZvdW5kVmFsdWUpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9iaiA9IHRoaXMuX3N0cmF0ZWd5LmdldE9iakJ5S2V5SWQoa2V5LmlkKTtcbiAgICAgICAgICAgIHJldHVybiAob2JqICE9PSBVTkRFRklORUQpID8gb2JqIDogdGhpcy5fdGhyb3dPck51bGwoa2V5LCBub3RGb3VuZFZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxcQGludGVybmFsXG4gICAgICAgICAqIEBwYXJhbSB7P30ga2V5XG4gICAgICAgICAqIEBwYXJhbSB7P30gbm90Rm91bmRWYWx1ZVxuICAgICAgICAgKiBAcGFyYW0gez99IGxvd2VyQm91bmRWaXNpYmlsaXR5XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBSZWZsZWN0aXZlSW5qZWN0b3JfLnByb3RvdHlwZS5fZ2V0QnlLZXlEZWZhdWx0ID0gZnVuY3Rpb24gKGtleSwgbm90Rm91bmRWYWx1ZSwgbG93ZXJCb3VuZFZpc2liaWxpdHkpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGluajtcbiAgICAgICAgICAgIGlmIChsb3dlckJvdW5kVmlzaWJpbGl0eSBpbnN0YW5jZW9mIFNraXBTZWxmKSB7XG4gICAgICAgICAgICAgICAgaW5qID0gdGhpcy5fcGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5qID0gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChpbmogaW5zdGFuY2VvZiBSZWZsZWN0aXZlSW5qZWN0b3JfKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5qXyA9IChpbmopO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9iaiA9IGlual8uX3N0cmF0ZWd5LmdldE9iakJ5S2V5SWQoa2V5LmlkKTtcbiAgICAgICAgICAgICAgICBpZiAob2JqICE9PSBVTkRFRklORUQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICAgICAgaW5qID0gaW5qXy5fcGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluaiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmouZ2V0KGtleS50b2tlbiwgbm90Rm91bmRWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdGhyb3dPck51bGwoa2V5LCBub3RGb3VuZFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlZmxlY3RpdmVJbmplY3Rvcl8ucHJvdG90eXBlLCBcImRpc3BsYXlOYW1lXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvdmlkZXJzID0gX21hcFByb3ZpZGVycyh0aGlzLCBmdW5jdGlvbiAoYikgeyByZXR1cm4gJyBcIicgKyBiLmtleS5kaXNwbGF5TmFtZSArICdcIiAnOyB9KVxuICAgICAgICAgICAgICAgICAgICAuam9pbignLCAnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJSZWZsZWN0aXZlSW5qZWN0b3IocHJvdmlkZXJzOiBbXCIgKyBwcm92aWRlcnMgKyBcIl0pXCI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBSZWZsZWN0aXZlSW5qZWN0b3JfLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZGlzcGxheU5hbWU7IH07XG4gICAgICAgIHJldHVybiBSZWZsZWN0aXZlSW5qZWN0b3JfO1xuICAgIH0oKSk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gSU5KRUNUT1JfS0VZID0gUmVmbGVjdGl2ZUtleS5nZXQoSW5qZWN0b3IpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaW5qZWN0b3JcbiAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfbWFwUHJvdmlkZXJzKGluamVjdG9yLCBmbikge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXMgPSBuZXcgQXJyYXkoaW5qZWN0b3IuX3Byb3RvLm51bWJlck9mUHJvdmlkZXJzKTtcbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IGluamVjdG9yLl9wcm90by5udW1iZXJPZlByb3ZpZGVyczsgKytpKSB7XG4gICAgICAgICAgICByZXNbaV0gPSBmbihpbmplY3Rvci5fcHJvdG8uZ2V0UHJvdmlkZXJBdEluZGV4KGkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBcXEB3aGF0SXREb2VzIFByb3ZpZGVzIGEgaG9vayBmb3IgY2VudHJhbGl6ZWQgZXhjZXB0aW9uIGhhbmRsaW5nLlxuICAgICAqXG4gICAgICogXFxAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIGBFcnJvckhhbmRsZXJgIHByaW50cyBlcnJvciBtZXNzYWdlcyB0byB0aGUgYGNvbnNvbGVgLiBUb1xuICAgICAqIGludGVyY2VwdCBlcnJvciBoYW5kbGluZywgd3JpdGUgYSBjdXN0b20gZXhjZXB0aW9uIGhhbmRsZXIgdGhhdCByZXBsYWNlcyB0aGlzIGRlZmF1bHQgYXNcbiAgICAgKiBhcHByb3ByaWF0ZSBmb3IgeW91ciBhcHAuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogY2xhc3MgTXlFcnJvckhhbmRsZXIgaW1wbGVtZW50cyBFcnJvckhhbmRsZXIge1xuICAgICAqICAgaGFuZGxlRXJyb3IoZXJyb3IpIHtcbiAgICAgKiAgICAgLy8gZG8gc29tZXRoaW5nIHdpdGggdGhlIGV4Y2VwdGlvblxuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIFxcQE5nTW9kdWxlKHtcbiAgICAgKiAgIHByb3ZpZGVyczogW3twcm92aWRlOiBFcnJvckhhbmRsZXIsIHVzZUNsYXNzOiBNeUVycm9ySGFuZGxlcn1dXG4gICAgICogfSlcbiAgICAgKiBjbGFzcyBNeU1vZHVsZSB7fVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogXFxAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEVycm9ySGFuZGxlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez89fSByZXRocm93RXJyb3JcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIEVycm9ySGFuZGxlcihyZXRocm93RXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChyZXRocm93RXJyb3IgPT09IHZvaWQgMCkgeyByZXRocm93RXJyb3IgPSB0cnVlOyB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLl9jb25zb2xlID0gY29uc29sZTtcbiAgICAgICAgICAgIHRoaXMucmV0aHJvd0Vycm9yID0gcmV0aHJvd0Vycm9yO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGVycm9yXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBFcnJvckhhbmRsZXIucHJvdG90eXBlLmhhbmRsZUVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvcmlnaW5hbEVycm9yID0gdGhpcy5fZmluZE9yaWdpbmFsRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3JpZ2luYWxTdGFjayA9IHRoaXMuX2ZpbmRPcmlnaW5hbFN0YWNrKGVycm9yKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbnRleHQgPSB0aGlzLl9maW5kQ29udGV4dChlcnJvcik7XG4gICAgICAgICAgICB0aGlzLl9jb25zb2xlLmVycm9yKFwiRVhDRVBUSU9OOiBcIiArIHRoaXMuX2V4dHJhY3RNZXNzYWdlKGVycm9yKSk7XG4gICAgICAgICAgICBpZiAob3JpZ2luYWxFcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnNvbGUuZXJyb3IoXCJPUklHSU5BTCBFWENFUFRJT046IFwiICsgdGhpcy5fZXh0cmFjdE1lc3NhZ2Uob3JpZ2luYWxFcnJvcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9yaWdpbmFsU3RhY2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25zb2xlLmVycm9yKCdPUklHSU5BTCBTVEFDS1RSQUNFOicpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnNvbGUuZXJyb3Iob3JpZ2luYWxTdGFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnNvbGUuZXJyb3IoJ0VSUk9SIENPTlRFWFQ6Jyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29uc29sZS5lcnJvcihjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlIHJldGhyb3cgZXhjZXB0aW9ucywgc28gb3BlcmF0aW9ucyBsaWtlICdib290c3RyYXAnIHdpbGwgcmVzdWx0IGluIGFuIGVycm9yXG4gICAgICAgICAgICAvLyB3aGVuIGFuIGVycm9yIGhhcHBlbnMuIElmIHdlIGRvIG5vdCByZXRocm93LCBib290c3RyYXAgd2lsbCBhbHdheXMgc3VjY2VlZC5cbiAgICAgICAgICAgIGlmICh0aGlzLnJldGhyb3dFcnJvcilcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxcQGludGVybmFsXG4gICAgICAgICAqIEBwYXJhbSB7P30gZXJyb3JcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEVycm9ySGFuZGxlci5wcm90b3R5cGUuX2V4dHJhY3RNZXNzYWdlID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBlcnJvci50b1N0cmluZygpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogXFxAaW50ZXJuYWxcbiAgICAgICAgICogQHBhcmFtIHs/fSBlcnJvclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRXJyb3JIYW5kbGVyLnByb3RvdHlwZS5fZmluZENvbnRleHQgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvci5jb250ZXh0ID8gZXJyb3IuY29udGV4dCA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZpbmRDb250ZXh0KCgoZXJyb3IpKS5vcmlnaW5hbEVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogXFxAaW50ZXJuYWxcbiAgICAgICAgICogQHBhcmFtIHs/fSBlcnJvclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRXJyb3JIYW5kbGVyLnByb3RvdHlwZS5fZmluZE9yaWdpbmFsRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGUgPSAoKGVycm9yKSkub3JpZ2luYWxFcnJvcjtcbiAgICAgICAgICAgIHdoaWxlIChlICYmICgoZSkpLm9yaWdpbmFsRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlID0gKChlKSkub3JpZ2luYWxFcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogXFxAaW50ZXJuYWxcbiAgICAgICAgICogQHBhcmFtIHs/fSBlcnJvclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRXJyb3JIYW5kbGVyLnByb3RvdHlwZS5fZmluZE9yaWdpbmFsU3RhY2sgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICghKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZSA9IGVycm9yO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhY2sgPSBlLnN0YWNrO1xuICAgICAgICAgICAgd2hpbGUgKGUgaW5zdGFuY2VvZiBFcnJvciAmJiAoKGUpKS5vcmlnaW5hbEVycm9yKSB7XG4gICAgICAgICAgICAgICAgZSA9ICgoZSkpLm9yaWdpbmFsRXJyb3I7XG4gICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLnN0YWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrID0gZS5zdGFjaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3RhY2s7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBFcnJvckhhbmRsZXI7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIFdyYXBzIEphdmFzY3JpcHQgT2JqZWN0c1xuICAgICAqL1xuICAgIHZhciBTdHJpbmdNYXBXcmFwcGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gU3RyaW5nTWFwV3JhcHBlcigpIHtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBtMVxuICAgICAgICAgKiBAcGFyYW0gez99IG0yXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBTdHJpbmdNYXBXcmFwcGVyLm1lcmdlID0gZnVuY3Rpb24gKG0xLCBtMikge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbSA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IE9iamVjdC5rZXlzKG0xKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgayA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICBtW2tdID0gbTFba107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IDAsIF9jID0gT2JqZWN0LmtleXMobTIpOyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xuICAgICAgICAgICAgICAgIHZhciBrID0gX2NbX2JdO1xuICAgICAgICAgICAgICAgIG1ba10gPSBtMltrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBtMVxuICAgICAgICAgKiBAcGFyYW0gez99IG0yXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBTdHJpbmdNYXBXcmFwcGVyLmVxdWFscyA9IGZ1bmN0aW9uIChtMSwgbTIpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGsxID0gT2JqZWN0LmtleXMobTEpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gazIgPSBPYmplY3Qua2V5cyhtMik7XG4gICAgICAgICAgICBpZiAoazEubGVuZ3RoICE9IGsyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBrMS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGtleSA9IGsxW2ldO1xuICAgICAgICAgICAgICAgIGlmIChtMVtrZXldICE9PSBtMltrZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFN0cmluZ01hcFdyYXBwZXI7XG4gICAgfSgpKTtcbiAgICB2YXIgTGlzdFdyYXBwZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBMaXN0V3JhcHBlcigpIHtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBhcnJcbiAgICAgICAgICogQHBhcmFtIHs/fSBjb25kaXRpb25cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIExpc3RXcmFwcGVyLmZpbmRMYXN0ID0gZnVuY3Rpb24gKGFyciwgY29uZGl0aW9uKSB7XG4gICAgICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSBhcnIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoY29uZGl0aW9uKGFycltpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFycltpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gbGlzdFxuICAgICAgICAgKiBAcGFyYW0gez99IGl0ZW1zXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBMaXN0V3JhcHBlci5yZW1vdmVBbGwgPSBmdW5jdGlvbiAobGlzdCwgaXRlbXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGluZGV4ID0gbGlzdC5pbmRleE9mKGl0ZW1zW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBsaXN0LnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBsaXN0XG4gICAgICAgICAqIEBwYXJhbSB7P30gZWxcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIExpc3RXcmFwcGVyLnJlbW92ZSA9IGZ1bmN0aW9uIChsaXN0LCBlbCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5kZXggPSBsaXN0LmluZGV4T2YoZWwpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICBsaXN0LnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGFcbiAgICAgICAgICogQHBhcmFtIHs/fSBiXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBMaXN0V3JhcHBlci5lcXVhbHMgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBsaXN0XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBMaXN0V3JhcHBlci5mbGF0dGVuID0gZnVuY3Rpb24gKGxpc3QpIHtcbiAgICAgICAgICAgIHJldHVybiBsaXN0LnJlZHVjZShmdW5jdGlvbiAoZmxhdCwgaXRlbSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZsYXRJdGVtID0gQXJyYXkuaXNBcnJheShpdGVtKSA/IExpc3RXcmFwcGVyLmZsYXR0ZW4oaXRlbSkgOiBpdGVtO1xuICAgICAgICAgICAgICAgIHJldHVybiAoKGZsYXQpKS5jb25jYXQoZmxhdEl0ZW0pO1xuICAgICAgICAgICAgfSwgW10pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gTGlzdFdyYXBwZXI7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG9ialxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNMaXN0TGlrZUl0ZXJhYmxlKG9iaikge1xuICAgICAgICBpZiAoIWlzSnNPYmplY3Qob2JqKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkob2JqKSB8fFxuICAgICAgICAgICAgKCEob2JqIGluc3RhbmNlb2YgTWFwKSAmJlxuICAgICAgICAgICAgICAgIGdldFN5bWJvbEl0ZXJhdG9yKCkgaW4gb2JqKTsgLy8gSlMgSXRlcmFibGUgaGF2ZSBhIFN5bWJvbC5pdGVyYXRvciBwcm9wXG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYVxuICAgICAqIEBwYXJhbSB7P30gYlxuICAgICAqIEBwYXJhbSB7P30gY29tcGFyYXRvclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJlSXRlcmFibGVzRXF1YWwoYSwgYiwgY29tcGFyYXRvcikge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpdGVyYXRvcjEgPSBhW2dldFN5bWJvbEl0ZXJhdG9yKCldKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGl0ZXJhdG9yMiA9IGJbZ2V0U3ltYm9sSXRlcmF0b3IoKV0oKTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGl0ZW0xID0gaXRlcmF0b3IxLm5leHQoKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGl0ZW0yID0gaXRlcmF0b3IyLm5leHQoKTtcbiAgICAgICAgICAgIGlmIChpdGVtMS5kb25lICYmIGl0ZW0yLmRvbmUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBpZiAoaXRlbTEuZG9uZSB8fCBpdGVtMi5kb25lKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmICghY29tcGFyYXRvcihpdGVtMS52YWx1ZSwgaXRlbTIudmFsdWUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG9ialxuICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGl0ZXJhdGVMaXN0TGlrZShvYmosIGZuKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmbihvYmpbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXRlcmF0b3IgPSBvYmpbZ2V0U3ltYm9sSXRlcmF0b3IoKV0oKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGl0ZW0gPSB2b2lkIDA7XG4gICAgICAgICAgICB3aGlsZSAoISgoaXRlbSA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkpIHtcbiAgICAgICAgICAgICAgICBmbihpdGVtLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSBpZiB0aGUgYXJndW1lbnQgaXMgc2hhcGVkIGxpa2UgYSBQcm9taXNlXG4gICAgICogQHBhcmFtIHs/fSBvYmpcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUHJvbWlzZShvYmopIHtcbiAgICAgICAgLy8gYWxsb3cgYW55IFByb21pc2UvQSsgY29tcGxpYW50IHRoZW5hYmxlLlxuICAgICAgICAvLyBJdCdzIHVwIHRvIHRoZSBjYWxsZXIgdG8gZW5zdXJlIHRoYXQgb2JqLnRoZW4gY29uZm9ybXMgdG8gdGhlIHNwZWNcbiAgICAgICAgcmV0dXJuICEhb2JqICYmIHR5cGVvZiBvYmoudGhlbiA9PT0gJ2Z1bmN0aW9uJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIGFuIGFwcGxpY2F0aW9uIGlzIGluaXRpYWxpemVkLlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBBUFBfSU5JVElBTElaRVIgPSBuZXcgT3BhcXVlVG9rZW4oJ0FwcGxpY2F0aW9uIEluaXRpYWxpemVyJyk7XG4gICAgLyoqXG4gICAgICogQSBjbGFzcyB0aGF0IHJlZmxlY3RzIHRoZSBzdGF0ZSBvZiBydW5uaW5nIHtcXEBsaW5rIEFQUF9JTklUSUFMSVpFUn1zLlxuICAgICAqXG4gICAgICogXFxAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIEFwcGxpY2F0aW9uSW5pdFN0YXR1cyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGFwcEluaXRzXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBBcHBsaWNhdGlvbkluaXRTdGF0dXMoYXBwSW5pdHMpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLl9kb25lID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgYXN5bmNJbml0UHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgIGlmIChhcHBJbml0cykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXBwSW5pdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluaXRSZXN1bHQgPSBhcHBJbml0c1tpXSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNQcm9taXNlKGluaXRSZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3luY0luaXRQcm9taXNlcy5wdXNoKGluaXRSZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZG9uZVByb21pc2UgPSBQcm9taXNlLmFsbChhc3luY0luaXRQcm9taXNlcykudGhlbihmdW5jdGlvbiAoKSB7IF90aGlzLl9kb25lID0gdHJ1ZTsgfSk7XG4gICAgICAgICAgICBpZiAoYXN5bmNJbml0UHJvbWlzZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFwcGxpY2F0aW9uSW5pdFN0YXR1cy5wcm90b3R5cGUsIFwiZG9uZVwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZG9uZTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcHBsaWNhdGlvbkluaXRTdGF0dXMucHJvdG90eXBlLCBcImRvbmVQcm9taXNlXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kb25lUHJvbWlzZTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIEFwcGxpY2F0aW9uSW5pdFN0YXR1cy5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBBcHBsaWNhdGlvbkluaXRTdGF0dXMuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgICAgICB7IHR5cGU6IEFycmF5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtBUFBfSU5JVElBTElaRVIsXSB9LCB7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgICAgICBdOyB9O1xuICAgICAgICByZXR1cm4gQXBwbGljYXRpb25Jbml0U3RhdHVzO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBBIERJIFRva2VuIHJlcHJlc2VudGluZyBhIHVuaXF1ZSBzdHJpbmcgaWQgYXNzaWduZWQgdG8gdGhlIGFwcGxpY2F0aW9uIGJ5IEFuZ3VsYXIgYW5kIHVzZWRcbiAgICAgKiBwcmltYXJpbHkgZm9yIHByZWZpeGluZyBhcHBsaWNhdGlvbiBhdHRyaWJ1dGVzIGFuZCBDU1Mgc3R5bGVzIHdoZW5cbiAgICAgKiB7QGxpbmsgVmlld0VuY2Fwc3VsYXRpb24jRW11bGF0ZWR9IGlzIGJlaW5nIHVzZWQuXG4gICAgICpcbiAgICAgKiBJZiB5b3UgbmVlZCB0byBhdm9pZCByYW5kb21seSBnZW5lcmF0ZWQgdmFsdWUgdG8gYmUgdXNlZCBhcyBhbiBhcHBsaWNhdGlvbiBpZCwgeW91IGNhbiBwcm92aWRlXG4gICAgICogYSBjdXN0b20gdmFsdWUgdmlhIGEgREkgcHJvdmlkZXIgPCEtLSBUT0RPOiBwcm92aWRlciAtLT4gY29uZmlndXJpbmcgdGhlIHJvb3Qge0BsaW5rIEluamVjdG9yfVxuICAgICAqIHVzaW5nIHRoaXMgdG9rZW4uXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIEFQUF9JRCA9IG5ldyBPcGFxdWVUb2tlbignQXBwSWQnKTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9hcHBJZFJhbmRvbVByb3ZpZGVyRmFjdG9yeSgpIHtcbiAgICAgICAgcmV0dXJuIFwiXCIgKyBfcmFuZG9tQ2hhcigpICsgX3JhbmRvbUNoYXIoKSArIF9yYW5kb21DaGFyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVycyB0aGF0IHdpbGwgZ2VuZXJhdGUgYSByYW5kb20gQVBQX0lEX1RPS0VOLlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBBUFBfSURfUkFORE9NX1BST1ZJREVSID0ge1xuICAgICAgICBwcm92aWRlOiBBUFBfSUQsXG4gICAgICAgIHVzZUZhY3Rvcnk6IF9hcHBJZFJhbmRvbVByb3ZpZGVyRmFjdG9yeSxcbiAgICAgICAgZGVwczogLyoqIEB0eXBlIHs/fSAqLyAoW10pLFxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfcmFuZG9tQ2hhcigpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoOTcgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyNSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIGEgcGxhdGZvcm0gaXMgaW5pdGlhbGl6ZWQuXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIFBMQVRGT1JNX0lOSVRJQUxJWkVSID0gbmV3IE9wYXF1ZVRva2VuKCdQbGF0Zm9ybSBJbml0aWFsaXplcicpO1xuICAgIC8qKlxuICAgICAqIEFsbCBjYWxsYmFja3MgcHJvdmlkZWQgdmlhIHRoaXMgdG9rZW4gd2lsbCBiZSBjYWxsZWQgZm9yIGV2ZXJ5IGNvbXBvbmVudCB0aGF0IGlzIGJvb3RzdHJhcHBlZC5cbiAgICAgKiBTaWduYXR1cmUgb2YgdGhlIGNhbGxiYWNrOlxuICAgICAqXG4gICAgICogYChjb21wb25lbnRSZWY6IENvbXBvbmVudFJlZikgPT4gdm9pZGAuXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gQVBQX0JPT1RTVFJBUF9MSVNURU5FUiA9IG5ldyBPcGFxdWVUb2tlbignYXBwQm9vdHN0cmFwTGlzdGVuZXInKTtcbiAgICAvKipcbiAgICAgKiBBIHRva2VuIHdoaWNoIGluZGljYXRlcyB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhlIGFwcGxpY2F0aW9uXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIFBBQ0tBR0VfUk9PVF9VUkwgPSBuZXcgT3BhcXVlVG9rZW4oJ0FwcGxpY2F0aW9uIFBhY2thZ2VzIFJvb3QgVVJMJyk7XG5cbiAgICB2YXIgQ29uc29sZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIENvbnNvbGUoKSB7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gbWVzc2FnZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQ29uc29sZS5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHsgcHJpbnQobWVzc2FnZSk7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IG1lc3NhZ2VcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIENvbnNvbGUucHJvdG90eXBlLndhcm4gPSBmdW5jdGlvbiAobWVzc2FnZSkgeyB3YXJuKG1lc3NhZ2UpOyB9O1xuICAgICAgICBDb25zb2xlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IEluamVjdGFibGUgfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIENvbnNvbGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbiAgICAgICAgcmV0dXJuIENvbnNvbGU7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDQgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhhdCBhIGNvbXBvbmVudCBpcyBzdGlsbCBiZWluZyBsb2FkZWQgaW4gYSBzeW5jaHJvbm91cyBjb21waWxlLlxuICAgICAqXG4gICAgICogXFxAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIENvbXBvbmVudFN0aWxsTG9hZGluZ0Vycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDQoQ29tcG9uZW50U3RpbGxMb2FkaW5nRXJyb3IsIF9zdXBlcik7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGNvbXBUeXBlXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBDb21wb25lbnRTdGlsbExvYWRpbmdFcnJvcihjb21wVHlwZSkge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgXCJDYW4ndCBjb21waWxlIHN5bmNocm9ub3VzbHkgYXMgXCIgKyBzdHJpbmdpZnkoY29tcFR5cGUpICsgXCIgaXMgc3RpbGwgYmVpbmcgbG9hZGVkIVwiKTtcbiAgICAgICAgICAgIHRoaXMuY29tcFR5cGUgPSBjb21wVHlwZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ29tcG9uZW50U3RpbGxMb2FkaW5nRXJyb3I7XG4gICAgfShCYXNlRXJyb3IpKTtcbiAgICAvKipcbiAgICAgKiBDb21iaW5hdGlvbiBvZiBOZ01vZHVsZUZhY3RvcnkgYW5kIENvbXBvbmVudEZhY3RvcnlzLlxuICAgICAqXG4gICAgICogXFxAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIE1vZHVsZVdpdGhDb21wb25lbnRGYWN0b3JpZXMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBuZ01vZHVsZUZhY3RvcnlcbiAgICAgICAgICogQHBhcmFtIHs/fSBjb21wb25lbnRGYWN0b3JpZXNcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIE1vZHVsZVdpdGhDb21wb25lbnRGYWN0b3JpZXMobmdNb2R1bGVGYWN0b3J5LCBjb21wb25lbnRGYWN0b3JpZXMpIHtcbiAgICAgICAgICAgIHRoaXMubmdNb2R1bGVGYWN0b3J5ID0gbmdNb2R1bGVGYWN0b3J5O1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRGYWN0b3JpZXMgPSBjb21wb25lbnRGYWN0b3JpZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1vZHVsZVdpdGhDb21wb25lbnRGYWN0b3JpZXM7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF90aHJvd0Vycm9yKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSdW50aW1lIGNvbXBpbGVyIGlzIG5vdCBsb2FkZWRcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvdy1sZXZlbCBzZXJ2aWNlIGZvciBydW5uaW5nIHRoZSBhbmd1bGFyIGNvbXBpbGVyIGR1cmluZyBydW50aW1lXG4gICAgICogdG8gY3JlYXRlIHtcXEBsaW5rIENvbXBvbmVudEZhY3Rvcnl9cywgd2hpY2hcbiAgICAgKiBjYW4gbGF0ZXIgYmUgdXNlZCB0byBjcmVhdGUgYW5kIHJlbmRlciBhIENvbXBvbmVudCBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEVhY2ggYFxcQE5nTW9kdWxlYCBwcm92aWRlcyBhbiBvd24gYENvbXBpbGVyYCB0byBpdHMgaW5qZWN0b3IsXG4gICAgICogdGhhdCB3aWxsIHVzZSB0aGUgZGlyZWN0aXZlcy9waXBlcyBvZiB0aGUgbmcgbW9kdWxlIGZvciBjb21waWxhdGlvblxuICAgICAqIG9mIGNvbXBvbmVudHMuXG4gICAgICogXFxAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIENvbXBpbGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQ29tcGlsZXIoKSB7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbXBpbGVzIHRoZSBnaXZlbiBOZ01vZHVsZSBhbmQgYWxsIG9mIGl0cyBjb21wb25lbnRzLiBBbGwgdGVtcGxhdGVzIG9mIHRoZSBjb21wb25lbnRzIGxpc3RlZFxuICAgICAgICAgKiBpbiBgZW50cnlDb21wb25lbnRzYFxuICAgICAgICAgKiBoYXZlIHRvIGJlIGlubGluZWQuIE90aGVyd2lzZSB0aHJvd3MgYSB7XFxAbGluayBDb21wb25lbnRTdGlsbExvYWRpbmdFcnJvcn0uXG4gICAgICAgICAqIEBwYXJhbSB7P30gbW9kdWxlVHlwZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQ29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGVNb2R1bGVTeW5jID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUpIHsgdGhyb3cgX3Rocm93RXJyb3IoKTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbXBpbGVzIHRoZSBnaXZlbiBOZ01vZHVsZSBhbmQgYWxsIG9mIGl0cyBjb21wb25lbnRzXG4gICAgICAgICAqIEBwYXJhbSB7P30gbW9kdWxlVHlwZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQ29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGVNb2R1bGVBc3luYyA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlKSB7IHRocm93IF90aHJvd0Vycm9yKCk7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTYW1lIGFzIHtcXEBsaW5rIGNvbXBpbGVNb2R1bGVTeW5jfSBidXQgYWxzbyBjcmVhdGVzIENvbXBvbmVudEZhY3RvcmllcyBmb3IgYWxsIGNvbXBvbmVudHMuXG4gICAgICAgICAqIEBwYXJhbSB7P30gbW9kdWxlVHlwZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQ29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGVNb2R1bGVBbmRBbGxDb21wb25lbnRzU3luYyA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBfdGhyb3dFcnJvcigpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2FtZSBhcyB7XFxAbGluayBjb21waWxlTW9kdWxlQXN5bmN9IGJ1dCBhbHNvIGNyZWF0ZXMgQ29tcG9uZW50RmFjdG9yaWVzIGZvciBhbGwgY29tcG9uZW50cy5cbiAgICAgICAgICogQHBhcmFtIHs/fSBtb2R1bGVUeXBlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBDb21waWxlci5wcm90b3R5cGUuY29tcGlsZU1vZHVsZUFuZEFsbENvbXBvbmVudHNBc3luYyA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBfdGhyb3dFcnJvcigpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRXhwb3NlcyB0aGUgQ1NTLXN0eWxlIHNlbGVjdG9ycyB0aGF0IGhhdmUgYmVlbiB1c2VkIGluIGBuZ0NvbnRlbnRgIGRpcmVjdGl2ZXMgd2l0aGluXG4gICAgICAgICAqIHRoZSB0ZW1wbGF0ZSBvZiB0aGUgZ2l2ZW4gY29tcG9uZW50LlxuICAgICAgICAgKiBUaGlzIGlzIHVzZWQgYnkgdGhlIGB1cGdyYWRlYCBsaWJyYXJ5IHRvIGNvbXBpbGUgdGhlIGFwcHJvcHJpYXRlIHRyYW5zY2x1ZGUgY29udGVudFxuICAgICAgICAgKiBpbiB0aGUgQW5ndWxhciAxIHdyYXBwZXIgY29tcG9uZW50LlxuICAgICAgICAgKiBAcGFyYW0gez99IGNvbXBvbmVudFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQ29tcGlsZXIucHJvdG90eXBlLmdldE5nQ29udGVudFNlbGVjdG9ycyA9IGZ1bmN0aW9uIChjb21wb25lbnQpIHsgdGhyb3cgX3Rocm93RXJyb3IoKTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsZWFycyBhbGwgY2FjaGVzLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQ29tcGlsZXIucHJvdG90eXBlLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbGVhcnMgdGhlIGNhY2hlIGZvciB0aGUgZ2l2ZW4gY29tcG9uZW50L25nTW9kdWxlLlxuICAgICAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIENvbXBpbGVyLnByb3RvdHlwZS5jbGVhckNhY2hlRm9yID0gZnVuY3Rpb24gKHR5cGUpIHsgfTtcbiAgICAgICAgQ29tcGlsZXIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgQ29tcGlsZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcbiAgICAgICAgcmV0dXJuIENvbXBpbGVyO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogVG9rZW4gdG8gcHJvdmlkZSBDb21waWxlck9wdGlvbnMgaW4gdGhlIHBsYXRmb3JtIGluamVjdG9yLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIENPTVBJTEVSX09QVElPTlMgPSBuZXcgT3BhcXVlVG9rZW4oJ2NvbXBpbGVyT3B0aW9ucycpO1xuICAgIC8qKlxuICAgICAqIEEgZmFjdG9yeSBmb3IgY3JlYXRpbmcgYSBDb21waWxlclxuICAgICAqXG4gICAgICogXFxAZXhwZXJpbWVudGFsXG4gICAgICogQGFic3RyYWN0XG4gICAgICovXG4gICAgdmFyIENvbXBpbGVyRmFjdG9yeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIENvbXBpbGVyRmFjdG9yeSgpIHtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqIEBwYXJhbSB7Pz19IG9wdGlvbnNcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIENvbXBpbGVyRmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlQ29tcGlsZXIgPSBmdW5jdGlvbiAob3B0aW9ucykgeyB9O1xuICAgICAgICByZXR1cm4gQ29tcGlsZXJGYWN0b3J5O1xuICAgIH0oKSk7XG5cbiAgICB2YXIgRWxlbWVudFJlZiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IG5hdGl2ZUVsZW1lbnRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIEVsZW1lbnRSZWYobmF0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5uYXRpdmVFbGVtZW50ID0gbmF0aXZlRWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRWxlbWVudFJlZjtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkNiA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVzZSBieSBkaXJlY3RpdmVzIGFuZCBjb21wb25lbnRzIHRvIGVtaXQgY3VzdG9tIEV2ZW50cy5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlc1xuICAgICAqXG4gICAgICogSW4gdGhlIGZvbGxvd2luZyBleGFtcGxlLCBgWmlwcHlgIGFsdGVybmF0aXZlbHkgZW1pdHMgYG9wZW5gIGFuZCBgY2xvc2VgIGV2ZW50cyB3aGVuIGl0c1xuICAgICAqIHRpdGxlIGdldHMgY2xpY2tlZDpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIFxcQENvbXBvbmVudCh7XG4gICAgICogICBzZWxlY3RvcjogJ3ppcHB5JyxcbiAgICAgKiAgIHRlbXBsYXRlOiBgXG4gICAgICogICA8ZGl2IGNsYXNzPVwiemlwcHlcIj5cbiAgICAgKiAgICAgPGRpdiAoY2xpY2spPVwidG9nZ2xlKClcIj5Ub2dnbGU8L2Rpdj5cbiAgICAgKiAgICAgPGRpdiBbaGlkZGVuXT1cIiF2aXNpYmxlXCI+XG4gICAgICogICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgICAqICAgICA8L2Rpdj5cbiAgICAgKiAgPC9kaXY+YH0pXG4gICAgICogZXhwb3J0IGNsYXNzIFppcHB5IHtcbiAgICAgKiAgIHZpc2libGU6IGJvb2xlYW4gPSB0cnVlO1xuICAgICAqICAgXFxAT3V0cHV0KCkgb3BlbjogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICogICBcXEBPdXRwdXQoKSBjbG9zZTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICpcbiAgICAgKiAgIHRvZ2dsZSgpIHtcbiAgICAgKiAgICAgdGhpcy52aXNpYmxlID0gIXRoaXMudmlzaWJsZTtcbiAgICAgKiAgICAgaWYgKHRoaXMudmlzaWJsZSkge1xuICAgICAqICAgICAgIHRoaXMub3Blbi5lbWl0KG51bGwpO1xuICAgICAqICAgICB9IGVsc2Uge1xuICAgICAqICAgICAgIHRoaXMuY2xvc2UuZW1pdChudWxsKTtcbiAgICAgKiAgICAgfVxuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFRoZSBldmVudHMgcGF5bG9hZCBjYW4gYmUgYWNjZXNzZWQgYnkgdGhlIHBhcmFtZXRlciBgJGV2ZW50YCBvbiB0aGUgY29tcG9uZW50cyBvdXRwdXQgZXZlbnRcbiAgICAgKiBoYW5kbGVyOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogPHppcHB5IChvcGVuKT1cIm9uT3BlbigkZXZlbnQpXCIgKGNsb3NlKT1cIm9uQ2xvc2UoJGV2ZW50KVwiPjwvemlwcHk+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBVc2VzIFJ4Lk9ic2VydmFibGUgYnV0IHByb3ZpZGVzIGFuIGFkYXB0ZXIgdG8gbWFrZSBpdCB3b3JrIGFzIHNwZWNpZmllZCBoZXJlOlxuICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9qaHVzYWluL29ic2VydmFibGUtc3BlY1xuICAgICAqXG4gICAgICogT25jZSBhIHJlZmVyZW5jZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgc3BlYyBpcyBhdmFpbGFibGUsIHN3aXRjaCB0byBpdC5cbiAgICAgKiBcXEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgRXZlbnRFbWl0dGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDYoRXZlbnRFbWl0dGVyLCBfc3VwZXIpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBbRXZlbnRFbWl0dGVyXSwgd2hpY2ggZGVwZW5kaW5nIG9uIFtpc0FzeW5jXSxcbiAgICAgICAgICogZGVsaXZlcnMgZXZlbnRzIHN5bmNocm9ub3VzbHkgb3IgYXN5bmNocm9ub3VzbHkuXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IGlzQXN5bmNcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIEV2ZW50RW1pdHRlcihpc0FzeW5jKSB7XG4gICAgICAgICAgICBpZiAoaXNBc3luYyA9PT0gdm9pZCAwKSB7IGlzQXN5bmMgPSBmYWxzZTsgfVxuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9faXNBc3luYyA9IGlzQXN5bmM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAodmFsdWUpIHsgX3N1cGVyLnByb3RvdHlwZS5uZXh0LmNhbGwodGhpcywgdmFsdWUpOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/PX0gZ2VuZXJhdG9yT3JOZXh0XG4gICAgICAgICAqIEBwYXJhbSB7Pz19IGVycm9yXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IGNvbXBsZXRlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIChnZW5lcmF0b3JPck5leHQsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2NoZWR1bGVyRm47XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlcnJvckZuID0gZnVuY3Rpb24gKGVycikgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbXBsZXRlRm4gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgICAgICAgaWYgKGdlbmVyYXRvck9yTmV4dCAmJiB0eXBlb2YgZ2VuZXJhdG9yT3JOZXh0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHNjaGVkdWxlckZuID0gdGhpcy5fX2lzQXN5bmMgPyBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBnZW5lcmF0b3JPck5leHQubmV4dCh2YWx1ZSk7IH0pO1xuICAgICAgICAgICAgICAgIH0gOiBmdW5jdGlvbiAodmFsdWUpIHsgZ2VuZXJhdG9yT3JOZXh0Lm5leHQodmFsdWUpOyB9O1xuICAgICAgICAgICAgICAgIGlmIChnZW5lcmF0b3JPck5leHQuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JGbiA9IHRoaXMuX19pc0FzeW5jID8gZnVuY3Rpb24gKGVycikgeyBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdlbmVyYXRvck9yTmV4dC5lcnJvcihlcnIpOyB9KTsgfSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZXJyKSB7IGdlbmVyYXRvck9yTmV4dC5lcnJvcihlcnIpOyB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZ2VuZXJhdG9yT3JOZXh0LmNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlRm4gPSB0aGlzLl9faXNBc3luYyA/IGZ1bmN0aW9uICgpIHsgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBnZW5lcmF0b3JPck5leHQuY29tcGxldGUoKTsgfSk7IH0gOlxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyBnZW5lcmF0b3JPck5leHQuY29tcGxldGUoKTsgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzY2hlZHVsZXJGbiA9IHRoaXMuX19pc0FzeW5jID8gZnVuY3Rpb24gKHZhbHVlKSB7IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2VuZXJhdG9yT3JOZXh0KHZhbHVlKTsgfSk7IH0gOlxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAodmFsdWUpIHsgZ2VuZXJhdG9yT3JOZXh0KHZhbHVlKTsgfTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JGbiA9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9faXNBc3luYyA/IGZ1bmN0aW9uIChlcnIpIHsgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBlcnJvcihlcnIpOyB9KTsgfSA6IGZ1bmN0aW9uIChlcnIpIHsgZXJyb3IoZXJyKTsgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlRm4gPVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2lzQXN5bmMgPyBmdW5jdGlvbiAoKSB7IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gY29tcGxldGUoKTsgfSk7IH0gOiBmdW5jdGlvbiAoKSB7IGNvbXBsZXRlKCk7IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuc3Vic2NyaWJlLmNhbGwodGhpcywgc2NoZWR1bGVyRm4sIGVycm9yRm4sIGNvbXBsZXRlRm4pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRXZlbnRFbWl0dGVyO1xuICAgIH0ocnhqc19TdWJqZWN0LlN1YmplY3QpKTtcblxuICAgIC8qKlxuICAgICAqIEFuIGluamVjdGFibGUgc2VydmljZSBmb3IgZXhlY3V0aW5nIHdvcmsgaW5zaWRlIG9yIG91dHNpZGUgb2YgdGhlIEFuZ3VsYXIgem9uZS5cbiAgICAgKlxuICAgICAqIFRoZSBtb3N0IGNvbW1vbiB1c2Ugb2YgdGhpcyBzZXJ2aWNlIGlzIHRvIG9wdGltaXplIHBlcmZvcm1hbmNlIHdoZW4gc3RhcnRpbmcgYSB3b3JrIGNvbnNpc3Rpbmcgb2ZcbiAgICAgKiBvbmUgb3IgbW9yZSBhc3luY2hyb25vdXMgdGFza3MgdGhhdCBkb24ndCByZXF1aXJlIFVJIHVwZGF0ZXMgb3IgZXJyb3IgaGFuZGxpbmcgdG8gYmUgaGFuZGxlZCBieVxuICAgICAqIEFuZ3VsYXIuIFN1Y2ggdGFza3MgY2FuIGJlIGtpY2tlZCBvZmYgdmlhIHtcXEBsaW5rIHJ1bk91dHNpZGVBbmd1bGFyfSBhbmQgaWYgbmVlZGVkLCB0aGVzZSB0YXNrc1xuICAgICAqIGNhbiByZWVudGVyIHRoZSBBbmd1bGFyIHpvbmUgdmlhIHtcXEBsaW5rIHJ1bn0uXG4gICAgICpcbiAgICAgKiA8IS0tIFRPRE86IGFkZC9maXggbGlua3MgdG86XG4gICAgICogICAtIGRvY3MgZXhwbGFpbmluZyB6b25lcyBhbmQgdGhlIHVzZSBvZiB6b25lcyBpbiBBbmd1bGFyIGFuZCBjaGFuZ2UtZGV0ZWN0aW9uXG4gICAgICogICAtIGxpbmsgdG8gcnVuT3V0c2lkZUFuZ3VsYXIvcnVuICh0aHJvdWdob3V0IHRoaXMgZmlsZSEpXG4gICAgICogICAtLT5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICogYGBgXG4gICAgICogaW1wb3J0IHtDb21wb25lbnQsIE5nWm9uZX0gZnJvbSAnXFxAYW5ndWxhci9jb3JlJztcbiAgICAgKiBpbXBvcnQge05nSWZ9IGZyb20gJ1xcQGFuZ3VsYXIvY29tbW9uJztcbiAgICAgKlxuICAgICAqIFxcQENvbXBvbmVudCh7XG4gICAgICogICBzZWxlY3RvcjogJ25nLXpvbmUtZGVtbycuXG4gICAgICogICB0ZW1wbGF0ZTogYFxuICAgICAqICAgICA8aDI+RGVtbzogTmdab25lPC9oMj5cbiAgICAgKlxuICAgICAqICAgICA8cD5Qcm9ncmVzczoge3twcm9ncmVzc319JTwvcD5cbiAgICAgKiAgICAgPHAgKm5nSWY9XCJwcm9ncmVzcyA+PSAxMDBcIj5Eb25lIHByb2Nlc3Npbmcge3tsYWJlbH19IG9mIEFuZ3VsYXIgem9uZSE8L3A+XG4gICAgICpcbiAgICAgKiAgICAgPGJ1dHRvbiAoY2xpY2spPVwicHJvY2Vzc1dpdGhpbkFuZ3VsYXJab25lKClcIj5Qcm9jZXNzIHdpdGhpbiBBbmd1bGFyIHpvbmU8L2J1dHRvbj5cbiAgICAgKiAgICAgPGJ1dHRvbiAoY2xpY2spPVwicHJvY2Vzc091dHNpZGVPZkFuZ3VsYXJab25lKClcIj5Qcm9jZXNzIG91dHNpZGUgb2YgQW5ndWxhciB6b25lPC9idXR0b24+XG4gICAgICogICBgLFxuICAgICAqIH0pXG4gICAgICogZXhwb3J0IGNsYXNzIE5nWm9uZURlbW8ge1xuICAgICAqICAgcHJvZ3Jlc3M6IG51bWJlciA9IDA7XG4gICAgICogICBsYWJlbDogc3RyaW5nO1xuICAgICAqXG4gICAgICogICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9uZ1pvbmU6IE5nWm9uZSkge31cbiAgICAgKlxuICAgICAqICAgLy8gTG9vcCBpbnNpZGUgdGhlIEFuZ3VsYXIgem9uZVxuICAgICAqICAgLy8gc28gdGhlIFVJIERPRVMgcmVmcmVzaCBhZnRlciBlYWNoIHNldFRpbWVvdXQgY3ljbGVcbiAgICAgKiAgIHByb2Nlc3NXaXRoaW5Bbmd1bGFyWm9uZSgpIHtcbiAgICAgKiAgICAgdGhpcy5sYWJlbCA9ICdpbnNpZGUnO1xuICAgICAqICAgICB0aGlzLnByb2dyZXNzID0gMDtcbiAgICAgKiAgICAgdGhpcy5faW5jcmVhc2VQcm9ncmVzcygoKSA9PiBjb25zb2xlLmxvZygnSW5zaWRlIERvbmUhJykpO1xuICAgICAqICAgfVxuICAgICAqXG4gICAgICogICAvLyBMb29wIG91dHNpZGUgb2YgdGhlIEFuZ3VsYXIgem9uZVxuICAgICAqICAgLy8gc28gdGhlIFVJIERPRVMgTk9UIHJlZnJlc2ggYWZ0ZXIgZWFjaCBzZXRUaW1lb3V0IGN5Y2xlXG4gICAgICogICBwcm9jZXNzT3V0c2lkZU9mQW5ndWxhclpvbmUoKSB7XG4gICAgICogICAgIHRoaXMubGFiZWwgPSAnb3V0c2lkZSc7XG4gICAgICogICAgIHRoaXMucHJvZ3Jlc3MgPSAwO1xuICAgICAqICAgICB0aGlzLl9uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAqICAgICAgIHRoaXMuX2luY3JlYXNlUHJvZ3Jlc3MoKCkgPT4ge1xuICAgICAqICAgICAgIC8vIHJlZW50ZXIgdGhlIEFuZ3VsYXIgem9uZSBhbmQgZGlzcGxheSBkb25lXG4gICAgICogICAgICAgdGhpcy5fbmdab25lLnJ1bigoKSA9PiB7Y29uc29sZS5sb2coJ091dHNpZGUgRG9uZSEnKSB9KTtcbiAgICAgKiAgICAgfX0pKTtcbiAgICAgKiAgIH1cbiAgICAgKlxuICAgICAqICAgX2luY3JlYXNlUHJvZ3Jlc3MoZG9uZUNhbGxiYWNrOiAoKSA9PiB2b2lkKSB7XG4gICAgICogICAgIHRoaXMucHJvZ3Jlc3MgKz0gMTtcbiAgICAgKiAgICAgY29uc29sZS5sb2coYEN1cnJlbnQgcHJvZ3Jlc3M6ICR7dGhpcy5wcm9ncmVzc30lYCk7XG4gICAgICpcbiAgICAgKiAgICAgaWYgKHRoaXMucHJvZ3Jlc3MgPCAxMDApIHtcbiAgICAgKiAgICAgICB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB0aGlzLl9pbmNyZWFzZVByb2dyZXNzKGRvbmVDYWxsYmFjaykpLCAxMClcbiAgICAgKiAgICAgfSBlbHNlIHtcbiAgICAgKiAgICAgICBkb25lQ2FsbGJhY2soKTtcbiAgICAgKiAgICAgfVxuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKiBcXEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgTmdab25lID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gX18wXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBOZ1pvbmUoX2EpIHtcbiAgICAgICAgICAgIHZhciBfYiA9IF9hLmVuYWJsZUxvbmdTdGFja1RyYWNlLCBlbmFibGVMb25nU3RhY2tUcmFjZSA9IF9iID09PSB2b2lkIDAgPyBmYWxzZSA6IF9iO1xuICAgICAgICAgICAgdGhpcy5faGFzUGVuZGluZ01pY3JvdGFza3MgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2hhc1BlbmRpbmdNYWNyb3Rhc2tzID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pc1N0YWJsZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9uZXN0aW5nID0gMDtcbiAgICAgICAgICAgIHRoaXMuX29uVW5zdGFibGUgPSBuZXcgRXZlbnRFbWl0dGVyKGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuX29uTWljcm90YXNrRW1wdHkgPSBuZXcgRXZlbnRFbWl0dGVyKGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuX29uU3RhYmxlID0gbmV3IEV2ZW50RW1pdHRlcihmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLl9vbkVycm9yRXZlbnRzID0gbmV3IEV2ZW50RW1pdHRlcihmYWxzZSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIFpvbmUgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FuZ3VsYXIgcmVxdWlyZXMgWm9uZS5qcyBwcm9seWZpbGwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBab25lLmFzc2VydFpvbmVQYXRjaGVkKCk7XG4gICAgICAgICAgICB0aGlzLm91dGVyID0gdGhpcy5pbm5lciA9IFpvbmUuY3VycmVudDtcbiAgICAgICAgICAgIGlmIChab25lWyd3dGZab25lU3BlYyddKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbm5lciA9IHRoaXMuaW5uZXIuZm9yayhab25lWyd3dGZab25lU3BlYyddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbmFibGVMb25nU3RhY2tUcmFjZSAmJiBab25lWydsb25nU3RhY2tUcmFjZVpvbmVTcGVjJ10pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlubmVyID0gdGhpcy5pbm5lci5mb3JrKFpvbmVbJ2xvbmdTdGFja1RyYWNlWm9uZVNwZWMnXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmZvcmtJbm5lclpvbmVXaXRoQW5ndWxhckJlaGF2aW9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBOZ1pvbmUuaXNJbkFuZ3VsYXJab25lID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gWm9uZS5jdXJyZW50LmdldCgnaXNBbmd1bGFyWm9uZScpID09PSB0cnVlOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIE5nWm9uZS5hc3NlcnRJbkFuZ3VsYXJab25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFOZ1pvbmUuaXNJbkFuZ3VsYXJab25lKCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIGJlIGluIEFuZ3VsYXIgWm9uZSwgYnV0IGl0IGlzIG5vdCEnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBOZ1pvbmUuYXNzZXJ0Tm90SW5Bbmd1bGFyWm9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChOZ1pvbmUuaXNJbkFuZ3VsYXJab25lKCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIG5vdCBiZSBpbiBBbmd1bGFyIFpvbmUsIGJ1dCBpdCBpcyEnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV4ZWN1dGVzIHRoZSBgZm5gIGZ1bmN0aW9uIHN5bmNocm9ub3VzbHkgd2l0aGluIHRoZSBBbmd1bGFyIHpvbmUgYW5kIHJldHVybnMgdmFsdWUgcmV0dXJuZWQgYnlcbiAgICAgICAgICogdGhlIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBSdW5uaW5nIGZ1bmN0aW9ucyB2aWEgYHJ1bmAgYWxsb3dzIHlvdSB0byByZWVudGVyIEFuZ3VsYXIgem9uZSBmcm9tIGEgdGFzayB0aGF0IHdhcyBleGVjdXRlZFxuICAgICAgICAgKiBvdXRzaWRlIG9mIHRoZSBBbmd1bGFyIHpvbmUgKHR5cGljYWxseSBzdGFydGVkIHZpYSB7XFxAbGluayBydW5PdXRzaWRlQW5ndWxhcn0pLlxuICAgICAgICAgKlxuICAgICAgICAgKiBBbnkgZnV0dXJlIHRhc2tzIG9yIG1pY3JvdGFza3Mgc2NoZWR1bGVkIGZyb20gd2l0aGluIHRoaXMgZnVuY3Rpb24gd2lsbCBjb250aW51ZSBleGVjdXRpbmcgZnJvbVxuICAgICAgICAgKiB3aXRoaW4gdGhlIEFuZ3VsYXIgem9uZS5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgYSBzeW5jaHJvbm91cyBlcnJvciBoYXBwZW5zIGl0IHdpbGwgYmUgcmV0aHJvd24gYW5kIG5vdCByZXBvcnRlZCB2aWEgYG9uRXJyb3JgLlxuICAgICAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBOZ1pvbmUucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIChmbikgeyByZXR1cm4gdGhpcy5pbm5lci5ydW4oZm4pOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2FtZSBhcyBgcnVuYCwgZXhjZXB0IHRoYXQgc3luY2hyb25vdXMgZXJyb3JzIGFyZSBjYXVnaHQgYW5kIGZvcndhcmRlZCB2aWEgYG9uRXJyb3JgIGFuZCBub3RcbiAgICAgICAgICogcmV0aHJvd24uXG4gICAgICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIE5nWm9uZS5wcm90b3R5cGUucnVuR3VhcmRlZCA9IGZ1bmN0aW9uIChmbikgeyByZXR1cm4gdGhpcy5pbm5lci5ydW5HdWFyZGVkKGZuKTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV4ZWN1dGVzIHRoZSBgZm5gIGZ1bmN0aW9uIHN5bmNocm9ub3VzbHkgaW4gQW5ndWxhcidzIHBhcmVudCB6b25lIGFuZCByZXR1cm5zIHZhbHVlIHJldHVybmVkIGJ5XG4gICAgICAgICAqIHRoZSBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogUnVubmluZyBmdW5jdGlvbnMgdmlhIGBydW5PdXRzaWRlQW5ndWxhcmAgYWxsb3dzIHlvdSB0byBlc2NhcGUgQW5ndWxhcidzIHpvbmUgYW5kIGRvIHdvcmsgdGhhdFxuICAgICAgICAgKiBkb2Vzbid0IHRyaWdnZXIgQW5ndWxhciBjaGFuZ2UtZGV0ZWN0aW9uIG9yIGlzIHN1YmplY3QgdG8gQW5ndWxhcidzIGVycm9yIGhhbmRsaW5nLlxuICAgICAgICAgKlxuICAgICAgICAgKiBBbnkgZnV0dXJlIHRhc2tzIG9yIG1pY3JvdGFza3Mgc2NoZWR1bGVkIGZyb20gd2l0aGluIHRoaXMgZnVuY3Rpb24gd2lsbCBjb250aW51ZSBleGVjdXRpbmcgZnJvbVxuICAgICAgICAgKiBvdXRzaWRlIG9mIHRoZSBBbmd1bGFyIHpvbmUuXG4gICAgICAgICAqXG4gICAgICAgICAqIFVzZSB7XFxAbGluayBydW59IHRvIHJlZW50ZXIgdGhlIEFuZ3VsYXIgem9uZSBhbmQgZG8gd29yayB0aGF0IHVwZGF0ZXMgdGhlIGFwcGxpY2F0aW9uIG1vZGVsLlxuICAgICAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBOZ1pvbmUucHJvdG90eXBlLnJ1bk91dHNpZGVBbmd1bGFyID0gZnVuY3Rpb24gKGZuKSB7IHJldHVybiB0aGlzLm91dGVyLnJ1bihmbik7IH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ1pvbmUucHJvdG90eXBlLCBcIm9uVW5zdGFibGVcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBOb3RpZmllcyB3aGVuIGNvZGUgZW50ZXJzIEFuZ3VsYXIgWm9uZS4gVGhpcyBnZXRzIGZpcmVkIGZpcnN0IG9uIFZNIFR1cm4uXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX29uVW5zdGFibGU7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdab25lLnByb3RvdHlwZSwgXCJvbk1pY3JvdGFza0VtcHR5XCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTm90aWZpZXMgd2hlbiB0aGVyZSBpcyBubyBtb3JlIG1pY3JvdGFza3MgZW5xdWV1ZSBpbiB0aGUgY3VycmVudCBWTSBUdXJuLlxuICAgICAgICAgICAgICogVGhpcyBpcyBhIGhpbnQgZm9yIEFuZ3VsYXIgdG8gZG8gY2hhbmdlIGRldGVjdGlvbiwgd2hpY2ggbWF5IGVucXVldWUgbW9yZSBtaWNyb3Rhc2tzLlxuICAgICAgICAgICAgICogRm9yIHRoaXMgcmVhc29uIHRoaXMgZXZlbnQgY2FuIGZpcmUgbXVsdGlwbGUgdGltZXMgcGVyIFZNIFR1cm4uXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX29uTWljcm90YXNrRW1wdHk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdab25lLnByb3RvdHlwZSwgXCJvblN0YWJsZVwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE5vdGlmaWVzIHdoZW4gdGhlIGxhc3QgYG9uTWljcm90YXNrRW1wdHlgIGhhcyBydW4gYW5kIHRoZXJlIGFyZSBubyBtb3JlIG1pY3JvdGFza3MsIHdoaWNoXG4gICAgICAgICAgICAgKiBpbXBsaWVzIHdlIGFyZSBhYm91dCB0byByZWxpbnF1aXNoIFZNIHR1cm4uXG4gICAgICAgICAgICAgKiBUaGlzIGV2ZW50IGdldHMgY2FsbGVkIGp1c3Qgb25jZS5cbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fb25TdGFibGU7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdab25lLnByb3RvdHlwZSwgXCJvbkVycm9yXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTm90aWZ5IHRoYXQgYW4gZXJyb3IgaGFzIGJlZW4gZGVsaXZlcmVkLlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9vbkVycm9yRXZlbnRzOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nWm9uZS5wcm90b3R5cGUsIFwiaXNTdGFibGVcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXaGV0aGVyIHRoZXJlIGFyZSBubyBvdXRzdGFuZGluZyBtaWNyb3Rhc2tzIG9yIG1hY3JvdGFza3MuXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2lzU3RhYmxlOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nWm9uZS5wcm90b3R5cGUsIFwiaGFzUGVuZGluZ01pY3JvdGFza3NcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2hhc1BlbmRpbmdNaWNyb3Rhc2tzOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nWm9uZS5wcm90b3R5cGUsIFwiaGFzUGVuZGluZ01hY3JvdGFza3NcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2hhc1BlbmRpbmdNYWNyb3Rhc2tzOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBOZ1pvbmUucHJvdG90eXBlLmNoZWNrU3RhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGlmICh0aGlzLl9uZXN0aW5nID09IDAgJiYgIXRoaXMuX2hhc1BlbmRpbmdNaWNyb3Rhc2tzICYmICF0aGlzLl9pc1N0YWJsZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX25lc3RpbmcrKztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25NaWNyb3Rhc2tFbXB0eS5lbWl0KG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbmVzdGluZy0tO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2hhc1BlbmRpbmdNaWNyb3Rhc2tzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucnVuT3V0c2lkZUFuZ3VsYXIoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX29uU3RhYmxlLmVtaXQobnVsbCk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faXNTdGFibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIE5nWm9uZS5wcm90b3R5cGUuZm9ya0lubmVyWm9uZVdpdGhBbmd1bGFyQmVoYXZpb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5pbm5lciA9IHRoaXMuaW5uZXIuZm9yayh7XG4gICAgICAgICAgICAgICAgbmFtZTogJ2FuZ3VsYXInLFxuICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IC8qKiBAdHlwZSB7P30gKi8gKHsgJ2lzQW5ndWxhclpvbmUnOiB0cnVlIH0pLFxuICAgICAgICAgICAgICAgIG9uSW52b2tlVGFzazogZnVuY3Rpb24gKGRlbGVnYXRlLCBjdXJyZW50LCB0YXJnZXQsIHRhc2ssIGFwcGx5VGhpcywgYXBwbHlBcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5vbkVudGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVsZWdhdGUuaW52b2tlVGFzayh0YXJnZXQsIHRhc2ssIGFwcGx5VGhpcywgYXBwbHlBcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm9uTGVhdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25JbnZva2U6IGZ1bmN0aW9uIChkZWxlZ2F0ZSwgY3VycmVudCwgdGFyZ2V0LCBjYWxsYmFjaywgYXBwbHlUaGlzLCBhcHBseUFyZ3MsIHNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMub25FbnRlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlLmludm9rZSh0YXJnZXQsIGNhbGxiYWNrLCBhcHBseVRoaXMsIGFwcGx5QXJncywgc291cmNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm9uTGVhdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25IYXNUYXNrOiBmdW5jdGlvbiAoZGVsZWdhdGUsIGN1cnJlbnQsIHRhcmdldCwgaGFzVGFza1N0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGVnYXRlLmhhc1Rhc2sodGFyZ2V0LCBoYXNUYXNrU3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudCA9PT0gdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBhcmUgb25seSBpbnRlcmVzdGVkIGluIGhhc1Rhc2sgZXZlbnRzIHdoaWNoIG9yaWdpbmF0ZSBmcm9tIG91ciB6b25lXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAoQSBjaGlsZCBoYXNUYXNrIGV2ZW50IGlzIG5vdCBpbnRlcmVzdGluZyB0byB1cylcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNUYXNrU3RhdGUuY2hhbmdlID09ICdtaWNyb1Rhc2snKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0SGFzTWljcm90YXNrKGhhc1Rhc2tTdGF0ZS5taWNyb1Rhc2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaGFzVGFza1N0YXRlLmNoYW5nZSA9PSAnbWFjcm9UYXNrJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnNldEhhc01hY3JvdGFzayhoYXNUYXNrU3RhdGUubWFjcm9UYXNrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25IYW5kbGVFcnJvcjogZnVuY3Rpb24gKGRlbGVnYXRlLCBjdXJyZW50LCB0YXJnZXQsIGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGVnYXRlLmhhbmRsZUVycm9yKHRhcmdldCwgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy50cmlnZ2VyRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgTmdab25lLnByb3RvdHlwZS5vbkVudGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fbmVzdGluZysrO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzU3RhYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNTdGFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vblVuc3RhYmxlLmVtaXQobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgTmdab25lLnByb3RvdHlwZS5vbkxlYXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fbmVzdGluZy0tO1xuICAgICAgICAgICAgdGhpcy5jaGVja1N0YWJsZSgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBoYXNNaWNyb3Rhc2tzXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBOZ1pvbmUucHJvdG90eXBlLnNldEhhc01pY3JvdGFzayA9IGZ1bmN0aW9uIChoYXNNaWNyb3Rhc2tzKSB7XG4gICAgICAgICAgICB0aGlzLl9oYXNQZW5kaW5nTWljcm90YXNrcyA9IGhhc01pY3JvdGFza3M7XG4gICAgICAgICAgICB0aGlzLmNoZWNrU3RhYmxlKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGhhc01hY3JvdGFza3NcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIE5nWm9uZS5wcm90b3R5cGUuc2V0SGFzTWFjcm90YXNrID0gZnVuY3Rpb24gKGhhc01hY3JvdGFza3MpIHsgdGhpcy5faGFzUGVuZGluZ01hY3JvdGFza3MgPSBoYXNNYWNyb3Rhc2tzOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBlcnJvclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgTmdab25lLnByb3RvdHlwZS50cmlnZ2VyRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHsgdGhpcy5fb25FcnJvckV2ZW50cy5lbWl0KGVycm9yKTsgfTtcbiAgICAgICAgcmV0dXJuIE5nWm9uZTtcbiAgICB9KCkpO1xuXG4gICAgdmFyIEFuaW1hdGlvblF1ZXVlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gX3pvbmVcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvblF1ZXVlKF96b25lKSB7XG4gICAgICAgICAgICB0aGlzLl96b25lID0gX3pvbmU7XG4gICAgICAgICAgICB0aGlzLmVudHJpZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBwbGF5ZXJcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEFuaW1hdGlvblF1ZXVlLnByb3RvdHlwZS5lbnF1ZXVlID0gZnVuY3Rpb24gKHBsYXllcikgeyB0aGlzLmVudHJpZXMucHVzaChwbGF5ZXIpOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEFuaW1hdGlvblF1ZXVlLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAvLyBnaXZlbiB0aGF0IGVhY2ggYW5pbWF0aW9uIHBsYXllciBtYXkgc2V0IGFzaWRlXG4gICAgICAgICAgICAvLyBtaWNyb3Rhc2tzIGFuZCByZWx5IG9uIERPTS1iYXNlZCBldmVudHMsIHRoaXNcbiAgICAgICAgICAgIC8vIHdpbGwgY2F1c2UgQW5ndWxhciB0byBydW4gY2hhbmdlIGRldGVjdGlvbiBhZnRlclxuICAgICAgICAgICAgLy8gZWFjaCByZXF1ZXN0LiBUaGlzIHNpZGVzdGVwcyB0aGUgaXNzdWUuIElmIGEgdXNlclxuICAgICAgICAgICAgLy8gaG9va3MgaW50byBhbiBhbmltYXRpb24gdmlhIChAYW5pbS5zdGFydCkgb3IgKEBhbmltLmRvbmUpXG4gICAgICAgICAgICAvLyB0aGVuIHRob3NlIG1ldGhvZHMgd2lsbCBhdXRvbWF0aWNhbGx5IHRyaWdnZXIgY2hhbmdlXG4gICAgICAgICAgICAvLyBkZXRlY3Rpb24gYnkgd3JhcHBpbmcgdGhlbXNlbHZlcyBpbnNpZGUgb2YgYSB6b25lXG4gICAgICAgICAgICBpZiAodGhpcy5lbnRyaWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGNvZGUgaXMgd3JhcHBlZCBpbnRvIGEgc2luZ2xlIHByb21pc2Ugc3VjaCB0aGF0IHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBvblN0YXJ0IGFuZCBvbkRvbmUgcGxheWVyIGNhbGxiYWNrcyBhcmUgdHJpZ2dlcmVkIG91dHNpZGVcbiAgICAgICAgICAgICAgICAgICAgLy8gb2YgdGhlIGRpZ2VzdCBjeWNsZSBvZiBhbmltYXRpb25zXG4gICAgICAgICAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZShudWxsKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl90cmlnZ2VyQW5pbWF0aW9ucygpOyB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBbmltYXRpb25RdWV1ZS5wcm90b3R5cGUuX3RyaWdnZXJBbmltYXRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgTmdab25lLmFzc2VydE5vdEluQW5ndWxhclpvbmUoKTtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLmVudHJpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGxheWVyID0gdGhpcy5lbnRyaWVzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgLy8gaW4gdGhlIGV2ZW50IHRoYXQgYW4gYW5pbWF0aW9uIHRocm93cyBhbiBlcnJvciB0aGVuIHdlIGRvXG4gICAgICAgICAgICAgICAgLy8gbm90IHdhbnQgdG8gcmUtcnVuIGFuaW1hdGlvbnMgb24gYW55IHByZXZpb3VzIGFuaW1hdGlvbnNcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGV5IGhhdmUgYWxyZWFkeSBiZWVuIGtpY2tlZCBvZmYgYmVmb3JlaGFuZFxuICAgICAgICAgICAgICAgIGlmICghcGxheWVyLmhhc1N0YXJ0ZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICBwbGF5ZXIucGxheSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQW5pbWF0aW9uUXVldWUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgQW5pbWF0aW9uUXVldWUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgICAgICB7IHR5cGU6IE5nWm9uZSwgfSxcbiAgICAgICAgXTsgfTtcbiAgICAgICAgcmV0dXJuIEFuaW1hdGlvblF1ZXVlO1xuICAgIH0oKSk7XG5cbiAgICB2YXIgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyRmFjdG9yeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIERlZmF1bHRJdGVyYWJsZURpZmZlckZhY3RvcnkoKSB7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gb2JqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXJGYWN0b3J5LnByb3RvdHlwZS5zdXBwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIGlzTGlzdExpa2VJdGVyYWJsZShvYmopOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBjZFJlZlxuICAgICAgICAgKiBAcGFyYW0gez89fSB0cmFja0J5Rm5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIERlZmF1bHRJdGVyYWJsZURpZmZlckZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uIChjZFJlZiwgdHJhY2tCeUZuKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERlZmF1bHRJdGVyYWJsZURpZmZlcih0cmFja0J5Rm4pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRGVmYXVsdEl0ZXJhYmxlRGlmZmVyRmFjdG9yeTtcbiAgICB9KCkpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyYWNrQnlJZGVudGl0eSA9IGZ1bmN0aW9uIChpbmRleCwgaXRlbSkgeyByZXR1cm4gaXRlbTsgfTtcbiAgICAvKipcbiAgICAgKiBcXEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IF90cmFja0J5Rm5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIERlZmF1bHRJdGVyYWJsZURpZmZlcihfdHJhY2tCeUZuKSB7XG4gICAgICAgICAgICB0aGlzLl90cmFja0J5Rm4gPSBfdHJhY2tCeUZuO1xuICAgICAgICAgICAgdGhpcy5fbGVuZ3RoID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2NvbGxlY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fbGlua2VkUmVjb3JkcyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl91bmxpbmtlZFJlY29yZHMgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNJdEhlYWQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5faXRIZWFkID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2l0VGFpbCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9hZGRpdGlvbnNIZWFkID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2FkZGl0aW9uc1RhaWwgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fbW92ZXNIZWFkID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX21vdmVzVGFpbCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmFsc0hlYWQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZhbHNUYWlsID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2lkZW50aXR5Q2hhbmdlc0hlYWQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5faWRlbnRpdHlDaGFuZ2VzVGFpbCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl90cmFja0J5Rm4gPSB0aGlzLl90cmFja0J5Rm4gfHwgdHJhY2tCeUlkZW50aXR5O1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLCBcImNvbGxlY3Rpb25cIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NvbGxlY3Rpb247IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZSwgXCJsZW5ndGhcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2xlbmd0aDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLmZvckVhY2hJdGVtID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZWNvcmQ7XG4gICAgICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX2l0SGVhZDsgcmVjb3JkICE9PSBudWxsOyByZWNvcmQgPSByZWNvcmQuX25leHQpIHtcbiAgICAgICAgICAgICAgICBmbihyZWNvcmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBmblxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5mb3JFYWNoT3BlcmF0aW9uID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZXh0SXQgPSB0aGlzLl9pdEhlYWQ7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZXh0UmVtb3ZlID0gdGhpcy5fcmVtb3ZhbHNIZWFkO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYWRkUmVtb3ZlT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1vdmVPZmZzZXRzID0gbnVsbDtcbiAgICAgICAgICAgIHdoaWxlIChuZXh0SXQgfHwgbmV4dFJlbW92ZSkge1xuICAgICAgICAgICAgICAgIC8vIEZpZ3VyZSBvdXQgd2hpY2ggaXMgdGhlIG5leHQgcmVjb3JkIHRvIHByb2Nlc3NcbiAgICAgICAgICAgICAgICAvLyBPcmRlcjogcmVtb3ZlLCBhZGQsIG1vdmVcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZWNvcmQgPSAhbmV4dFJlbW92ZSB8fFxuICAgICAgICAgICAgICAgICAgICBuZXh0SXQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRJdC5jdXJyZW50SW5kZXggPCBnZXRQcmV2aW91c0luZGV4KG5leHRSZW1vdmUsIGFkZFJlbW92ZU9mZnNldCwgbW92ZU9mZnNldHMpID9cbiAgICAgICAgICAgICAgICAgICAgbmV4dEl0IDpcbiAgICAgICAgICAgICAgICAgICAgbmV4dFJlbW92ZTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhZGpQcmV2aW91c0luZGV4ID0gZ2V0UHJldmlvdXNJbmRleChyZWNvcmQsIGFkZFJlbW92ZU9mZnNldCwgbW92ZU9mZnNldHMpO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGN1cnJlbnRJbmRleCA9IHJlY29yZC5jdXJyZW50SW5kZXg7XG4gICAgICAgICAgICAgICAgLy8gY29uc3VtZSB0aGUgaXRlbSwgYW5kIGFkanVzdCB0aGUgYWRkUmVtb3ZlT2Zmc2V0IGFuZCB1cGRhdGUgbW92ZURpc3RhbmNlIGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgIGlmIChyZWNvcmQgPT09IG5leHRSZW1vdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkUmVtb3ZlT2Zmc2V0LS07XG4gICAgICAgICAgICAgICAgICAgIG5leHRSZW1vdmUgPSBuZXh0UmVtb3ZlLl9uZXh0UmVtb3ZlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRJdCA9IG5leHRJdC5fbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY29yZC5wcmV2aW91c0luZGV4ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZFJlbW92ZU9mZnNldCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSU5WQVJJQU5UOiAgY3VycmVudEluZGV4IDwgcHJldmlvdXNJbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtb3ZlT2Zmc2V0cylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3ZlT2Zmc2V0cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbG9jYWxNb3ZlUHJldmlvdXNJbmRleCA9IGFkalByZXZpb3VzSW5kZXggLSBhZGRSZW1vdmVPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsb2NhbEN1cnJlbnRJbmRleCA9IGN1cnJlbnRJbmRleCAtIGFkZFJlbW92ZU9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2NhbE1vdmVQcmV2aW91c0luZGV4ICE9IGxvY2FsQ3VycmVudEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IGxvY2FsTW92ZVByZXZpb3VzSW5kZXg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvZmZzZXQgPSBpIDwgbW92ZU9mZnNldHMubGVuZ3RoID8gbW92ZU9mZnNldHNbaV0gOiAobW92ZU9mZnNldHNbaV0gPSAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5kZXggPSBvZmZzZXQgKyBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxDdXJyZW50SW5kZXggPD0gaW5kZXggJiYgaW5kZXggPCBsb2NhbE1vdmVQcmV2aW91c0luZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3ZlT2Zmc2V0c1tpXSA9IG9mZnNldCArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJldmlvdXNJbmRleCA9IHJlY29yZC5wcmV2aW91c0luZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVPZmZzZXRzW3ByZXZpb3VzSW5kZXhdID0gbG9jYWxDdXJyZW50SW5kZXggLSBsb2NhbE1vdmVQcmV2aW91c0luZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhZGpQcmV2aW91c0luZGV4ICE9PSBjdXJyZW50SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgZm4ocmVjb3JkLCBhZGpQcmV2aW91c0luZGV4LCBjdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuZm9yRWFjaFByZXZpb3VzSXRlbSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVjb3JkO1xuICAgICAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9wcmV2aW91c0l0SGVhZDsgcmVjb3JkICE9PSBudWxsOyByZWNvcmQgPSByZWNvcmQuX25leHRQcmV2aW91cykge1xuICAgICAgICAgICAgICAgIGZuKHJlY29yZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLmZvckVhY2hBZGRlZEl0ZW0gPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlY29yZDtcbiAgICAgICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5fYWRkaXRpb25zSGVhZDsgcmVjb3JkICE9PSBudWxsOyByZWNvcmQgPSByZWNvcmQuX25leHRBZGRlZCkge1xuICAgICAgICAgICAgICAgIGZuKHJlY29yZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLmZvckVhY2hNb3ZlZEl0ZW0gPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlY29yZDtcbiAgICAgICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5fbW92ZXNIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dE1vdmVkKSB7XG4gICAgICAgICAgICAgICAgZm4ocmVjb3JkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuZm9yRWFjaFJlbW92ZWRJdGVtID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZWNvcmQ7XG4gICAgICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX3JlbW92YWxzSGVhZDsgcmVjb3JkICE9PSBudWxsOyByZWNvcmQgPSByZWNvcmQuX25leHRSZW1vdmVkKSB7XG4gICAgICAgICAgICAgICAgZm4ocmVjb3JkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuZm9yRWFjaElkZW50aXR5Q2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZWNvcmQ7XG4gICAgICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX2lkZW50aXR5Q2hhbmdlc0hlYWQ7IHJlY29yZCAhPT0gbnVsbDsgcmVjb3JkID0gcmVjb3JkLl9uZXh0SWRlbnRpdHlDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICBmbihyZWNvcmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBjb2xsZWN0aW9uXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLmRpZmYgPSBmdW5jdGlvbiAoY29sbGVjdGlvbikge1xuICAgICAgICAgICAgaWYgKGlzQmxhbmsoY29sbGVjdGlvbikpXG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbiA9IFtdO1xuICAgICAgICAgICAgaWYgKCFpc0xpc3RMaWtlSXRlcmFibGUoY29sbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciB0cnlpbmcgdG8gZGlmZiAnXCIgKyBjb2xsZWN0aW9uICsgXCInXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY2hlY2soY29sbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUub25EZXN0cm95ID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBjb2xsZWN0aW9uXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLmNoZWNrID0gZnVuY3Rpb24gKGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLl9yZXNldCgpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVjb3JkID0gdGhpcy5faXRIZWFkO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWF5QmVEaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5kZXg7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpdGVtO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXRlbVRyYWNrQnk7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjb2xsZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxpc3QgPSBjb2xsZWN0aW9uO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaW5kZXhfMSA9IDA7IGluZGV4XzEgPCB0aGlzLl9sZW5ndGg7IGluZGV4XzErKykge1xuICAgICAgICAgICAgICAgICAgICBpdGVtID0gbGlzdFtpbmRleF8xXTtcbiAgICAgICAgICAgICAgICAgICAgaXRlbVRyYWNrQnkgPSB0aGlzLl90cmFja0J5Rm4oaW5kZXhfMSwgaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWNvcmQgPT09IG51bGwgfHwgIWxvb3NlSWRlbnRpY2FsKHJlY29yZC50cmFja0J5SWQsIGl0ZW1UcmFja0J5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3JkID0gdGhpcy5fbWlzbWF0Y2gocmVjb3JkLCBpdGVtLCBpdGVtVHJhY2tCeSwgaW5kZXhfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXlCZURpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXlCZURpcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyhtaXNrbyk6IGNhbiB3ZSBsaW1pdCB0aGlzIHRvIGR1cGxpY2F0ZXMgb25seT9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNvcmQgPSB0aGlzLl92ZXJpZnlSZWluc2VydGlvbihyZWNvcmQsIGl0ZW0sIGl0ZW1UcmFja0J5LCBpbmRleF8xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbG9vc2VJZGVudGljYWwocmVjb3JkLml0ZW0sIGl0ZW0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZElkZW50aXR5Q2hhbmdlKHJlY29yZCwgaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkID0gcmVjb3JkLl9uZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICBpdGVyYXRlTGlzdExpa2UoY29sbGVjdGlvbiwgZnVuY3Rpb24gKGl0ZW0gLyoqIFRPRE8gIzkxMDAgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbVRyYWNrQnkgPSBfdGhpcy5fdHJhY2tCeUZuKGluZGV4LCBpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY29yZCA9PT0gbnVsbCB8fCAhbG9vc2VJZGVudGljYWwocmVjb3JkLnRyYWNrQnlJZCwgaXRlbVRyYWNrQnkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWNvcmQgPSBfdGhpcy5fbWlzbWF0Y2gocmVjb3JkLCBpdGVtLCBpdGVtVHJhY2tCeSwgaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF5QmVEaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF5QmVEaXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8obWlza28pOiBjYW4gd2UgbGltaXQgdGhpcyB0byBkdXBsaWNhdGVzIG9ubHk/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3JkID0gX3RoaXMuX3ZlcmlmeVJlaW5zZXJ0aW9uKHJlY29yZCwgaXRlbSwgaXRlbVRyYWNrQnksIGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbG9vc2VJZGVudGljYWwocmVjb3JkLml0ZW0sIGl0ZW0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9hZGRJZGVudGl0eUNoYW5nZShyZWNvcmQsIGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlY29yZCA9IHJlY29yZC5fbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9sZW5ndGggPSBpbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3RydW5jYXRlKHJlY29yZCk7XG4gICAgICAgICAgICB0aGlzLl9jb2xsZWN0aW9uID0gY29sbGVjdGlvbjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzRGlydHk7XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLCBcImlzRGlydHlcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYWRkaXRpb25zSGVhZCAhPT0gbnVsbCB8fCB0aGlzLl9tb3Zlc0hlYWQgIT09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZhbHNIZWFkICE9PSBudWxsIHx8IHRoaXMuX2lkZW50aXR5Q2hhbmdlc0hlYWQgIT09IG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc2V0IHRoZSBzdGF0ZSBvZiB0aGUgY2hhbmdlIG9iamVjdHMgdG8gc2hvdyBubyBjaGFuZ2VzLiBUaGlzIG1lYW5zIHNldCBwcmV2aW91c0tleSB0b1xuICAgICAgICAgKiBjdXJyZW50S2V5LCBhbmQgY2xlYXIgYWxsIG9mIHRoZSBxdWV1ZXMgKGFkZGl0aW9ucywgbW92ZXMsIHJlbW92YWxzKS5cbiAgICAgICAgICogU2V0IHRoZSBwcmV2aW91c0luZGV4ZXMgb2YgbW92ZWQgYW5kIGFkZGVkIGl0ZW1zIHRvIHRoZWlyIGN1cnJlbnRJbmRleGVzXG4gICAgICAgICAqIFJlc2V0IHRoZSBsaXN0IG9mIGFkZGl0aW9ucywgbW92ZXMgYW5kIHJlbW92YWxzXG4gICAgICAgICAqXG4gICAgICAgICAqIFxcQGludGVybmFsXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLl9yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRGlydHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZWNvcmQgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmV4dFJlY29yZCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX3ByZXZpb3VzSXRIZWFkID0gdGhpcy5faXRIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dCkge1xuICAgICAgICAgICAgICAgICAgICByZWNvcmQuX25leHRQcmV2aW91cyA9IHJlY29yZC5fbmV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9hZGRpdGlvbnNIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dEFkZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY29yZC5wcmV2aW91c0luZGV4ID0gcmVjb3JkLmN1cnJlbnRJbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkaXRpb25zSGVhZCA9IHRoaXMuX2FkZGl0aW9uc1RhaWwgPSBudWxsO1xuICAgICAgICAgICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5fbW92ZXNIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IG5leHRSZWNvcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkLnByZXZpb3VzSW5kZXggPSByZWNvcmQuY3VycmVudEluZGV4O1xuICAgICAgICAgICAgICAgICAgICBuZXh0UmVjb3JkID0gcmVjb3JkLl9uZXh0TW92ZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX21vdmVzSGVhZCA9IHRoaXMuX21vdmVzVGFpbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZhbHNIZWFkID0gdGhpcy5fcmVtb3ZhbHNUYWlsID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLl9pZGVudGl0eUNoYW5nZXNIZWFkID0gdGhpcy5faWRlbnRpdHlDaGFuZ2VzVGFpbCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGlzIHRoZSBjb3JlIGZ1bmN0aW9uIHdoaWNoIGhhbmRsZXMgZGlmZmVyZW5jZXMgYmV0d2VlbiBjb2xsZWN0aW9ucy5cbiAgICAgICAgICpcbiAgICAgICAgICogLSBgcmVjb3JkYCBpcyB0aGUgcmVjb3JkIHdoaWNoIHdlIHNhdyBhdCB0aGlzIHBvc2l0aW9uIGxhc3QgdGltZS4gSWYgbnVsbCB0aGVuIGl0IGlzIGEgbmV3XG4gICAgICAgICAqICAgaXRlbS5cbiAgICAgICAgICogLSBgaXRlbWAgaXMgdGhlIGN1cnJlbnQgaXRlbSBpbiB0aGUgY29sbGVjdGlvblxuICAgICAgICAgKiAtIGBpbmRleGAgaXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBpdGVtIGluIHRoZSBjb2xsZWN0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIFxcQGludGVybmFsXG4gICAgICAgICAqIEBwYXJhbSB7P30gcmVjb3JkXG4gICAgICAgICAqIEBwYXJhbSB7P30gaXRlbVxuICAgICAgICAgKiBAcGFyYW0gez99IGl0ZW1UcmFja0J5XG4gICAgICAgICAqIEBwYXJhbSB7P30gaW5kZXhcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuX21pc21hdGNoID0gZnVuY3Rpb24gKHJlY29yZCwgaXRlbSwgaXRlbVRyYWNrQnksIGluZGV4KSB7XG4gICAgICAgICAgICAvLyBUaGUgcHJldmlvdXMgcmVjb3JkIGFmdGVyIHdoaWNoIHdlIHdpbGwgYXBwZW5kIHRoZSBjdXJyZW50IG9uZS5cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZXZpb3VzUmVjb3JkO1xuICAgICAgICAgICAgaWYgKHJlY29yZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHByZXZpb3VzUmVjb3JkID0gdGhpcy5faXRUYWlsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNSZWNvcmQgPSByZWNvcmQuX3ByZXY7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSByZWNvcmQgZnJvbSB0aGUgY29sbGVjdGlvbiBzaW5jZSB3ZSBrbm93IGl0IGRvZXMgbm90IG1hdGNoIHRoZSBpdGVtLlxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZShyZWNvcmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQXR0ZW1wdCB0byBzZWUgaWYgd2UgaGF2ZSBzZWVuIHRoZSBpdGVtIGJlZm9yZS5cbiAgICAgICAgICAgIHJlY29yZCA9IHRoaXMuX2xpbmtlZFJlY29yZHMgPT09IG51bGwgPyBudWxsIDogdGhpcy5fbGlua2VkUmVjb3Jkcy5nZXQoaXRlbVRyYWNrQnksIGluZGV4KTtcbiAgICAgICAgICAgIGlmIChyZWNvcmQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIHNlZW4gdGhpcyBiZWZvcmUsIHdlIG5lZWQgdG8gbW92ZSBpdCBmb3J3YXJkIGluIHRoZSBjb2xsZWN0aW9uLlxuICAgICAgICAgICAgICAgIC8vIEJ1dCBmaXJzdCB3ZSBuZWVkIHRvIGNoZWNrIGlmIGlkZW50aXR5IGNoYW5nZWQsIHNvIHdlIGNhbiB1cGRhdGUgaW4gdmlldyBpZiBuZWNlc3NhcnlcbiAgICAgICAgICAgICAgICBpZiAoIWxvb3NlSWRlbnRpY2FsKHJlY29yZC5pdGVtLCBpdGVtKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkSWRlbnRpdHlDaGFuZ2UocmVjb3JkLCBpdGVtKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb3ZlQWZ0ZXIocmVjb3JkLCBwcmV2aW91c1JlY29yZCwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTmV2ZXIgc2VlbiBpdCwgY2hlY2sgZXZpY3RlZCBsaXN0LlxuICAgICAgICAgICAgICAgIHJlY29yZCA9IHRoaXMuX3VubGlua2VkUmVjb3JkcyA9PT0gbnVsbCA/IG51bGwgOiB0aGlzLl91bmxpbmtlZFJlY29yZHMuZ2V0KGl0ZW1UcmFja0J5KTtcbiAgICAgICAgICAgICAgICBpZiAocmVjb3JkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEl0IGlzIGFuIGl0ZW0gd2hpY2ggd2UgaGF2ZSBldmljdGVkIGVhcmxpZXI6IHJlaW5zZXJ0IGl0IGJhY2sgaW50byB0aGUgbGlzdC5cbiAgICAgICAgICAgICAgICAgICAgLy8gQnV0IGZpcnN0IHdlIG5lZWQgdG8gY2hlY2sgaWYgaWRlbnRpdHkgY2hhbmdlZCwgc28gd2UgY2FuIHVwZGF0ZSBpbiB2aWV3IGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWxvb3NlSWRlbnRpY2FsKHJlY29yZC5pdGVtLCBpdGVtKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZElkZW50aXR5Q2hhbmdlKHJlY29yZCwgaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlaW5zZXJ0QWZ0ZXIocmVjb3JkLCBwcmV2aW91c1JlY29yZCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSXQgaXMgYSBuZXcgaXRlbTogYWRkIGl0LlxuICAgICAgICAgICAgICAgICAgICByZWNvcmQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkQWZ0ZXIobmV3IENvbGxlY3Rpb25DaGFuZ2VSZWNvcmQoaXRlbSwgaXRlbVRyYWNrQnkpLCBwcmV2aW91c1JlY29yZCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWNvcmQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGNoZWNrIGlzIG9ubHkgbmVlZGVkIGlmIGFuIGFycmF5IGNvbnRhaW5zIGR1cGxpY2F0ZXMuIChTaG9ydCBjaXJjdWl0IG9mIG5vdGhpbmcgZGlydHkpXG4gICAgICAgICAqXG4gICAgICAgICAqIFVzZSBjYXNlOiBgW2EsIGFdYCA9PiBgW2IsIGEsIGFdYFxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiB3ZSBkaWQgbm90IGhhdmUgdGhpcyBjaGVjayB0aGVuIHRoZSBpbnNlcnRpb24gb2YgYGJgIHdvdWxkOlxuICAgICAgICAgKiAgIDEpIGV2aWN0IGZpcnN0IGBhYFxuICAgICAgICAgKiAgIDIpIGluc2VydCBgYmAgYXQgYDBgIGluZGV4LlxuICAgICAgICAgKiAgIDMpIGxlYXZlIGBhYCBhdCBpbmRleCBgMWAgYXMgaXMuIDwtLSB0aGlzIGlzIHdyb25nIVxuICAgICAgICAgKiAgIDMpIHJlaW5zZXJ0IGBhYCBhdCBpbmRleCAyLiA8LS0gdGhpcyBpcyB3cm9uZyFcbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGNvcnJlY3QgYmVoYXZpb3IgaXM6XG4gICAgICAgICAqICAgMSkgZXZpY3QgZmlyc3QgYGFgXG4gICAgICAgICAqICAgMikgaW5zZXJ0IGBiYCBhdCBgMGAgaW5kZXguXG4gICAgICAgICAqICAgMykgcmVpbnNlcnQgYGFgIGF0IGluZGV4IDEuXG4gICAgICAgICAqICAgMykgbW92ZSBgYWAgYXQgZnJvbSBgMWAgdG8gYDJgLlxuICAgICAgICAgKlxuICAgICAgICAgKlxuICAgICAgICAgKiBEb3VibGUgY2hlY2sgdGhhdCB3ZSBoYXZlIG5vdCBldmljdGVkIGEgZHVwbGljYXRlIGl0ZW0uIFdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlIGl0ZW0gdHlwZSBtYXlcbiAgICAgICAgICogaGF2ZSBhbHJlYWR5IGJlZW4gcmVtb3ZlZDpcbiAgICAgICAgICogVGhlIGluc2VydGlvbiBvZiBiIHdpbGwgZXZpY3QgdGhlIGZpcnN0ICdhJy4gSWYgd2UgZG9uJ3QgcmVpbnNlcnQgaXQgbm93IGl0IHdpbGwgYmUgcmVpbnNlcnRlZFxuICAgICAgICAgKiBhdCB0aGUgZW5kLiBXaGljaCB3aWxsIHNob3cgdXAgYXMgdGhlIHR3byAnYSdzIHN3aXRjaGluZyBwb3NpdGlvbi4gVGhpcyBpcyBpbmNvcnJlY3QsIHNpbmNlIGFcbiAgICAgICAgICogYmV0dGVyIHdheSB0byB0aGluayBvZiBpdCBpcyBhcyBpbnNlcnQgb2YgJ2InIHJhdGhlciB0aGVuIHN3aXRjaCAnYScgd2l0aCAnYicgYW5kIHRoZW4gYWRkICdhJ1xuICAgICAgICAgKiBhdCB0aGUgZW5kLlxuICAgICAgICAgKlxuICAgICAgICAgKiBcXEBpbnRlcm5hbFxuICAgICAgICAgKiBAcGFyYW0gez99IHJlY29yZFxuICAgICAgICAgKiBAcGFyYW0gez99IGl0ZW1cbiAgICAgICAgICogQHBhcmFtIHs/fSBpdGVtVHJhY2tCeVxuICAgICAgICAgKiBAcGFyYW0gez99IGluZGV4XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLl92ZXJpZnlSZWluc2VydGlvbiA9IGZ1bmN0aW9uIChyZWNvcmQsIGl0ZW0sIGl0ZW1UcmFja0J5LCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVpbnNlcnRSZWNvcmQgPSB0aGlzLl91bmxpbmtlZFJlY29yZHMgPT09IG51bGwgPyBudWxsIDogdGhpcy5fdW5saW5rZWRSZWNvcmRzLmdldChpdGVtVHJhY2tCeSk7XG4gICAgICAgICAgICBpZiAocmVpbnNlcnRSZWNvcmQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZWNvcmQgPSB0aGlzLl9yZWluc2VydEFmdGVyKHJlaW5zZXJ0UmVjb3JkLCByZWNvcmQuX3ByZXYsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlY29yZC5jdXJyZW50SW5kZXggIT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZWNvcmQuY3VycmVudEluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkVG9Nb3ZlcyhyZWNvcmQsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWNvcmQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgcmlkIG9mIGFueSBleGNlc3Mge1xcQGxpbmsgQ29sbGVjdGlvbkNoYW5nZVJlY29yZH1zIGZyb20gdGhlIHByZXZpb3VzIGNvbGxlY3Rpb25cbiAgICAgICAgICpcbiAgICAgICAgICogLSBgcmVjb3JkYCBUaGUgZmlyc3QgZXhjZXNzIHtcXEBsaW5rIENvbGxlY3Rpb25DaGFuZ2VSZWNvcmR9LlxuICAgICAgICAgKlxuICAgICAgICAgKiBcXEBpbnRlcm5hbFxuICAgICAgICAgKiBAcGFyYW0gez99IHJlY29yZFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5fdHJ1bmNhdGUgPSBmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgICAvLyBBbnl0aGluZyBhZnRlciB0aGF0IG5lZWRzIHRvIGJlIHJlbW92ZWQ7XG4gICAgICAgICAgICB3aGlsZSAocmVjb3JkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmV4dFJlY29yZCA9IHJlY29yZC5fbmV4dDtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRUb1JlbW92YWxzKHRoaXMuX3VubGluayhyZWNvcmQpKTtcbiAgICAgICAgICAgICAgICByZWNvcmQgPSBuZXh0UmVjb3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3VubGlua2VkUmVjb3JkcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VubGlua2VkUmVjb3Jkcy5jbGVhcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2FkZGl0aW9uc1RhaWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRpdGlvbnNUYWlsLl9uZXh0QWRkZWQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX21vdmVzVGFpbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21vdmVzVGFpbC5fbmV4dE1vdmVkID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9pdFRhaWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pdFRhaWwuX25leHQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3JlbW92YWxzVGFpbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92YWxzVGFpbC5fbmV4dFJlbW92ZWQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2lkZW50aXR5Q2hhbmdlc1RhaWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pZGVudGl0eUNoYW5nZXNUYWlsLl9uZXh0SWRlbnRpdHlDaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogXFxAaW50ZXJuYWxcbiAgICAgICAgICogQHBhcmFtIHs/fSByZWNvcmRcbiAgICAgICAgICogQHBhcmFtIHs/fSBwcmV2UmVjb3JkXG4gICAgICAgICAqIEBwYXJhbSB7P30gaW5kZXhcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuX3JlaW5zZXJ0QWZ0ZXIgPSBmdW5jdGlvbiAocmVjb3JkLCBwcmV2UmVjb3JkLCBpbmRleCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3VubGlua2VkUmVjb3JkcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VubGlua2VkUmVjb3Jkcy5yZW1vdmUocmVjb3JkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZXYgPSByZWNvcmQuX3ByZXZSZW1vdmVkO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmV4dCA9IHJlY29yZC5fbmV4dFJlbW92ZWQ7XG4gICAgICAgICAgICBpZiAocHJldiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92YWxzSGVhZCA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmV2Ll9uZXh0UmVtb3ZlZCA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92YWxzVGFpbCA9IHByZXY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXh0Ll9wcmV2UmVtb3ZlZCA9IHByZXY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9pbnNlcnRBZnRlcihyZWNvcmQsIHByZXZSZWNvcmQsIGluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuX2FkZFRvTW92ZXMocmVjb3JkLCBpbmRleCk7XG4gICAgICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogXFxAaW50ZXJuYWxcbiAgICAgICAgICogQHBhcmFtIHs/fSByZWNvcmRcbiAgICAgICAgICogQHBhcmFtIHs/fSBwcmV2UmVjb3JkXG4gICAgICAgICAqIEBwYXJhbSB7P30gaW5kZXhcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuX21vdmVBZnRlciA9IGZ1bmN0aW9uIChyZWNvcmQsIHByZXZSZWNvcmQsIGluZGV4KSB7XG4gICAgICAgICAgICB0aGlzLl91bmxpbmsocmVjb3JkKTtcbiAgICAgICAgICAgIHRoaXMuX2luc2VydEFmdGVyKHJlY29yZCwgcHJldlJlY29yZCwgaW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5fYWRkVG9Nb3ZlcyhyZWNvcmQsIGluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiByZWNvcmQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBcXEBpbnRlcm5hbFxuICAgICAgICAgKiBAcGFyYW0gez99IHJlY29yZFxuICAgICAgICAgKiBAcGFyYW0gez99IHByZXZSZWNvcmRcbiAgICAgICAgICogQHBhcmFtIHs/fSBpbmRleFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5fYWRkQWZ0ZXIgPSBmdW5jdGlvbiAocmVjb3JkLCBwcmV2UmVjb3JkLCBpbmRleCkge1xuICAgICAgICAgICAgdGhpcy5faW5zZXJ0QWZ0ZXIocmVjb3JkLCBwcmV2UmVjb3JkLCBpbmRleCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fYWRkaXRpb25zVGFpbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIHRvZG8odmljYilcbiAgICAgICAgICAgICAgICAvLyBhc3NlcnQodGhpcy5fYWRkaXRpb25zSGVhZCA9PT0gbnVsbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkaXRpb25zVGFpbCA9IHRoaXMuX2FkZGl0aW9uc0hlYWQgPSByZWNvcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB0b2RvKHZpY2IpXG4gICAgICAgICAgICAgICAgLy8gYXNzZXJ0KF9hZGRpdGlvbnNUYWlsLl9uZXh0QWRkZWQgPT09IG51bGwpO1xuICAgICAgICAgICAgICAgIC8vIGFzc2VydChyZWNvcmQuX25leHRBZGRlZCA9PT0gbnVsbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkaXRpb25zVGFpbCA9IHRoaXMuX2FkZGl0aW9uc1RhaWwuX25leHRBZGRlZCA9IHJlY29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWNvcmQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBcXEBpbnRlcm5hbFxuICAgICAgICAgKiBAcGFyYW0gez99IHJlY29yZFxuICAgICAgICAgKiBAcGFyYW0gez99IHByZXZSZWNvcmRcbiAgICAgICAgICogQHBhcmFtIHs/fSBpbmRleFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5faW5zZXJ0QWZ0ZXIgPSBmdW5jdGlvbiAocmVjb3JkLCBwcmV2UmVjb3JkLCBpbmRleCkge1xuICAgICAgICAgICAgLy8gdG9kbyh2aWNiKVxuICAgICAgICAgICAgLy8gYXNzZXJ0KHJlY29yZCAhPSBwcmV2UmVjb3JkKTtcbiAgICAgICAgICAgIC8vIGFzc2VydChyZWNvcmQuX25leHQgPT09IG51bGwpO1xuICAgICAgICAgICAgLy8gYXNzZXJ0KHJlY29yZC5fcHJldiA9PT0gbnVsbCk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZXh0ID0gcHJldlJlY29yZCA9PT0gbnVsbCA/IHRoaXMuX2l0SGVhZCA6IHByZXZSZWNvcmQuX25leHQ7XG4gICAgICAgICAgICAvLyB0b2RvKHZpY2IpXG4gICAgICAgICAgICAvLyBhc3NlcnQobmV4dCAhPSByZWNvcmQpO1xuICAgICAgICAgICAgLy8gYXNzZXJ0KHByZXZSZWNvcmQgIT0gcmVjb3JkKTtcbiAgICAgICAgICAgIHJlY29yZC5fbmV4dCA9IG5leHQ7XG4gICAgICAgICAgICByZWNvcmQuX3ByZXYgPSBwcmV2UmVjb3JkO1xuICAgICAgICAgICAgaWYgKG5leHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pdFRhaWwgPSByZWNvcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXh0Ll9wcmV2ID0gcmVjb3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByZXZSZWNvcmQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pdEhlYWQgPSByZWNvcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmV2UmVjb3JkLl9uZXh0ID0gcmVjb3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2xpbmtlZFJlY29yZHMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9saW5rZWRSZWNvcmRzID0gbmV3IF9EdXBsaWNhdGVNYXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2xpbmtlZFJlY29yZHMucHV0KHJlY29yZCk7XG4gICAgICAgICAgICByZWNvcmQuY3VycmVudEluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogXFxAaW50ZXJuYWxcbiAgICAgICAgICogQHBhcmFtIHs/fSByZWNvcmRcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuX3JlbW92ZSA9IGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hZGRUb1JlbW92YWxzKHRoaXMuX3VubGluayhyZWNvcmQpKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxcQGludGVybmFsXG4gICAgICAgICAqIEBwYXJhbSB7P30gcmVjb3JkXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLl91bmxpbmsgPSBmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbGlua2VkUmVjb3JkcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xpbmtlZFJlY29yZHMucmVtb3ZlKHJlY29yZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcmV2ID0gcmVjb3JkLl9wcmV2O1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmV4dCA9IHJlY29yZC5fbmV4dDtcbiAgICAgICAgICAgIC8vIHRvZG8odmljYilcbiAgICAgICAgICAgIC8vIGFzc2VydCgocmVjb3JkLl9wcmV2ID0gbnVsbCkgPT09IG51bGwpO1xuICAgICAgICAgICAgLy8gYXNzZXJ0KChyZWNvcmQuX25leHQgPSBudWxsKSA9PT0gbnVsbCk7XG4gICAgICAgICAgICBpZiAocHJldiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2l0SGVhZCA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmV2Ll9uZXh0ID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faXRUYWlsID0gcHJldjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5leHQuX3ByZXYgPSBwcmV2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxcQGludGVybmFsXG4gICAgICAgICAqIEBwYXJhbSB7P30gcmVjb3JkXG4gICAgICAgICAqIEBwYXJhbSB7P30gdG9JbmRleFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5fYWRkVG9Nb3ZlcyA9IGZ1bmN0aW9uIChyZWNvcmQsIHRvSW5kZXgpIHtcbiAgICAgICAgICAgIC8vIHRvZG8odmljYilcbiAgICAgICAgICAgIC8vIGFzc2VydChyZWNvcmQuX25leHRNb3ZlZCA9PT0gbnVsbCk7XG4gICAgICAgICAgICBpZiAocmVjb3JkLnByZXZpb3VzSW5kZXggPT09IHRvSW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX21vdmVzVGFpbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIHRvZG8odmljYilcbiAgICAgICAgICAgICAgICAvLyBhc3NlcnQoX21vdmVzSGVhZCA9PT0gbnVsbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW92ZXNUYWlsID0gdGhpcy5fbW92ZXNIZWFkID0gcmVjb3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdG9kbyh2aWNiKVxuICAgICAgICAgICAgICAgIC8vIGFzc2VydChfbW92ZXNUYWlsLl9uZXh0TW92ZWQgPT09IG51bGwpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21vdmVzVGFpbCA9IHRoaXMuX21vdmVzVGFpbC5fbmV4dE1vdmVkID0gcmVjb3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxcQGludGVybmFsXG4gICAgICAgICAqIEBwYXJhbSB7P30gcmVjb3JkXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLl9hZGRUb1JlbW92YWxzID0gZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3VubGlua2VkUmVjb3JkcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VubGlua2VkUmVjb3JkcyA9IG5ldyBfRHVwbGljYXRlTWFwKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl91bmxpbmtlZFJlY29yZHMucHV0KHJlY29yZCk7XG4gICAgICAgICAgICByZWNvcmQuY3VycmVudEluZGV4ID0gbnVsbDtcbiAgICAgICAgICAgIHJlY29yZC5fbmV4dFJlbW92ZWQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3JlbW92YWxzVGFpbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIHRvZG8odmljYilcbiAgICAgICAgICAgICAgICAvLyBhc3NlcnQoX3JlbW92YWxzSGVhZCA9PT0gbnVsbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZhbHNUYWlsID0gdGhpcy5fcmVtb3ZhbHNIZWFkID0gcmVjb3JkO1xuICAgICAgICAgICAgICAgIHJlY29yZC5fcHJldlJlbW92ZWQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdG9kbyh2aWNiKVxuICAgICAgICAgICAgICAgIC8vIGFzc2VydChfcmVtb3ZhbHNUYWlsLl9uZXh0UmVtb3ZlZCA9PT0gbnVsbCk7XG4gICAgICAgICAgICAgICAgLy8gYXNzZXJ0KHJlY29yZC5fbmV4dFJlbW92ZWQgPT09IG51bGwpO1xuICAgICAgICAgICAgICAgIHJlY29yZC5fcHJldlJlbW92ZWQgPSB0aGlzLl9yZW1vdmFsc1RhaWw7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZhbHNUYWlsID0gdGhpcy5fcmVtb3ZhbHNUYWlsLl9uZXh0UmVtb3ZlZCA9IHJlY29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWNvcmQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBcXEBpbnRlcm5hbFxuICAgICAgICAgKiBAcGFyYW0gez99IHJlY29yZFxuICAgICAgICAgKiBAcGFyYW0gez99IGl0ZW1cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuX2FkZElkZW50aXR5Q2hhbmdlID0gZnVuY3Rpb24gKHJlY29yZCwgaXRlbSkge1xuICAgICAgICAgICAgcmVjb3JkLml0ZW0gPSBpdGVtO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lkZW50aXR5Q2hhbmdlc1RhaWwgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pZGVudGl0eUNoYW5nZXNUYWlsID0gdGhpcy5faWRlbnRpdHlDaGFuZ2VzSGVhZCA9IHJlY29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2lkZW50aXR5Q2hhbmdlc1RhaWwgPSB0aGlzLl9pZGVudGl0eUNoYW5nZXNUYWlsLl9uZXh0SWRlbnRpdHlDaGFuZ2UgPSByZWNvcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsaXN0ID0gW107XG4gICAgICAgICAgICB0aGlzLmZvckVhY2hJdGVtKGZ1bmN0aW9uIChyZWNvcmQgLyoqIFRPRE8gIzkxMDAgKi8pIHsgcmV0dXJuIGxpc3QucHVzaChyZWNvcmQpOyB9KTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZXZpb3VzID0gW107XG4gICAgICAgICAgICB0aGlzLmZvckVhY2hQcmV2aW91c0l0ZW0oZnVuY3Rpb24gKHJlY29yZCAvKiogVE9ETyAjOTEwMCAqLykgeyByZXR1cm4gcHJldmlvdXMucHVzaChyZWNvcmQpOyB9KTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFkZGl0aW9ucyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5mb3JFYWNoQWRkZWRJdGVtKGZ1bmN0aW9uIChyZWNvcmQgLyoqIFRPRE8gIzkxMDAgKi8pIHsgcmV0dXJuIGFkZGl0aW9ucy5wdXNoKHJlY29yZCk7IH0pO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbW92ZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuZm9yRWFjaE1vdmVkSXRlbShmdW5jdGlvbiAocmVjb3JkIC8qKiBUT0RPICM5MTAwICovKSB7IHJldHVybiBtb3Zlcy5wdXNoKHJlY29yZCk7IH0pO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVtb3ZhbHMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuZm9yRWFjaFJlbW92ZWRJdGVtKGZ1bmN0aW9uIChyZWNvcmQgLyoqIFRPRE8gIzkxMDAgKi8pIHsgcmV0dXJuIHJlbW92YWxzLnB1c2gocmVjb3JkKTsgfSk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpZGVudGl0eUNoYW5nZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuZm9yRWFjaElkZW50aXR5Q2hhbmdlKGZ1bmN0aW9uIChyZWNvcmQgLyoqIFRPRE8gIzkxMDAgKi8pIHsgcmV0dXJuIGlkZW50aXR5Q2hhbmdlcy5wdXNoKHJlY29yZCk7IH0pO1xuICAgICAgICAgICAgcmV0dXJuICdjb2xsZWN0aW9uOiAnICsgbGlzdC5qb2luKCcsICcpICsgJ1xcbicgK1xuICAgICAgICAgICAgICAgICdwcmV2aW91czogJyArIHByZXZpb3VzLmpvaW4oJywgJykgKyAnXFxuJyArXG4gICAgICAgICAgICAgICAgJ2FkZGl0aW9uczogJyArIGFkZGl0aW9ucy5qb2luKCcsICcpICsgJ1xcbicgK1xuICAgICAgICAgICAgICAgICdtb3ZlczogJyArIG1vdmVzLmpvaW4oJywgJykgKyAnXFxuJyArXG4gICAgICAgICAgICAgICAgJ3JlbW92YWxzOiAnICsgcmVtb3ZhbHMuam9pbignLCAnKSArICdcXG4nICtcbiAgICAgICAgICAgICAgICAnaWRlbnRpdHlDaGFuZ2VzOiAnICsgaWRlbnRpdHlDaGFuZ2VzLmpvaW4oJywgJykgKyAnXFxuJztcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIERlZmF1bHRJdGVyYWJsZURpZmZlcjtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIFxcQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBDb2xsZWN0aW9uQ2hhbmdlUmVjb3JkID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gaXRlbVxuICAgICAgICAgKiBAcGFyYW0gez99IHRyYWNrQnlJZFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gQ29sbGVjdGlvbkNoYW5nZVJlY29yZChpdGVtLCB0cmFja0J5SWQpIHtcbiAgICAgICAgICAgIHRoaXMuaXRlbSA9IGl0ZW07XG4gICAgICAgICAgICB0aGlzLnRyYWNrQnlJZCA9IHRyYWNrQnlJZDtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEluZGV4ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXNJbmRleCA9IG51bGw7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9uZXh0UHJldmlvdXMgPSBudWxsO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fcHJldiA9IG51bGw7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9uZXh0ID0gbnVsbDtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX3ByZXZEdXAgPSBudWxsO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fbmV4dER1cCA9IG51bGw7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9wcmV2UmVtb3ZlZCA9IG51bGw7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9uZXh0UmVtb3ZlZCA9IG51bGw7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9uZXh0QWRkZWQgPSBudWxsO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fbmV4dE1vdmVkID0gbnVsbDtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX25leHRJZGVudGl0eUNoYW5nZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBDb2xsZWN0aW9uQ2hhbmdlUmVjb3JkLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByZXZpb3VzSW5kZXggPT09IHRoaXMuY3VycmVudEluZGV4ID8gc3RyaW5naWZ5KHRoaXMuaXRlbSkgOlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSh0aGlzLml0ZW0pICsgJ1snICtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5naWZ5KHRoaXMucHJldmlvdXNJbmRleCkgKyAnLT4nICsgc3RyaW5naWZ5KHRoaXMuY3VycmVudEluZGV4KSArICddJztcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIENvbGxlY3Rpb25DaGFuZ2VSZWNvcmQ7XG4gICAgfSgpKTtcbiAgICB2YXIgX0R1cGxpY2F0ZUl0ZW1SZWNvcmRMaXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gX0R1cGxpY2F0ZUl0ZW1SZWNvcmRMaXN0KCkge1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5faGVhZCA9IG51bGw7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl90YWlsID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQXBwZW5kIHRoZSByZWNvcmQgdG8gdGhlIGxpc3Qgb2YgZHVwbGljYXRlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogTm90ZTogYnkgZGVzaWduIGFsbCByZWNvcmRzIGluIHRoZSBsaXN0IG9mIGR1cGxpY2F0ZXMgaG9sZCB0aGUgc2FtZSB2YWx1ZSBpbiByZWNvcmQuaXRlbS5cbiAgICAgICAgICogQHBhcmFtIHs/fSByZWNvcmRcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIF9EdXBsaWNhdGVJdGVtUmVjb3JkTGlzdC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2hlYWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9oZWFkID0gdGhpcy5fdGFpbCA9IHJlY29yZDtcbiAgICAgICAgICAgICAgICByZWNvcmQuX25leHREdXAgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJlY29yZC5fcHJldkR1cCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB0b2RvKHZpY2IpXG4gICAgICAgICAgICAgICAgLy8gYXNzZXJ0KHJlY29yZC5pdGVtID09ICBfaGVhZC5pdGVtIHx8XG4gICAgICAgICAgICAgICAgLy8gICAgICAgcmVjb3JkLml0ZW0gaXMgbnVtICYmIHJlY29yZC5pdGVtLmlzTmFOICYmIF9oZWFkLml0ZW0gaXMgbnVtICYmIF9oZWFkLml0ZW0uaXNOYU4pO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RhaWwuX25leHREdXAgPSByZWNvcmQ7XG4gICAgICAgICAgICAgICAgcmVjb3JkLl9wcmV2RHVwID0gdGhpcy5fdGFpbDtcbiAgICAgICAgICAgICAgICByZWNvcmQuX25leHREdXAgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RhaWwgPSByZWNvcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHRyYWNrQnlJZFxuICAgICAgICAgKiBAcGFyYW0gez99IGFmdGVySW5kZXhcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIF9EdXBsaWNhdGVJdGVtUmVjb3JkTGlzdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHRyYWNrQnlJZCwgYWZ0ZXJJbmRleCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVjb3JkO1xuICAgICAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9oZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dER1cCkge1xuICAgICAgICAgICAgICAgIGlmICgoYWZ0ZXJJbmRleCA9PT0gbnVsbCB8fCBhZnRlckluZGV4IDwgcmVjb3JkLmN1cnJlbnRJbmRleCkgJiZcbiAgICAgICAgICAgICAgICAgICAgbG9vc2VJZGVudGljYWwocmVjb3JkLnRyYWNrQnlJZCwgdHJhY2tCeUlkKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlIG9uZSB7XFxAbGluayBDb2xsZWN0aW9uQ2hhbmdlUmVjb3JkfSBmcm9tIHRoZSBsaXN0IG9mIGR1cGxpY2F0ZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgbGlzdCBvZiBkdXBsaWNhdGVzIGlzIGVtcHR5LlxuICAgICAgICAgKiBAcGFyYW0gez99IHJlY29yZFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgX0R1cGxpY2F0ZUl0ZW1SZWNvcmRMaXN0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgICAvLyB0b2RvKHZpY2IpXG4gICAgICAgICAgICAvLyBhc3NlcnQoKCkge1xuICAgICAgICAgICAgLy8gIC8vIHZlcmlmeSB0aGF0IHRoZSByZWNvcmQgYmVpbmcgcmVtb3ZlZCBpcyBpbiB0aGUgbGlzdC5cbiAgICAgICAgICAgIC8vICBmb3IgKENvbGxlY3Rpb25DaGFuZ2VSZWNvcmQgY3Vyc29yID0gX2hlYWQ7IGN1cnNvciAhPSBudWxsOyBjdXJzb3IgPSBjdXJzb3IuX25leHREdXApIHtcbiAgICAgICAgICAgIC8vICAgIGlmIChpZGVudGljYWwoY3Vyc29yLCByZWNvcmQpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIC8vICB9XG4gICAgICAgICAgICAvLyAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgLy99KTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZXYgPSByZWNvcmQuX3ByZXZEdXA7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZXh0ID0gcmVjb3JkLl9uZXh0RHVwO1xuICAgICAgICAgICAgaWYgKHByZXYgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9oZWFkID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByZXYuX25leHREdXAgPSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5leHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90YWlsID0gcHJldjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5leHQuX3ByZXZEdXAgPSBwcmV2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hlYWQgPT09IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfRHVwbGljYXRlSXRlbVJlY29yZExpc3Q7XG4gICAgfSgpKTtcbiAgICB2YXIgX0R1cGxpY2F0ZU1hcCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIF9EdXBsaWNhdGVNYXAoKSB7XG4gICAgICAgICAgICB0aGlzLm1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSByZWNvcmRcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIF9EdXBsaWNhdGVNYXAucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGtleSA9IHJlY29yZC50cmFja0J5SWQ7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkdXBsaWNhdGVzID0gdGhpcy5tYXAuZ2V0KGtleSk7XG4gICAgICAgICAgICBpZiAoIWR1cGxpY2F0ZXMpIHtcbiAgICAgICAgICAgICAgICBkdXBsaWNhdGVzID0gbmV3IF9EdXBsaWNhdGVJdGVtUmVjb3JkTGlzdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMubWFwLnNldChrZXksIGR1cGxpY2F0ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZHVwbGljYXRlcy5hZGQocmVjb3JkKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHJpZXZlIHRoZSBgdmFsdWVgIHVzaW5nIGtleS4gQmVjYXVzZSB0aGUgQ29sbGVjdGlvbkNoYW5nZVJlY29yZCB2YWx1ZSBtYXkgYmUgb25lIHdoaWNoIHdlXG4gICAgICAgICAqIGhhdmUgYWxyZWFkeSBpdGVyYXRlZCBvdmVyLCB3ZSB1c2UgdGhlIGFmdGVySW5kZXggdG8gcHJldGVuZCBpdCBpcyBub3QgdGhlcmUuXG4gICAgICAgICAqXG4gICAgICAgICAqIFVzZSBjYXNlOiBgW2EsIGIsIGMsIGEsIGFdYCBpZiB3ZSBhcmUgYXQgaW5kZXggYDNgIHdoaWNoIGlzIHRoZSBzZWNvbmQgYGFgIHRoZW4gYXNraW5nIGlmIHdlXG4gICAgICAgICAqIGhhdmUgYW55IG1vcmUgYGFgcyBuZWVkcyB0byByZXR1cm4gdGhlIGxhc3QgYGFgIG5vdCB0aGUgZmlyc3Qgb3Igc2Vjb25kLlxuICAgICAgICAgKiBAcGFyYW0gez99IHRyYWNrQnlJZFxuICAgICAgICAgKiBAcGFyYW0gez89fSBhZnRlckluZGV4XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBfRHVwbGljYXRlTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodHJhY2tCeUlkLCBhZnRlckluZGV4KSB7XG4gICAgICAgICAgICBpZiAoYWZ0ZXJJbmRleCA9PT0gdm9pZCAwKSB7IGFmdGVySW5kZXggPSBudWxsOyB9XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBrZXkgPSB0cmFja0J5SWQ7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZWNvcmRMaXN0ID0gdGhpcy5tYXAuZ2V0KGtleSk7XG4gICAgICAgICAgICByZXR1cm4gcmVjb3JkTGlzdCA/IHJlY29yZExpc3QuZ2V0KHRyYWNrQnlJZCwgYWZ0ZXJJbmRleCkgOiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlcyBhIHtcXEBsaW5rIENvbGxlY3Rpb25DaGFuZ2VSZWNvcmR9IGZyb20gdGhlIGxpc3Qgb2YgZHVwbGljYXRlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGxpc3Qgb2YgZHVwbGljYXRlcyBhbHNvIGlzIHJlbW92ZWQgZnJvbSB0aGUgbWFwIGlmIGl0IGdldHMgZW1wdHkuXG4gICAgICAgICAqIEBwYXJhbSB7P30gcmVjb3JkXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBfRHVwbGljYXRlTWFwLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBrZXkgPSByZWNvcmQudHJhY2tCeUlkO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVjb3JkTGlzdCA9IHRoaXMubWFwLmdldChrZXkpO1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBsaXN0IG9mIGR1cGxpY2F0ZXMgd2hlbiBpdCBnZXRzIGVtcHR5XG4gICAgICAgICAgICBpZiAocmVjb3JkTGlzdC5yZW1vdmUocmVjb3JkKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubWFwLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9EdXBsaWNhdGVNYXAucHJvdG90eXBlLCBcImlzRW1wdHlcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubWFwLnNpemUgPT09IDA7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIF9EdXBsaWNhdGVNYXAucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkgeyB0aGlzLm1hcC5jbGVhcigpOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIF9EdXBsaWNhdGVNYXAucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ19EdXBsaWNhdGVNYXAoJyArIHN0cmluZ2lmeSh0aGlzLm1hcCkgKyAnKSc7IH07XG4gICAgICAgIHJldHVybiBfRHVwbGljYXRlTWFwO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpdGVtXG4gICAgICogQHBhcmFtIHs/fSBhZGRSZW1vdmVPZmZzZXRcbiAgICAgKiBAcGFyYW0gez99IG1vdmVPZmZzZXRzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRQcmV2aW91c0luZGV4KGl0ZW0sIGFkZFJlbW92ZU9mZnNldCwgbW92ZU9mZnNldHMpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJldmlvdXNJbmRleCA9IGl0ZW0ucHJldmlvdXNJbmRleDtcbiAgICAgICAgaWYgKHByZXZpb3VzSW5kZXggPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gcHJldmlvdXNJbmRleDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbW92ZU9mZnNldCA9IDA7XG4gICAgICAgIGlmIChtb3ZlT2Zmc2V0cyAmJiBwcmV2aW91c0luZGV4IDwgbW92ZU9mZnNldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBtb3ZlT2Zmc2V0ID0gbW92ZU9mZnNldHNbcHJldmlvdXNJbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByZXZpb3VzSW5kZXggKyBhZGRSZW1vdmVPZmZzZXQgKyBtb3ZlT2Zmc2V0O1xuICAgIH1cblxuICAgIHZhciBEZWZhdWx0S2V5VmFsdWVEaWZmZXJGYWN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRGVmYXVsdEtleVZhbHVlRGlmZmVyRmFjdG9yeSgpIHtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBvYmpcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIERlZmF1bHRLZXlWYWx1ZURpZmZlckZhY3RvcnkucHJvdG90eXBlLnN1cHBvcnRzID0gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqIGluc3RhbmNlb2YgTWFwIHx8IGlzSnNPYmplY3Qob2JqKTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gY2RSZWZcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIERlZmF1bHRLZXlWYWx1ZURpZmZlckZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uIChjZFJlZikgeyByZXR1cm4gbmV3IERlZmF1bHRLZXlWYWx1ZURpZmZlcigpOyB9O1xuICAgICAgICByZXR1cm4gRGVmYXVsdEtleVZhbHVlRGlmZmVyRmFjdG9yeTtcbiAgICB9KCkpO1xuICAgIHZhciBEZWZhdWx0S2V5VmFsdWVEaWZmZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBEZWZhdWx0S2V5VmFsdWVEaWZmZXIoKSB7XG4gICAgICAgICAgICB0aGlzLl9yZWNvcmRzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgdGhpcy5fbWFwSGVhZCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9wcmV2aW91c01hcEhlYWQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlc0hlYWQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlc1RhaWwgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fYWRkaXRpb25zSGVhZCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9hZGRpdGlvbnNUYWlsID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3JlbW92YWxzSGVhZCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmFsc1RhaWwgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWZhdWx0S2V5VmFsdWVEaWZmZXIucHJvdG90eXBlLCBcImlzRGlydHlcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYWRkaXRpb25zSGVhZCAhPT0gbnVsbCB8fCB0aGlzLl9jaGFuZ2VzSGVhZCAhPT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmFsc0hlYWQgIT09IG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIERlZmF1bHRLZXlWYWx1ZURpZmZlci5wcm90b3R5cGUuZm9yRWFjaEl0ZW0gPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlY29yZDtcbiAgICAgICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5fbWFwSGVhZDsgcmVjb3JkICE9PSBudWxsOyByZWNvcmQgPSByZWNvcmQuX25leHQpIHtcbiAgICAgICAgICAgICAgICBmbihyZWNvcmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBmblxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZS5mb3JFYWNoUHJldmlvdXNJdGVtID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZWNvcmQ7XG4gICAgICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX3ByZXZpb3VzTWFwSGVhZDsgcmVjb3JkICE9PSBudWxsOyByZWNvcmQgPSByZWNvcmQuX25leHRQcmV2aW91cykge1xuICAgICAgICAgICAgICAgIGZuKHJlY29yZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXIucHJvdG90eXBlLmZvckVhY2hDaGFuZ2VkSXRlbSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVjb3JkO1xuICAgICAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9jaGFuZ2VzSGVhZDsgcmVjb3JkICE9PSBudWxsOyByZWNvcmQgPSByZWNvcmQuX25leHRDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgZm4ocmVjb3JkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIERlZmF1bHRLZXlWYWx1ZURpZmZlci5wcm90b3R5cGUuZm9yRWFjaEFkZGVkSXRlbSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVjb3JkO1xuICAgICAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9hZGRpdGlvbnNIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dEFkZGVkKSB7XG4gICAgICAgICAgICAgICAgZm4ocmVjb3JkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIERlZmF1bHRLZXlWYWx1ZURpZmZlci5wcm90b3R5cGUuZm9yRWFjaFJlbW92ZWRJdGVtID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZWNvcmQ7XG4gICAgICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX3JlbW92YWxzSGVhZDsgcmVjb3JkICE9PSBudWxsOyByZWNvcmQgPSByZWNvcmQuX25leHRSZW1vdmVkKSB7XG4gICAgICAgICAgICAgICAgZm4ocmVjb3JkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gbWFwXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXIucHJvdG90eXBlLmRpZmYgPSBmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgICAgICBpZiAoIW1hcCkge1xuICAgICAgICAgICAgICAgIG1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCEobWFwIGluc3RhbmNlb2YgTWFwIHx8IGlzSnNPYmplY3QobWFwKSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciB0cnlpbmcgdG8gZGlmZiAnXCIgKyBtYXAgKyBcIidcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGVjayhtYXApID8gdGhpcyA6IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZS5vbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IG1hcFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZS5jaGVjayA9IGZ1bmN0aW9uIChtYXApIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLl9yZXNldCgpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVjb3JkcyA9IHRoaXMuX3JlY29yZHM7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvbGRTZXFSZWNvcmQgPSB0aGlzLl9tYXBIZWFkO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGFzdE9sZFNlcVJlY29yZCA9IG51bGw7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsYXN0TmV3U2VxUmVjb3JkID0gbnVsbDtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNlcUNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2ZvckVhY2gobWFwLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5ld1NlcVJlY29yZDtcbiAgICAgICAgICAgICAgICBpZiAob2xkU2VxUmVjb3JkICYmIGtleSA9PT0gb2xkU2VxUmVjb3JkLmtleSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdTZXFSZWNvcmQgPSBvbGRTZXFSZWNvcmQ7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9tYXliZUFkZFRvQ2hhbmdlcyhuZXdTZXFSZWNvcmQsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNlcUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAob2xkU2VxUmVjb3JkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVtb3ZlRnJvbVNlcShsYXN0T2xkU2VxUmVjb3JkLCBvbGRTZXFSZWNvcmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2FkZFRvUmVtb3ZhbHMob2xkU2VxUmVjb3JkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVjb3Jkcy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3U2VxUmVjb3JkID0gcmVjb3Jkcy5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9tYXliZUFkZFRvQ2hhbmdlcyhuZXdTZXFSZWNvcmQsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1NlcVJlY29yZCA9IG5ldyBLZXlWYWx1ZUNoYW5nZVJlY29yZChrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3Jkcy5zZXQoa2V5LCBuZXdTZXFSZWNvcmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3U2VxUmVjb3JkLmN1cnJlbnRWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2FkZFRvQWRkaXRpb25zKG5ld1NlcVJlY29yZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlcUNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLl9pc0luUmVtb3ZhbHMobmV3U2VxUmVjb3JkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlbW92ZUZyb21SZW1vdmFscyhuZXdTZXFSZWNvcmQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXN0TmV3U2VxUmVjb3JkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9tYXBIZWFkID0gbmV3U2VxUmVjb3JkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdE5ld1NlcVJlY29yZC5fbmV4dCA9IG5ld1NlcVJlY29yZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsYXN0T2xkU2VxUmVjb3JkID0gb2xkU2VxUmVjb3JkO1xuICAgICAgICAgICAgICAgIGxhc3ROZXdTZXFSZWNvcmQgPSBuZXdTZXFSZWNvcmQ7XG4gICAgICAgICAgICAgICAgb2xkU2VxUmVjb3JkID0gb2xkU2VxUmVjb3JkICYmIG9sZFNlcVJlY29yZC5fbmV4dDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fdHJ1bmNhdGUobGFzdE9sZFNlcVJlY29yZCwgb2xkU2VxUmVjb3JkKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzRGlydHk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBcXEBpbnRlcm5hbFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZS5fcmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0RpcnR5KSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVjb3JkID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIC8vIFJlY29yZCB0aGUgc3RhdGUgb2YgdGhlIG1hcHBpbmdcbiAgICAgICAgICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX3ByZXZpb3VzTWFwSGVhZCA9IHRoaXMuX21hcEhlYWQ7IHJlY29yZCAhPT0gbnVsbDsgcmVjb3JkID0gcmVjb3JkLl9uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY29yZC5fbmV4dFByZXZpb3VzID0gcmVjb3JkLl9uZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX2NoYW5nZXNIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dENoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkLnByZXZpb3VzVmFsdWUgPSByZWNvcmQuY3VycmVudFZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX2FkZGl0aW9uc0hlYWQ7IHJlY29yZCAhPSBudWxsOyByZWNvcmQgPSByZWNvcmQuX25leHRBZGRlZCkge1xuICAgICAgICAgICAgICAgICAgICByZWNvcmQucHJldmlvdXNWYWx1ZSA9IHJlY29yZC5jdXJyZW50VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZXNIZWFkID0gdGhpcy5fY2hhbmdlc1RhaWwgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZGl0aW9uc0hlYWQgPSB0aGlzLl9hZGRpdGlvbnNUYWlsID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmFsc0hlYWQgPSB0aGlzLl9yZW1vdmFsc1RhaWwgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogXFxAaW50ZXJuYWxcbiAgICAgICAgICogQHBhcmFtIHs/fSBsYXN0UmVjb3JkXG4gICAgICAgICAqIEBwYXJhbSB7P30gcmVjb3JkXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXIucHJvdG90eXBlLl90cnVuY2F0ZSA9IGZ1bmN0aW9uIChsYXN0UmVjb3JkLCByZWNvcmQpIHtcbiAgICAgICAgICAgIHdoaWxlIChyZWNvcmQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAobGFzdFJlY29yZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXBIZWFkID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RSZWNvcmQuX25leHQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZXh0UmVjb3JkID0gcmVjb3JkLl9uZXh0O1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZFRvUmVtb3ZhbHMocmVjb3JkKTtcbiAgICAgICAgICAgICAgICBsYXN0UmVjb3JkID0gcmVjb3JkO1xuICAgICAgICAgICAgICAgIHJlY29yZCA9IG5leHRSZWNvcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIHJlYyA9IHRoaXMuX3JlbW92YWxzSGVhZDsgcmVjICE9PSBudWxsOyByZWMgPSByZWMuX25leHRSZW1vdmVkKSB7XG4gICAgICAgICAgICAgICAgcmVjLnByZXZpb3VzVmFsdWUgPSByZWMuY3VycmVudFZhbHVlO1xuICAgICAgICAgICAgICAgIHJlYy5jdXJyZW50VmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlY29yZHMuZGVsZXRlKHJlYy5rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSByZWNvcmRcbiAgICAgICAgICogQHBhcmFtIHs/fSBuZXdWYWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZS5fbWF5YmVBZGRUb0NoYW5nZXMgPSBmdW5jdGlvbiAocmVjb3JkLCBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKCFsb29zZUlkZW50aWNhbChuZXdWYWx1ZSwgcmVjb3JkLmN1cnJlbnRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZWNvcmQucHJldmlvdXNWYWx1ZSA9IHJlY29yZC5jdXJyZW50VmFsdWU7XG4gICAgICAgICAgICAgICAgcmVjb3JkLmN1cnJlbnRWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZFRvQ2hhbmdlcyhyZWNvcmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogXFxAaW50ZXJuYWxcbiAgICAgICAgICogQHBhcmFtIHs/fSByZWNvcmRcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIERlZmF1bHRLZXlWYWx1ZURpZmZlci5wcm90b3R5cGUuX2lzSW5SZW1vdmFscyA9IGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICAgIHJldHVybiByZWNvcmQgPT09IHRoaXMuX3JlbW92YWxzSGVhZCB8fCByZWNvcmQuX25leHRSZW1vdmVkICE9PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgcmVjb3JkLl9wcmV2UmVtb3ZlZCAhPT0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxcQGludGVybmFsXG4gICAgICAgICAqIEBwYXJhbSB7P30gcmVjb3JkXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXIucHJvdG90eXBlLl9hZGRUb1JlbW92YWxzID0gZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3JlbW92YWxzSGVhZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92YWxzSGVhZCA9IHRoaXMuX3JlbW92YWxzVGFpbCA9IHJlY29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92YWxzVGFpbC5fbmV4dFJlbW92ZWQgPSByZWNvcmQ7XG4gICAgICAgICAgICAgICAgcmVjb3JkLl9wcmV2UmVtb3ZlZCA9IHRoaXMuX3JlbW92YWxzVGFpbDtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmFsc1RhaWwgPSByZWNvcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBcXEBpbnRlcm5hbFxuICAgICAgICAgKiBAcGFyYW0gez99IHByZXZcbiAgICAgICAgICogQHBhcmFtIHs/fSByZWNvcmRcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIERlZmF1bHRLZXlWYWx1ZURpZmZlci5wcm90b3R5cGUuX3JlbW92ZUZyb21TZXEgPSBmdW5jdGlvbiAocHJldiwgcmVjb3JkKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZXh0ID0gcmVjb3JkLl9uZXh0O1xuICAgICAgICAgICAgaWYgKHByZXYgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXBIZWFkID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByZXYuX25leHQgPSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVjb3JkLl9uZXh0ID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxcQGludGVybmFsXG4gICAgICAgICAqIEBwYXJhbSB7P30gcmVjb3JkXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXIucHJvdG90eXBlLl9yZW1vdmVGcm9tUmVtb3ZhbHMgPSBmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcmV2ID0gcmVjb3JkLl9wcmV2UmVtb3ZlZDtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5leHQgPSByZWNvcmQuX25leHRSZW1vdmVkO1xuICAgICAgICAgICAgaWYgKHByZXYgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmFsc0hlYWQgPSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJldi5fbmV4dFJlbW92ZWQgPSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5leHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmFsc1RhaWwgPSBwcmV2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV4dC5fcHJldlJlbW92ZWQgPSBwcmV2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVjb3JkLl9wcmV2UmVtb3ZlZCA9IHJlY29yZC5fbmV4dFJlbW92ZWQgPSBudWxsO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogXFxAaW50ZXJuYWxcbiAgICAgICAgICogQHBhcmFtIHs/fSByZWNvcmRcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIERlZmF1bHRLZXlWYWx1ZURpZmZlci5wcm90b3R5cGUuX2FkZFRvQWRkaXRpb25zID0gZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2FkZGl0aW9uc0hlYWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRpdGlvbnNIZWFkID0gdGhpcy5fYWRkaXRpb25zVGFpbCA9IHJlY29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZGl0aW9uc1RhaWwuX25leHRBZGRlZCA9IHJlY29yZDtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRpdGlvbnNUYWlsID0gcmVjb3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogXFxAaW50ZXJuYWxcbiAgICAgICAgICogQHBhcmFtIHs/fSByZWNvcmRcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIERlZmF1bHRLZXlWYWx1ZURpZmZlci5wcm90b3R5cGUuX2FkZFRvQ2hhbmdlcyA9IGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jaGFuZ2VzSGVhZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZXNIZWFkID0gdGhpcy5fY2hhbmdlc1RhaWwgPSByZWNvcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VzVGFpbC5fbmV4dENoYW5nZWQgPSByZWNvcmQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlc1RhaWwgPSByZWNvcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGl0ZW1zID0gW107XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcmV2aW91cyA9IFtdO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2hhbmdlcyA9IFtdO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYWRkaXRpb25zID0gW107XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZW1vdmFscyA9IFtdO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVjb3JkO1xuICAgICAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9tYXBIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dCkge1xuICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goc3RyaW5naWZ5KHJlY29yZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9wcmV2aW91c01hcEhlYWQ7IHJlY29yZCAhPT0gbnVsbDsgcmVjb3JkID0gcmVjb3JkLl9uZXh0UHJldmlvdXMpIHtcbiAgICAgICAgICAgICAgICBwcmV2aW91cy5wdXNoKHN0cmluZ2lmeShyZWNvcmQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5fY2hhbmdlc0hlYWQ7IHJlY29yZCAhPT0gbnVsbDsgcmVjb3JkID0gcmVjb3JkLl9uZXh0Q2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaChzdHJpbmdpZnkocmVjb3JkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX2FkZGl0aW9uc0hlYWQ7IHJlY29yZCAhPT0gbnVsbDsgcmVjb3JkID0gcmVjb3JkLl9uZXh0QWRkZWQpIHtcbiAgICAgICAgICAgICAgICBhZGRpdGlvbnMucHVzaChzdHJpbmdpZnkocmVjb3JkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX3JlbW92YWxzSGVhZDsgcmVjb3JkICE9PSBudWxsOyByZWNvcmQgPSByZWNvcmQuX25leHRSZW1vdmVkKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZhbHMucHVzaChzdHJpbmdpZnkocmVjb3JkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJ21hcDogJyArIGl0ZW1zLmpvaW4oJywgJykgKyAnXFxuJyArXG4gICAgICAgICAgICAgICAgJ3ByZXZpb3VzOiAnICsgcHJldmlvdXMuam9pbignLCAnKSArICdcXG4nICtcbiAgICAgICAgICAgICAgICAnYWRkaXRpb25zOiAnICsgYWRkaXRpb25zLmpvaW4oJywgJykgKyAnXFxuJyArXG4gICAgICAgICAgICAgICAgJ2NoYW5nZXM6ICcgKyBjaGFuZ2VzLmpvaW4oJywgJykgKyAnXFxuJyArXG4gICAgICAgICAgICAgICAgJ3JlbW92YWxzOiAnICsgcmVtb3ZhbHMuam9pbignLCAnKSArICdcXG4nO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogXFxAaW50ZXJuYWxcbiAgICAgICAgICogQHBhcmFtIHs/fSBvYmpcbiAgICAgICAgICogQHBhcmFtIHs/fSBmblxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZS5fZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmosIGZuKSB7XG4gICAgICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgICAgICAgICAgb2JqLmZvckVhY2goZm4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7IHJldHVybiBmbihvYmpba10sIGspOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIERlZmF1bHRLZXlWYWx1ZURpZmZlcjtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIFxcQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBLZXlWYWx1ZUNoYW5nZVJlY29yZCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGtleVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gS2V5VmFsdWVDaGFuZ2VSZWNvcmQoa2V5KSB7XG4gICAgICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXNWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9uZXh0UHJldmlvdXMgPSBudWxsO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fbmV4dCA9IG51bGw7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9uZXh0QWRkZWQgPSBudWxsO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fbmV4dFJlbW92ZWQgPSBudWxsO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fcHJldlJlbW92ZWQgPSBudWxsO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fbmV4dENoYW5nZWQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgS2V5VmFsdWVDaGFuZ2VSZWNvcmQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvb3NlSWRlbnRpY2FsKHRoaXMucHJldmlvdXNWYWx1ZSwgdGhpcy5jdXJyZW50VmFsdWUpID9cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkodGhpcy5rZXkpIDpcbiAgICAgICAgICAgICAgICAoc3RyaW5naWZ5KHRoaXMua2V5KSArICdbJyArIHN0cmluZ2lmeSh0aGlzLnByZXZpb3VzVmFsdWUpICsgJy0+JyArXG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ2lmeSh0aGlzLmN1cnJlbnRWYWx1ZSkgKyAnXScpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gS2V5VmFsdWVDaGFuZ2VSZWNvcmQ7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEEgcmVwb3NpdG9yeSBvZiBkaWZmZXJlbnQgaXRlcmFibGUgZGlmZmluZyBzdHJhdGVnaWVzIHVzZWQgYnkgTmdGb3IsIE5nQ2xhc3MsIGFuZCBvdGhlcnMuXG4gICAgICogXFxAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEl0ZXJhYmxlRGlmZmVycyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGZhY3Rvcmllc1xuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gSXRlcmFibGVEaWZmZXJzKGZhY3Rvcmllcykge1xuICAgICAgICAgICAgdGhpcy5mYWN0b3JpZXMgPSBmYWN0b3JpZXM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gZmFjdG9yaWVzXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IHBhcmVudFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgSXRlcmFibGVEaWZmZXJzLmNyZWF0ZSA9IGZ1bmN0aW9uIChmYWN0b3JpZXMsIHBhcmVudCkge1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChwYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29waWVkID0gcGFyZW50LmZhY3Rvcmllcy5zbGljZSgpO1xuICAgICAgICAgICAgICAgIGZhY3RvcmllcyA9IGZhY3Rvcmllcy5jb25jYXQoY29waWVkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEl0ZXJhYmxlRGlmZmVycyhmYWN0b3JpZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJdGVyYWJsZURpZmZlcnMoZmFjdG9yaWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRha2VzIGFuIGFycmF5IG9mIHtcXEBsaW5rIEl0ZXJhYmxlRGlmZmVyRmFjdG9yeX0gYW5kIHJldHVybnMgYSBwcm92aWRlciB1c2VkIHRvIGV4dGVuZCB0aGVcbiAgICAgICAgICogaW5oZXJpdGVkIHtcXEBsaW5rIEl0ZXJhYmxlRGlmZmVyc30gaW5zdGFuY2Ugd2l0aCB0aGUgcHJvdmlkZWQgZmFjdG9yaWVzIGFuZCByZXR1cm4gYSBuZXdcbiAgICAgICAgICoge1xcQGxpbmsgSXRlcmFibGVEaWZmZXJzfSBpbnN0YW5jZS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGZvbGxvd2luZyBleGFtcGxlIHNob3dzIGhvdyB0byBleHRlbmQgYW4gZXhpc3RpbmcgbGlzdCBvZiBmYWN0b3JpZXMsXG4gICAgICAgICAqIHdoaWNoIHdpbGwgb25seSBiZSBhcHBsaWVkIHRvIHRoZSBpbmplY3RvciBmb3IgdGhpcyBjb21wb25lbnQgYW5kIGl0cyBjaGlsZHJlbi5cbiAgICAgICAgICogVGhpcyBzdGVwIGlzIGFsbCB0aGF0J3MgcmVxdWlyZWQgdG8gbWFrZSBhIG5ldyB7XFxAbGluayBJdGVyYWJsZURpZmZlcn0gYXZhaWxhYmxlLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICogXFxAQ29tcG9uZW50KHtcbiAgICAgICAgICogICB2aWV3UHJvdmlkZXJzOiBbXG4gICAgICAgICAqICAgICBJdGVyYWJsZURpZmZlcnMuZXh0ZW5kKFtuZXcgSW1tdXRhYmxlTGlzdERpZmZlcigpXSlcbiAgICAgICAgICogICBdXG4gICAgICAgICAqIH0pXG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKiBAcGFyYW0gez99IGZhY3Rvcmllc1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgSXRlcmFibGVEaWZmZXJzLmV4dGVuZCA9IGZ1bmN0aW9uIChmYWN0b3JpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZTogSXRlcmFibGVEaWZmZXJzLFxuICAgICAgICAgICAgICAgIHVzZUZhY3Rvcnk6IGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFR5cGljYWxseSB3b3VsZCBvY2N1ciB3aGVuIGNhbGxpbmcgSXRlcmFibGVEaWZmZXJzLmV4dGVuZCBpbnNpZGUgb2YgZGVwZW5kZW5jaWVzIHBhc3NlZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJvb3RzdHJhcCgpLCB3aGljaCB3b3VsZCBvdmVycmlkZSBkZWZhdWx0IHBpcGVzIGluc3RlYWQgb2YgZXh0ZW5kaW5nIHRoZW0uXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBleHRlbmQgSXRlcmFibGVEaWZmZXJzIHdpdGhvdXQgYSBwYXJlbnQgaW5qZWN0b3InKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSXRlcmFibGVEaWZmZXJzLmNyZWF0ZShmYWN0b3JpZXMsIHBhcmVudCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvLyBEZXBlbmRlbmN5IHRlY2huaWNhbGx5IGlzbid0IG9wdGlvbmFsLCBidXQgd2UgY2FuIHByb3ZpZGUgYSBiZXR0ZXIgZXJyb3IgbWVzc2FnZSB0aGlzIHdheS5cbiAgICAgICAgICAgICAgICBkZXBzOiBbW0l0ZXJhYmxlRGlmZmVycywgbmV3IFNraXBTZWxmKCksIG5ldyBPcHRpb25hbCgpXV1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGl0ZXJhYmxlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBJdGVyYWJsZURpZmZlcnMucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZhY3RvcnkgPSB0aGlzLmZhY3Rvcmllcy5maW5kKGZ1bmN0aW9uIChmKSB7IHJldHVybiBmLnN1cHBvcnRzKGl0ZXJhYmxlKTsgfSk7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KGZhY3RvcnkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhY3Rvcnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBhIGRpZmZlciBzdXBwb3J0aW5nIG9iamVjdCAnXCIgKyBpdGVyYWJsZSArIFwiJyBvZiB0eXBlICdcIiArIGdldFR5cGVOYW1lRm9yRGVidWdnaW5nKGl0ZXJhYmxlKSArIFwiJ1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEl0ZXJhYmxlRGlmZmVycztcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQSByZXBvc2l0b3J5IG9mIGRpZmZlcmVudCBNYXAgZGlmZmluZyBzdHJhdGVnaWVzIHVzZWQgYnkgTmdDbGFzcywgTmdTdHlsZSwgYW5kIG90aGVycy5cbiAgICAgKiBcXEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgS2V5VmFsdWVEaWZmZXJzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gZmFjdG9yaWVzXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBLZXlWYWx1ZURpZmZlcnMoZmFjdG9yaWVzKSB7XG4gICAgICAgICAgICB0aGlzLmZhY3RvcmllcyA9IGZhY3RvcmllcztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBmYWN0b3JpZXNcbiAgICAgICAgICogQHBhcmFtIHs/PX0gcGFyZW50XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBLZXlWYWx1ZURpZmZlcnMuY3JlYXRlID0gZnVuY3Rpb24gKGZhY3RvcmllcywgcGFyZW50KSB7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHBhcmVudCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb3BpZWQgPSBwYXJlbnQuZmFjdG9yaWVzLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgZmFjdG9yaWVzID0gZmFjdG9yaWVzLmNvbmNhdChjb3BpZWQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgS2V5VmFsdWVEaWZmZXJzKGZhY3Rvcmllcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEtleVZhbHVlRGlmZmVycyhmYWN0b3JpZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGFrZXMgYW4gYXJyYXkgb2Yge1xcQGxpbmsgS2V5VmFsdWVEaWZmZXJGYWN0b3J5fSBhbmQgcmV0dXJucyBhIHByb3ZpZGVyIHVzZWQgdG8gZXh0ZW5kIHRoZVxuICAgICAgICAgKiBpbmhlcml0ZWQge1xcQGxpbmsgS2V5VmFsdWVEaWZmZXJzfSBpbnN0YW5jZSB3aXRoIHRoZSBwcm92aWRlZCBmYWN0b3JpZXMgYW5kIHJldHVybiBhIG5ld1xuICAgICAgICAgKiB7XFxAbGluayBLZXlWYWx1ZURpZmZlcnN9IGluc3RhbmNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgZm9sbG93aW5nIGV4YW1wbGUgc2hvd3MgaG93IHRvIGV4dGVuZCBhbiBleGlzdGluZyBsaXN0IG9mIGZhY3RvcmllcyxcbiAgICAgICAgICogd2hpY2ggd2lsbCBvbmx5IGJlIGFwcGxpZWQgdG8gdGhlIGluamVjdG9yIGZvciB0aGlzIGNvbXBvbmVudCBhbmQgaXRzIGNoaWxkcmVuLlxuICAgICAgICAgKiBUaGlzIHN0ZXAgaXMgYWxsIHRoYXQncyByZXF1aXJlZCB0byBtYWtlIGEgbmV3IHtcXEBsaW5rIEtleVZhbHVlRGlmZmVyfSBhdmFpbGFibGUuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyBFeGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKiBcXEBDb21wb25lbnQoe1xuICAgICAgICAgKiAgIHZpZXdQcm92aWRlcnM6IFtcbiAgICAgICAgICogICAgIEtleVZhbHVlRGlmZmVycy5leHRlbmQoW25ldyBJbW11dGFibGVNYXBEaWZmZXIoKV0pXG4gICAgICAgICAqICAgXVxuICAgICAgICAgKiB9KVxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICogQHBhcmFtIHs/fSBmYWN0b3JpZXNcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEtleVZhbHVlRGlmZmVycy5leHRlbmQgPSBmdW5jdGlvbiAoZmFjdG9yaWVzKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IEtleVZhbHVlRGlmZmVycyxcbiAgICAgICAgICAgICAgICB1c2VGYWN0b3J5OiBmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUeXBpY2FsbHkgd291bGQgb2NjdXIgd2hlbiBjYWxsaW5nIEtleVZhbHVlRGlmZmVycy5leHRlbmQgaW5zaWRlIG9mIGRlcGVuZGVuY2llcyBwYXNzZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBib290c3RyYXAoKSwgd2hpY2ggd291bGQgb3ZlcnJpZGUgZGVmYXVsdCBwaXBlcyBpbnN0ZWFkIG9mIGV4dGVuZGluZyB0aGVtLlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZXh0ZW5kIEtleVZhbHVlRGlmZmVycyB3aXRob3V0IGEgcGFyZW50IGluamVjdG9yJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEtleVZhbHVlRGlmZmVycy5jcmVhdGUoZmFjdG9yaWVzLCBwYXJlbnQpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLy8gRGVwZW5kZW5jeSB0ZWNobmljYWxseSBpc24ndCBvcHRpb25hbCwgYnV0IHdlIGNhbiBwcm92aWRlIGEgYmV0dGVyIGVycm9yIG1lc3NhZ2UgdGhpcyB3YXkuXG4gICAgICAgICAgICAgICAgZGVwczogW1tLZXlWYWx1ZURpZmZlcnMsIG5ldyBTa2lwU2VsZigpLCBuZXcgT3B0aW9uYWwoKV1dXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBrdlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgS2V5VmFsdWVEaWZmZXJzLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKGt2KSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmYWN0b3J5ID0gdGhpcy5mYWN0b3JpZXMuZmluZChmdW5jdGlvbiAoZikgeyByZXR1cm4gZi5zdXBwb3J0cyhrdik7IH0pO1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChmYWN0b3J5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWN0b3J5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgYSBkaWZmZXIgc3VwcG9ydGluZyBvYmplY3QgJ1wiICsga3YgKyBcIidcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBLZXlWYWx1ZURpZmZlcnM7XG4gICAgfSgpKTtcblxuICAgIHZhciAvKiogQHR5cGUgez99ICovIFVOSU5JVElBTElaRUQgPSB7XG4gICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7IHJldHVybiAnQ0RfSU5JVF9WQUxVRSc7IH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYVxuICAgICAqIEBwYXJhbSB7P30gYlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gZGV2TW9kZUVxdWFsKGEsIGIpIHtcbiAgICAgICAgaWYgKGlzTGlzdExpa2VJdGVyYWJsZShhKSAmJiBpc0xpc3RMaWtlSXRlcmFibGUoYikpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmVJdGVyYWJsZXNFcXVhbChhLCBiLCBkZXZNb2RlRXF1YWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFpc0xpc3RMaWtlSXRlcmFibGUoYSkgJiYgIWlzUHJpbWl0aXZlKGEpICYmICFpc0xpc3RMaWtlSXRlcmFibGUoYikgJiYgIWlzUHJpbWl0aXZlKGIpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBsb29zZUlkZW50aWNhbChhLCBiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhhdCB0aGUgcmVzdWx0IG9mIGEge1xcQGxpbmsgUGlwZX0gdHJhbnNmb3JtYXRpb24gaGFzIGNoYW5nZWQgZXZlbiB0aG91Z2ggdGhlXG4gICAgICogcmVmZXJlbmNlXG4gICAgICogaGFzIG5vdCBjaGFuZ2VkLlxuICAgICAqXG4gICAgICogVGhlIHdyYXBwZWQgdmFsdWUgd2lsbCBiZSB1bndyYXBwZWQgYnkgY2hhbmdlIGRldGVjdGlvbiwgYW5kIHRoZSB1bndyYXBwZWQgdmFsdWUgd2lsbCBiZSBzdG9yZWQuXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogaWYgKHRoaXMuX2xhdGVzdFZhbHVlID09PSB0aGlzLl9sYXRlc3RSZXR1cm5lZFZhbHVlKSB7XG4gICAgICogICAgcmV0dXJuIHRoaXMuX2xhdGVzdFJldHVybmVkVmFsdWU7XG4gICAgICogIH0gZWxzZSB7XG4gICAgICogICAgdGhpcy5fbGF0ZXN0UmV0dXJuZWRWYWx1ZSA9IHRoaXMuX2xhdGVzdFZhbHVlO1xuICAgICAqICAgIHJldHVybiBXcmFwcGVkVmFsdWUud3JhcCh0aGlzLl9sYXRlc3RWYWx1ZSk7IC8vIHRoaXMgd2lsbCBmb3JjZSB1cGRhdGVcbiAgICAgKiAgfVxuICAgICAqIGBgYFxuICAgICAqIFxcQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBXcmFwcGVkVmFsdWUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB3cmFwcGVkXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBXcmFwcGVkVmFsdWUod3JhcHBlZCkge1xuICAgICAgICAgICAgdGhpcy53cmFwcGVkID0gd3JhcHBlZDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgV3JhcHBlZFZhbHVlLndyYXAgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIG5ldyBXcmFwcGVkVmFsdWUodmFsdWUpOyB9O1xuICAgICAgICByZXR1cm4gV3JhcHBlZFZhbHVlO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogSGVscGVyIGNsYXNzIGZvciB1bndyYXBwaW5nIFdyYXBwZWRWYWx1ZSBzXG4gICAgICovXG4gICAgdmFyIFZhbHVlVW53cmFwcGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gVmFsdWVVbndyYXBwZXIoKSB7XG4gICAgICAgICAgICB0aGlzLmhhc1dyYXBwZWRWYWx1ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBWYWx1ZVVud3JhcHBlci5wcm90b3R5cGUudW53cmFwID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBXcmFwcGVkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhc1dyYXBwZWRWYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLndyYXBwZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgVmFsdWVVbndyYXBwZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkgeyB0aGlzLmhhc1dyYXBwZWRWYWx1ZSA9IGZhbHNlOyB9O1xuICAgICAgICByZXR1cm4gVmFsdWVVbndyYXBwZXI7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGEgYmFzaWMgY2hhbmdlIGZyb20gYSBwcmV2aW91cyB0byBhIG5ldyB2YWx1ZS5cbiAgICAgKiBcXEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgU2ltcGxlQ2hhbmdlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gcHJldmlvdXNWYWx1ZVxuICAgICAgICAgKiBAcGFyYW0gez99IGN1cnJlbnRWYWx1ZVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gU2ltcGxlQ2hhbmdlKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5wcmV2aW91c1ZhbHVlID0gcHJldmlvdXNWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFZhbHVlID0gY3VycmVudFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVjayB3aGV0aGVyIHRoZSBuZXcgdmFsdWUgaXMgdGhlIGZpcnN0IHZhbHVlIGFzc2lnbmVkLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgU2ltcGxlQ2hhbmdlLnByb3RvdHlwZS5pc0ZpcnN0Q2hhbmdlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5wcmV2aW91c1ZhbHVlID09PSBVTklOSVRJQUxJWkVEOyB9O1xuICAgICAgICByZXR1cm4gU2ltcGxlQ2hhbmdlO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBcXEBzdGFibGVcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICB2YXIgQ2hhbmdlRGV0ZWN0b3JSZWYgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBDaGFuZ2VEZXRlY3RvclJlZigpIHtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogTWFya3MgYWxsIHtcXEBsaW5rIENoYW5nZURldGVjdGlvblN0cmF0ZWd5I09uUHVzaH0gYW5jZXN0b3JzIGFzIHRvIGJlIGNoZWNrZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIDwhLS0gVE9ETzogQWRkIGEgbGluayB0byBhIGNoYXB0ZXIgb24gT25QdXNoIGNvbXBvbmVudHMgLS0+XG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9HQzUxMmI/cD1wcmV2aWV3KSlcbiAgICAgICAgICpcbiAgICAgICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAgICAgKiBcXEBDb21wb25lbnQoe1xuICAgICAgICAgKiAgIHNlbGVjdG9yOiAnY21wJyxcbiAgICAgICAgICogICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgICogICB0ZW1wbGF0ZTogYE51bWJlciBvZiB0aWNrczoge3tudW1iZXJPZlRpY2tzfX1gXG4gICAgICAgICAqIH0pXG4gICAgICAgICAqIGNsYXNzIENtcCB7XG4gICAgICAgICAqICAgbnVtYmVyT2ZUaWNrcyA9IDA7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgY29uc3RydWN0b3IocmVmOiBDaGFuZ2VEZXRlY3RvclJlZikge1xuICAgICAgICAgKiAgICAgc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgKiAgICAgICB0aGlzLm51bWJlck9mVGlja3MgKytcbiAgICAgICAgICogICAgICAgLy8gdGhlIGZvbGxvd2luZyBpcyByZXF1aXJlZCwgb3RoZXJ3aXNlIHRoZSB2aWV3IHdpbGwgbm90IGJlIHVwZGF0ZWRcbiAgICAgICAgICogICAgICAgdGhpcy5yZWYubWFya0ZvckNoZWNrKCk7XG4gICAgICAgICAqICAgICB9LCAxMDAwKTtcbiAgICAgICAgICogICB9XG4gICAgICAgICAqIH1cbiAgICAgICAgICpcbiAgICAgICAgICogXFxAQ29tcG9uZW50KHtcbiAgICAgICAgICogICBzZWxlY3RvcjogJ2FwcCcsXG4gICAgICAgICAqICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgICAqICAgdGVtcGxhdGU6IGBcbiAgICAgICAgICogICAgIDxjbXA+PGNtcD5cbiAgICAgICAgICogICBgLFxuICAgICAgICAgKiB9KVxuICAgICAgICAgKiBjbGFzcyBBcHAge1xuICAgICAgICAgKiB9XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKiBAYWJzdHJhY3RcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIENoYW5nZURldGVjdG9yUmVmLnByb3RvdHlwZS5tYXJrRm9yQ2hlY2sgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRhY2hlcyB0aGUgY2hhbmdlIGRldGVjdG9yIGZyb20gdGhlIGNoYW5nZSBkZXRlY3RvciB0cmVlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgZGV0YWNoZWQgY2hhbmdlIGRldGVjdG9yIHdpbGwgbm90IGJlIGNoZWNrZWQgdW50aWwgaXQgaXMgcmVhdHRhY2hlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBjYW4gYWxzbyBiZSB1c2VkIGluIGNvbWJpbmF0aW9uIHdpdGgge1xcQGxpbmsgQ2hhbmdlRGV0ZWN0b3JSZWYjZGV0ZWN0Q2hhbmdlc30gdG8gaW1wbGVtZW50XG4gICAgICAgICAqIGxvY2FsIGNoYW5nZVxuICAgICAgICAgKiBkZXRlY3Rpb24gY2hlY2tzLlxuICAgICAgICAgKlxuICAgICAgICAgKiA8IS0tIFRPRE86IEFkZCBhIGxpbmsgdG8gYSBjaGFwdGVyIG9uIGRldGFjaC9yZWF0dGFjaC9sb2NhbCBkaWdlc3QgLS0+XG4gICAgICAgICAqIDwhLS0gVE9ETzogQWRkIGEgbGl2ZSBkZW1vIG9uY2UgcmVmLmRldGVjdENoYW5nZXMgaXMgbWVyZ2VkIGludG8gbWFzdGVyIC0tPlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgZm9sbG93aW5nIGV4YW1wbGUgZGVmaW5lcyBhIGNvbXBvbmVudCB3aXRoIGEgbGFyZ2UgbGlzdCBvZiByZWFkb25seSBkYXRhLlxuICAgICAgICAgKiBJbWFnaW5lIHRoZSBkYXRhIGNoYW5nZXMgY29uc3RhbnRseSwgbWFueSB0aW1lcyBwZXIgc2Vjb25kLiBGb3IgcGVyZm9ybWFuY2UgcmVhc29ucyxcbiAgICAgICAgICogd2Ugd2FudCB0byBjaGVjayBhbmQgdXBkYXRlIHRoZSBsaXN0IGV2ZXJ5IGZpdmUgc2Vjb25kcy4gV2UgY2FuIGRvIHRoYXQgYnkgZGV0YWNoaW5nXG4gICAgICAgICAqIHRoZSBjb21wb25lbnQncyBjaGFuZ2UgZGV0ZWN0b3IgYW5kIGRvaW5nIGEgbG9jYWwgY2hlY2sgZXZlcnkgZml2ZSBzZWNvbmRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICAgICAqIGNsYXNzIERhdGFQcm92aWRlciB7XG4gICAgICAgICAqICAgLy8gaW4gYSByZWFsIGFwcGxpY2F0aW9uIHRoZSByZXR1cm5lZCBkYXRhIHdpbGwgYmUgZGlmZmVyZW50IGV2ZXJ5IHRpbWVcbiAgICAgICAgICogICBnZXQgZGF0YSgpIHtcbiAgICAgICAgICogICAgIHJldHVybiBbMSwyLDMsNCw1XTtcbiAgICAgICAgICogICB9XG4gICAgICAgICAqIH1cbiAgICAgICAgICpcbiAgICAgICAgICogXFxAQ29tcG9uZW50KHtcbiAgICAgICAgICogICBzZWxlY3RvcjogJ2dpYW50LWxpc3QnLFxuICAgICAgICAgKiAgIHRlbXBsYXRlOiBgXG4gICAgICAgICAqICAgICA8bGkgKm5nRm9yPVwibGV0IGQgb2YgZGF0YVByb3ZpZGVyLmRhdGFcIj5EYXRhIHt7ZH19PC9saWc+XG4gICAgICAgICAqICAgYCxcbiAgICAgICAgICogfSlcbiAgICAgICAgICogY2xhc3MgR2lhbnRMaXN0IHtcbiAgICAgICAgICogICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYsIHByaXZhdGUgZGF0YVByb3ZpZGVyOkRhdGFQcm92aWRlcikge1xuICAgICAgICAgKiAgICAgcmVmLmRldGFjaCgpO1xuICAgICAgICAgKiAgICAgc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgKiAgICAgICB0aGlzLnJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgICAqICAgICB9LCA1MDAwKTtcbiAgICAgICAgICogICB9XG4gICAgICAgICAqIH1cbiAgICAgICAgICpcbiAgICAgICAgICogXFxAQ29tcG9uZW50KHtcbiAgICAgICAgICogICBzZWxlY3RvcjogJ2FwcCcsXG4gICAgICAgICAqICAgcHJvdmlkZXJzOiBbRGF0YVByb3ZpZGVyXSxcbiAgICAgICAgICogICB0ZW1wbGF0ZTogYFxuICAgICAgICAgKiAgICAgPGdpYW50LWxpc3Q+PGdpYW50LWxpc3Q+XG4gICAgICAgICAqICAgYCxcbiAgICAgICAgICogfSlcbiAgICAgICAgICogY2xhc3MgQXBwIHtcbiAgICAgICAgICogfVxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBDaGFuZ2VEZXRlY3RvclJlZi5wcm90b3R5cGUuZGV0YWNoID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2tzIHRoZSBjaGFuZ2UgZGV0ZWN0b3IgYW5kIGl0cyBjaGlsZHJlbi5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBjYW4gYWxzbyBiZSB1c2VkIGluIGNvbWJpbmF0aW9uIHdpdGgge1xcQGxpbmsgQ2hhbmdlRGV0ZWN0b3JSZWYjZGV0YWNofSB0byBpbXBsZW1lbnQgbG9jYWxcbiAgICAgICAgICogY2hhbmdlIGRldGVjdGlvblxuICAgICAgICAgKiBjaGVja3MuXG4gICAgICAgICAqXG4gICAgICAgICAqIDwhLS0gVE9ETzogQWRkIGEgbGluayB0byBhIGNoYXB0ZXIgb24gZGV0YWNoL3JlYXR0YWNoL2xvY2FsIGRpZ2VzdCAtLT5cbiAgICAgICAgICogPCEtLSBUT0RPOiBBZGQgYSBsaXZlIGRlbW8gb25jZSByZWYuZGV0ZWN0Q2hhbmdlcyBpcyBtZXJnZWQgaW50byBtYXN0ZXIgLS0+XG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyBFeGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBmb2xsb3dpbmcgZXhhbXBsZSBkZWZpbmVzIGEgY29tcG9uZW50IHdpdGggYSBsYXJnZSBsaXN0IG9mIHJlYWRvbmx5IGRhdGEuXG4gICAgICAgICAqIEltYWdpbmUsIHRoZSBkYXRhIGNoYW5nZXMgY29uc3RhbnRseSwgbWFueSB0aW1lcyBwZXIgc2Vjb25kLiBGb3IgcGVyZm9ybWFuY2UgcmVhc29ucyxcbiAgICAgICAgICogd2Ugd2FudCB0byBjaGVjayBhbmQgdXBkYXRlIHRoZSBsaXN0IGV2ZXJ5IGZpdmUgc2Vjb25kcy5cbiAgICAgICAgICpcbiAgICAgICAgICogV2UgY2FuIGRvIHRoYXQgYnkgZGV0YWNoaW5nIHRoZSBjb21wb25lbnQncyBjaGFuZ2UgZGV0ZWN0b3IgYW5kIGRvaW5nIGEgbG9jYWwgY2hhbmdlIGRldGVjdGlvblxuICAgICAgICAgKiBjaGVja1xuICAgICAgICAgKiBldmVyeSBmaXZlIHNlY29uZHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSB7XFxAbGluayBDaGFuZ2VEZXRlY3RvclJlZiNkZXRhY2h9IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgICAgICAgKiBAYWJzdHJhY3RcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIENoYW5nZURldGVjdG9yUmVmLnByb3RvdHlwZS5kZXRlY3RDaGFuZ2VzID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2tzIHRoZSBjaGFuZ2UgZGV0ZWN0b3IgYW5kIGl0cyBjaGlsZHJlbiwgYW5kIHRocm93cyBpZiBhbnkgY2hhbmdlcyBhcmUgZGV0ZWN0ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgaXMgdXNlZCBpbiBkZXZlbG9wbWVudCBtb2RlIHRvIHZlcmlmeSB0aGF0IHJ1bm5pbmcgY2hhbmdlIGRldGVjdGlvbiBkb2Vzbid0IGludHJvZHVjZVxuICAgICAgICAgKiBvdGhlciBjaGFuZ2VzLlxuICAgICAgICAgKiBAYWJzdHJhY3RcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIENoYW5nZURldGVjdG9yUmVmLnByb3RvdHlwZS5jaGVja05vQ2hhbmdlcyA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlYXR0YWNoIHRoZSBjaGFuZ2UgZGV0ZWN0b3IgdG8gdGhlIGNoYW5nZSBkZXRlY3RvciB0cmVlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGFsc28gbWFya3MgT25QdXNoIGFuY2VzdG9ycyBhcyB0byBiZSBjaGVja2VkLiBUaGlzIHJlYXR0YWNoZWQgY2hhbmdlIGRldGVjdG9yIHdpbGwgYmVcbiAgICAgICAgICogY2hlY2tlZCBkdXJpbmcgdGhlIG5leHQgY2hhbmdlIGRldGVjdGlvbiBydW4uXG4gICAgICAgICAqXG4gICAgICAgICAqIDwhLS0gVE9ETzogQWRkIGEgbGluayB0byBhIGNoYXB0ZXIgb24gZGV0YWNoL3JlYXR0YWNoL2xvY2FsIGRpZ2VzdCAtLT5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L2FVaFpoYT9wPXByZXZpZXcpKVxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgZm9sbG93aW5nIGV4YW1wbGUgY3JlYXRlcyBhIGNvbXBvbmVudCBkaXNwbGF5aW5nIGBsaXZlYCBkYXRhLiBUaGUgY29tcG9uZW50IHdpbGwgZGV0YWNoXG4gICAgICAgICAqIGl0cyBjaGFuZ2UgZGV0ZWN0b3IgZnJvbSB0aGUgbWFpbiBjaGFuZ2UgZGV0ZWN0b3IgdHJlZSB3aGVuIHRoZSBjb21wb25lbnQncyBsaXZlIHByb3BlcnR5XG4gICAgICAgICAqIGlzIHNldCB0byBmYWxzZS5cbiAgICAgICAgICpcbiAgICAgICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAgICAgKiBjbGFzcyBEYXRhUHJvdmlkZXIge1xuICAgICAgICAgKiAgIGRhdGEgPSAxO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgKiAgICAgc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgKiAgICAgICB0aGlzLmRhdGEgPSB0aGlzLmRhdGEgKiAyO1xuICAgICAgICAgKiAgICAgfSwgNTAwKTtcbiAgICAgICAgICogICB9XG4gICAgICAgICAqIH1cbiAgICAgICAgICpcbiAgICAgICAgICogXFxAQ29tcG9uZW50KHtcbiAgICAgICAgICogICBzZWxlY3RvcjogJ2xpdmUtZGF0YScsXG4gICAgICAgICAqICAgaW5wdXRzOiBbJ2xpdmUnXSxcbiAgICAgICAgICogICB0ZW1wbGF0ZTogJ0RhdGE6IHt7ZGF0YVByb3ZpZGVyLmRhdGF9fSdcbiAgICAgICAgICogfSlcbiAgICAgICAgICogY2xhc3MgTGl2ZURhdGEge1xuICAgICAgICAgKiAgIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVmOiBDaGFuZ2VEZXRlY3RvclJlZiwgcHJpdmF0ZSBkYXRhUHJvdmlkZXI6RGF0YVByb3ZpZGVyKSB7fVxuICAgICAgICAgKlxuICAgICAgICAgKiAgIHNldCBsaXZlKHZhbHVlKSB7XG4gICAgICAgICAqICAgICBpZiAodmFsdWUpXG4gICAgICAgICAqICAgICAgIHRoaXMucmVmLnJlYXR0YWNoKCk7XG4gICAgICAgICAqICAgICBlbHNlXG4gICAgICAgICAqICAgICAgIHRoaXMucmVmLmRldGFjaCgpO1xuICAgICAgICAgKiAgIH1cbiAgICAgICAgICogfVxuICAgICAgICAgKlxuICAgICAgICAgKiBcXEBDb21wb25lbnQoe1xuICAgICAgICAgKiAgIHNlbGVjdG9yOiAnYXBwJyxcbiAgICAgICAgICogICBwcm92aWRlcnM6IFtEYXRhUHJvdmlkZXJdLFxuICAgICAgICAgKiAgIHRlbXBsYXRlOiBgXG4gICAgICAgICAqICAgICBMaXZlIFVwZGF0ZTogPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIFsobmdNb2RlbCldPVwibGl2ZVwiPlxuICAgICAgICAgKiAgICAgPGxpdmUtZGF0YSBbbGl2ZV09XCJsaXZlXCI+PGxpdmUtZGF0YT5cbiAgICAgICAgICogICBgLFxuICAgICAgICAgKiB9KVxuICAgICAgICAgKiBjbGFzcyBBcHAge1xuICAgICAgICAgKiAgIGxpdmUgPSB0cnVlO1xuICAgICAgICAgKiB9XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKiBAYWJzdHJhY3RcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIENoYW5nZURldGVjdG9yUmVmLnByb3RvdHlwZS5yZWF0dGFjaCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgcmV0dXJuIENoYW5nZURldGVjdG9yUmVmO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBTdHJ1Y3R1cmFsIGRpZmZpbmcgZm9yIGBPYmplY3RgcyBhbmQgYE1hcGBzLlxuICAgICAqL1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGtleVZhbERpZmYgPSBbbmV3IERlZmF1bHRLZXlWYWx1ZURpZmZlckZhY3RvcnkoKV07XG4gICAgLyoqXG4gICAgICogU3RydWN0dXJhbCBkaWZmaW5nIGZvciBgSXRlcmFibGVgIHR5cGVzIHN1Y2ggYXMgYEFycmF5YHMuXG4gICAgICovXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXRlcmFibGVEaWZmID0gW25ldyBEZWZhdWx0SXRlcmFibGVEaWZmZXJGYWN0b3J5KCldO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlZmF1bHRJdGVyYWJsZURpZmZlcnMgPSBuZXcgSXRlcmFibGVEaWZmZXJzKGl0ZXJhYmxlRGlmZik7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVmYXVsdEtleVZhbHVlRGlmZmVycyA9IG5ldyBLZXlWYWx1ZURpZmZlcnMoa2V5VmFsRGlmZik7XG5cbiAgICB2YXIgUmVuZGVyQ29tcG9uZW50VHlwZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGlkXG4gICAgICAgICAqIEBwYXJhbSB7P30gdGVtcGxhdGVVcmxcbiAgICAgICAgICogQHBhcmFtIHs/fSBzbG90Q291bnRcbiAgICAgICAgICogQHBhcmFtIHs/fSBlbmNhcHN1bGF0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7P30gc3R5bGVzXG4gICAgICAgICAqIEBwYXJhbSB7P30gYW5pbWF0aW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gUmVuZGVyQ29tcG9uZW50VHlwZShpZCwgdGVtcGxhdGVVcmwsIHNsb3RDb3VudCwgZW5jYXBzdWxhdGlvbiwgc3R5bGVzLCBhbmltYXRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgICAgICB0aGlzLnRlbXBsYXRlVXJsID0gdGVtcGxhdGVVcmw7XG4gICAgICAgICAgICB0aGlzLnNsb3RDb3VudCA9IHNsb3RDb3VudDtcbiAgICAgICAgICAgIHRoaXMuZW5jYXBzdWxhdGlvbiA9IGVuY2Fwc3VsYXRpb247XG4gICAgICAgICAgICB0aGlzLnN0eWxlcyA9IHN0eWxlcztcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IGFuaW1hdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFJlbmRlckNvbXBvbmVudFR5cGU7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICB2YXIgUmVuZGVyRGVidWdJbmZvID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUmVuZGVyRGVidWdJbmZvKCkge1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZW5kZXJEZWJ1Z0luZm8ucHJvdG90eXBlLCBcImluamVjdG9yXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmltcGxlbWVudGVkKCk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVuZGVyRGVidWdJbmZvLnByb3RvdHlwZSwgXCJjb21wb25lbnRcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaW1wbGVtZW50ZWQoKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZW5kZXJEZWJ1Z0luZm8ucHJvdG90eXBlLCBcInByb3ZpZGVyVG9rZW5zXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmltcGxlbWVudGVkKCk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVuZGVyRGVidWdJbmZvLnByb3RvdHlwZSwgXCJyZWZlcmVuY2VzXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmltcGxlbWVudGVkKCk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVuZGVyRGVidWdJbmZvLnByb3RvdHlwZSwgXCJjb250ZXh0XCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmltcGxlbWVudGVkKCk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVuZGVyRGVidWdJbmZvLnByb3RvdHlwZSwgXCJzb3VyY2VcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaW1wbGVtZW50ZWQoKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBSZW5kZXJEZWJ1Z0luZm87XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBcXEBleHBlcmltZW50YWxcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICB2YXIgUmVuZGVyZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBSZW5kZXJlcigpIHtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqIEBwYXJhbSB7P30gc2VsZWN0b3JPck5vZGVcbiAgICAgICAgICogQHBhcmFtIHs/PX0gZGVidWdJbmZvXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBSZW5kZXJlci5wcm90b3R5cGUuc2VsZWN0Um9vdEVsZW1lbnQgPSBmdW5jdGlvbiAoc2VsZWN0b3JPck5vZGUsIGRlYnVnSW5mbykgeyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqIEBwYXJhbSB7P30gcGFyZW50RWxlbWVudFxuICAgICAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgICAgICogQHBhcmFtIHs/PX0gZGVidWdJbmZvXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChwYXJlbnRFbGVtZW50LCBuYW1lLCBkZWJ1Z0luZm8pIHsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBhYnN0cmFjdFxuICAgICAgICAgKiBAcGFyYW0gez99IGhvc3RFbGVtZW50XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlVmlld1Jvb3QgPSBmdW5jdGlvbiAoaG9zdEVsZW1lbnQpIHsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBhYnN0cmFjdFxuICAgICAgICAgKiBAcGFyYW0gez99IHBhcmVudEVsZW1lbnRcbiAgICAgICAgICogQHBhcmFtIHs/PX0gZGVidWdJbmZvXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlVGVtcGxhdGVBbmNob3IgPSBmdW5jdGlvbiAocGFyZW50RWxlbWVudCwgZGVidWdJbmZvKSB7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAYWJzdHJhY3RcbiAgICAgICAgICogQHBhcmFtIHs/fSBwYXJlbnRFbGVtZW50XG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHBhcmFtIHs/PX0gZGVidWdJbmZvXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlVGV4dCA9IGZ1bmN0aW9uIChwYXJlbnRFbGVtZW50LCB2YWx1ZSwgZGVidWdJbmZvKSB7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAYWJzdHJhY3RcbiAgICAgICAgICogQHBhcmFtIHs/fSBwYXJlbnRFbGVtZW50XG4gICAgICAgICAqIEBwYXJhbSB7P30gbm9kZXNcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFJlbmRlcmVyLnByb3RvdHlwZS5wcm9qZWN0Tm9kZXMgPSBmdW5jdGlvbiAocGFyZW50RWxlbWVudCwgbm9kZXMpIHsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBhYnN0cmFjdFxuICAgICAgICAgKiBAcGFyYW0gez99IG5vZGVcbiAgICAgICAgICogQHBhcmFtIHs/fSB2aWV3Um9vdE5vZGVzXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBSZW5kZXJlci5wcm90b3R5cGUuYXR0YWNoVmlld0FmdGVyID0gZnVuY3Rpb24gKG5vZGUsIHZpZXdSb290Tm9kZXMpIHsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBhYnN0cmFjdFxuICAgICAgICAgKiBAcGFyYW0gez99IHZpZXdSb290Tm9kZXNcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFJlbmRlcmVyLnByb3RvdHlwZS5kZXRhY2hWaWV3ID0gZnVuY3Rpb24gKHZpZXdSb290Tm9kZXMpIHsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBhYnN0cmFjdFxuICAgICAgICAgKiBAcGFyYW0gez99IGhvc3RFbGVtZW50XG4gICAgICAgICAqIEBwYXJhbSB7P30gdmlld0FsbE5vZGVzXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBSZW5kZXJlci5wcm90b3R5cGUuZGVzdHJveVZpZXcgPSBmdW5jdGlvbiAoaG9zdEVsZW1lbnQsIHZpZXdBbGxOb2RlcykgeyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqIEBwYXJhbSB7P30gcmVuZGVyRWxlbWVudFxuICAgICAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgICAgICogQHBhcmFtIHs/fSBjYWxsYmFja1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgUmVuZGVyZXIucHJvdG90eXBlLmxpc3RlbiA9IGZ1bmN0aW9uIChyZW5kZXJFbGVtZW50LCBuYW1lLCBjYWxsYmFjaykgeyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0XG4gICAgICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAgICAgKiBAcGFyYW0gez99IGNhbGxiYWNrXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBSZW5kZXJlci5wcm90b3R5cGUubGlzdGVuR2xvYmFsID0gZnVuY3Rpb24gKHRhcmdldCwgbmFtZSwgY2FsbGJhY2spIHsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBhYnN0cmFjdFxuICAgICAgICAgKiBAcGFyYW0gez99IHJlbmRlckVsZW1lbnRcbiAgICAgICAgICogQHBhcmFtIHs/fSBwcm9wZXJ0eU5hbWVcbiAgICAgICAgICogQHBhcmFtIHs/fSBwcm9wZXJ0eVZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBSZW5kZXJlci5wcm90b3R5cGUuc2V0RWxlbWVudFByb3BlcnR5ID0gZnVuY3Rpb24gKHJlbmRlckVsZW1lbnQsIHByb3BlcnR5TmFtZSwgcHJvcGVydHlWYWx1ZSkgeyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqIEBwYXJhbSB7P30gcmVuZGVyRWxlbWVudFxuICAgICAgICAgKiBAcGFyYW0gez99IGF0dHJpYnV0ZU5hbWVcbiAgICAgICAgICogQHBhcmFtIHs/fSBhdHRyaWJ1dGVWYWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgUmVuZGVyZXIucHJvdG90eXBlLnNldEVsZW1lbnRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAocmVuZGVyRWxlbWVudCwgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVmFsdWUpIHsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVzZWQgb25seSBpbiBkZWJ1ZyBtb2RlIHRvIHNlcmlhbGl6ZSBwcm9wZXJ0eSBjaGFuZ2VzIHRvIGRvbSBub2RlcyBhcyBhdHRyaWJ1dGVzLlxuICAgICAgICAgKiBAYWJzdHJhY3RcbiAgICAgICAgICogQHBhcmFtIHs/fSByZW5kZXJFbGVtZW50XG4gICAgICAgICAqIEBwYXJhbSB7P30gcHJvcGVydHlOYW1lXG4gICAgICAgICAqIEBwYXJhbSB7P30gcHJvcGVydHlWYWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgUmVuZGVyZXIucHJvdG90eXBlLnNldEJpbmRpbmdEZWJ1Z0luZm8gPSBmdW5jdGlvbiAocmVuZGVyRWxlbWVudCwgcHJvcGVydHlOYW1lLCBwcm9wZXJ0eVZhbHVlKSB7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAYWJzdHJhY3RcbiAgICAgICAgICogQHBhcmFtIHs/fSByZW5kZXJFbGVtZW50XG4gICAgICAgICAqIEBwYXJhbSB7P30gY2xhc3NOYW1lXG4gICAgICAgICAqIEBwYXJhbSB7P30gaXNBZGRcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFJlbmRlcmVyLnByb3RvdHlwZS5zZXRFbGVtZW50Q2xhc3MgPSBmdW5jdGlvbiAocmVuZGVyRWxlbWVudCwgY2xhc3NOYW1lLCBpc0FkZCkgeyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqIEBwYXJhbSB7P30gcmVuZGVyRWxlbWVudFxuICAgICAgICAgKiBAcGFyYW0gez99IHN0eWxlTmFtZVxuICAgICAgICAgKiBAcGFyYW0gez99IHN0eWxlVmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFJlbmRlcmVyLnByb3RvdHlwZS5zZXRFbGVtZW50U3R5bGUgPSBmdW5jdGlvbiAocmVuZGVyRWxlbWVudCwgc3R5bGVOYW1lLCBzdHlsZVZhbHVlKSB7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAYWJzdHJhY3RcbiAgICAgICAgICogQHBhcmFtIHs/fSByZW5kZXJFbGVtZW50XG4gICAgICAgICAqIEBwYXJhbSB7P30gbWV0aG9kTmFtZVxuICAgICAgICAgKiBAcGFyYW0gez89fSBhcmdzXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBSZW5kZXJlci5wcm90b3R5cGUuaW52b2tlRWxlbWVudE1ldGhvZCA9IGZ1bmN0aW9uIChyZW5kZXJFbGVtZW50LCBtZXRob2ROYW1lLCBhcmdzKSB7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAYWJzdHJhY3RcbiAgICAgICAgICogQHBhcmFtIHs/fSByZW5kZXJOb2RlXG4gICAgICAgICAqIEBwYXJhbSB7P30gdGV4dFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgUmVuZGVyZXIucHJvdG90eXBlLnNldFRleHQgPSBmdW5jdGlvbiAocmVuZGVyTm9kZSwgdGV4dCkgeyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAgICAgKiBAcGFyYW0gez99IHN0YXJ0aW5nU3R5bGVzXG4gICAgICAgICAqIEBwYXJhbSB7P30ga2V5ZnJhbWVzXG4gICAgICAgICAqIEBwYXJhbSB7P30gZHVyYXRpb25cbiAgICAgICAgICogQHBhcmFtIHs/fSBkZWxheVxuICAgICAgICAgKiBAcGFyYW0gez99IGVhc2luZ1xuICAgICAgICAgKiBAcGFyYW0gez89fSBwcmV2aW91c1BsYXllcnNcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFJlbmRlcmVyLnByb3RvdHlwZS5hbmltYXRlID0gZnVuY3Rpb24gKGVsZW1lbnQsIHN0YXJ0aW5nU3R5bGVzLCBrZXlmcmFtZXMsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nLCBwcmV2aW91c1BsYXllcnMpIHsgfTtcbiAgICAgICAgcmV0dXJuIFJlbmRlcmVyO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogSW5qZWN0YWJsZSBzZXJ2aWNlIHRoYXQgcHJvdmlkZXMgYSBsb3ctbGV2ZWwgaW50ZXJmYWNlIGZvciBtb2RpZnlpbmcgdGhlIFVJLlxuICAgICAqXG4gICAgICogVXNlIHRoaXMgc2VydmljZSB0byBieXBhc3MgQW5ndWxhcidzIHRlbXBsYXRpbmcgYW5kIG1ha2UgY3VzdG9tIFVJIGNoYW5nZXMgdGhhdCBjYW4ndCBiZVxuICAgICAqIGV4cHJlc3NlZCBkZWNsYXJhdGl2ZWx5LiBGb3IgZXhhbXBsZSBpZiB5b3UgbmVlZCB0byBzZXQgYSBwcm9wZXJ0eSBvciBhbiBhdHRyaWJ1dGUgd2hvc2UgbmFtZSBpc1xuICAgICAqIG5vdCBzdGF0aWNhbGx5IGtub3duLCB1c2Uge1xcQGxpbmsgI3NldEVsZW1lbnRQcm9wZXJ0eX0gb3Ige1xcQGxpbmsgI3NldEVsZW1lbnRBdHRyaWJ1dGV9XG4gICAgICogcmVzcGVjdGl2ZWx5LlxuICAgICAqXG4gICAgICogSWYgeW91IGFyZSBpbXBsZW1lbnRpbmcgYSBjdXN0b20gcmVuZGVyZXIsIHlvdSBtdXN0IGltcGxlbWVudCB0aGlzIGludGVyZmFjZS5cbiAgICAgKlxuICAgICAqIFRoZSBkZWZhdWx0IFJlbmRlcmVyIGltcGxlbWVudGF0aW9uIGlzIGBEb21SZW5kZXJlcmAuIEFsc28gYXZhaWxhYmxlIGlzIGBXZWJXb3JrZXJSZW5kZXJlcmAuXG4gICAgICogXFxAZXhwZXJpbWVudGFsXG4gICAgICogQGFic3RyYWN0XG4gICAgICovXG4gICAgdmFyIFJvb3RSZW5kZXJlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFJvb3RSZW5kZXJlcigpIHtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqIEBwYXJhbSB7P30gY29tcG9uZW50VHlwZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgUm9vdFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJDb21wb25lbnQgPSBmdW5jdGlvbiAoY29tcG9uZW50VHlwZSkgeyB9O1xuICAgICAgICByZXR1cm4gUm9vdFJlbmRlcmVyO1xuICAgIH0oKSk7XG5cbiAgICB2YXIgU2VjdXJpdHlDb250ZXh0ID0ge307XG4gICAgU2VjdXJpdHlDb250ZXh0Lk5PTkUgPSAwO1xuICAgIFNlY3VyaXR5Q29udGV4dC5IVE1MID0gMTtcbiAgICBTZWN1cml0eUNvbnRleHQuU1RZTEUgPSAyO1xuICAgIFNlY3VyaXR5Q29udGV4dC5TQ1JJUFQgPSAzO1xuICAgIFNlY3VyaXR5Q29udGV4dC5VUkwgPSA0O1xuICAgIFNlY3VyaXR5Q29udGV4dC5SRVNPVVJDRV9VUkwgPSA1O1xuICAgIFNlY3VyaXR5Q29udGV4dFtTZWN1cml0eUNvbnRleHQuTk9ORV0gPSBcIk5PTkVcIjtcbiAgICBTZWN1cml0eUNvbnRleHRbU2VjdXJpdHlDb250ZXh0LkhUTUxdID0gXCJIVE1MXCI7XG4gICAgU2VjdXJpdHlDb250ZXh0W1NlY3VyaXR5Q29udGV4dC5TVFlMRV0gPSBcIlNUWUxFXCI7XG4gICAgU2VjdXJpdHlDb250ZXh0W1NlY3VyaXR5Q29udGV4dC5TQ1JJUFRdID0gXCJTQ1JJUFRcIjtcbiAgICBTZWN1cml0eUNvbnRleHRbU2VjdXJpdHlDb250ZXh0LlVSTF0gPSBcIlVSTFwiO1xuICAgIFNlY3VyaXR5Q29udGV4dFtTZWN1cml0eUNvbnRleHQuUkVTT1VSQ0VfVVJMXSA9IFwiUkVTT1VSQ0VfVVJMXCI7XG4gICAgLyoqXG4gICAgICogU2FuaXRpemVyIGlzIHVzZWQgYnkgdGhlIHZpZXdzIHRvIHNhbml0aXplIHBvdGVudGlhbGx5IGRhbmdlcm91cyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBcXEBzdGFibGVcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICB2YXIgU2FuaXRpemVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gU2FuaXRpemVyKCkge1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAYWJzdHJhY3RcbiAgICAgICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFNhbml0aXplci5wcm90b3R5cGUuc2FuaXRpemUgPSBmdW5jdGlvbiAoY29udGV4dCwgdmFsdWUpIHsgfTtcbiAgICAgICAgcmV0dXJuIFNhbml0aXplcjtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkNyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFuIGVycm9yIHRocm93biBpZiBhcHBsaWNhdGlvbiBjaGFuZ2VzIG1vZGVsIGJyZWFraW5nIHRoZSB0b3AtZG93biBkYXRhIGZsb3cuXG4gICAgICpcbiAgICAgKiBUaGlzIGV4Y2VwdGlvbiBpcyBvbmx5IHRocm93biBpbiBkZXYgbW9kZS5cbiAgICAgKlxuICAgICAqIDwhLS0gVE9ETzogQWRkIGEgbGluayBvbmNlIHRoZSBkZXYgbW9kZSBvcHRpb24gaXMgY29uZmlndXJhYmxlIC0tPlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBcXEBDb21wb25lbnQoe1xuICAgICAqICAgc2VsZWN0b3I6ICdwYXJlbnQnLFxuICAgICAqICAgdGVtcGxhdGU6ICc8Y2hpbGQgW3Byb3BdPVwicGFyZW50UHJvcFwiPjwvY2hpbGQ+JyxcbiAgICAgKiB9KVxuICAgICAqIGNsYXNzIFBhcmVudCB7XG4gICAgICogICBwYXJlbnRQcm9wID0gJ2luaXQnO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIFxcQERpcmVjdGl2ZSh7c2VsZWN0b3I6ICdjaGlsZCcsIGlucHV0czogWydwcm9wJ119KVxuICAgICAqIGNsYXNzIENoaWxkIHtcbiAgICAgKiAgIGNvbnN0cnVjdG9yKHB1YmxpYyBwYXJlbnQ6IFBhcmVudCkge31cbiAgICAgKlxuICAgICAqICAgc2V0IHByb3Aodikge1xuICAgICAqICAgICAvLyB0aGlzIHVwZGF0ZXMgdGhlIHBhcmVudCBwcm9wZXJ0eSwgd2hpY2ggaXMgZGlzYWxsb3dlZCBkdXJpbmcgY2hhbmdlIGRldGVjdGlvblxuICAgICAqICAgICAvLyB0aGlzIHdpbGwgcmVzdWx0IGluIEV4cHJlc3Npb25DaGFuZ2VkQWZ0ZXJJdEhhc0JlZW5DaGVja2VkRXJyb3JcbiAgICAgKiAgICAgdGhpcy5wYXJlbnQucGFyZW50UHJvcCA9ICd1cGRhdGVkJztcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICogXFxAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEV4cHJlc3Npb25DaGFuZ2VkQWZ0ZXJJdEhhc0JlZW5DaGVja2VkRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkNyhFeHByZXNzaW9uQ2hhbmdlZEFmdGVySXRIYXNCZWVuQ2hlY2tlZEVycm9yLCBfc3VwZXIpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBvbGRWYWx1ZVxuICAgICAgICAgKiBAcGFyYW0gez99IGN1cnJWYWx1ZVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gRXhwcmVzc2lvbkNoYW5nZWRBZnRlckl0SGFzQmVlbkNoZWNrZWRFcnJvcihvbGRWYWx1ZSwgY3VyclZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgbXNnID0gXCJFeHByZXNzaW9uIGhhcyBjaGFuZ2VkIGFmdGVyIGl0IHdhcyBjaGVja2VkLiBQcmV2aW91cyB2YWx1ZTogJ1wiICsgb2xkVmFsdWUgKyBcIicuIEN1cnJlbnQgdmFsdWU6ICdcIiArIGN1cnJWYWx1ZSArIFwiJy5cIjtcbiAgICAgICAgICAgIGlmIChvbGRWYWx1ZSA9PT0gVU5JTklUSUFMSVpFRCkge1xuICAgICAgICAgICAgICAgIG1zZyArPVxuICAgICAgICAgICAgICAgICAgICBcIiBJdCBzZWVtcyBsaWtlIHRoZSB2aWV3IGhhcyBiZWVuIGNyZWF0ZWQgYWZ0ZXIgaXRzIHBhcmVudCBhbmQgaXRzIGNoaWxkcmVuIGhhdmUgYmVlbiBkaXJ0eSBjaGVja2VkLlwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiIEhhcyBpdCBiZWVuIGNyZWF0ZWQgaW4gYSBjaGFuZ2UgZGV0ZWN0aW9uIGhvb2sgP1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgbXNnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRXhwcmVzc2lvbkNoYW5nZWRBZnRlckl0SGFzQmVlbkNoZWNrZWRFcnJvcjtcbiAgICB9KEJhc2VFcnJvcikpO1xuICAgIC8qKlxuICAgICAqIFRocm93biB3aGVuIGFuIGV4Y2VwdGlvbiB3YXMgcmFpc2VkIGR1cmluZyB2aWV3IGNyZWF0aW9uLCBjaGFuZ2UgZGV0ZWN0aW9uIG9yIGRlc3RydWN0aW9uLlxuICAgICAqXG4gICAgICogVGhpcyBlcnJvciB3cmFwcyB0aGUgb3JpZ2luYWwgZXhjZXB0aW9uIHRvIGF0dGFjaCBhZGRpdGlvbmFsIGNvbnRleHR1YWwgaW5mb3JtYXRpb24gdGhhdCBjYW5cbiAgICAgKiBiZSB1c2VmdWwgZm9yIGRlYnVnZ2luZy5cbiAgICAgKiBcXEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgVmlld1dyYXBwZWRFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQ3KFZpZXdXcmFwcGVkRXJyb3IsIF9zdXBlcik7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IG9yaWdpbmFsRXJyb3JcbiAgICAgICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBWaWV3V3JhcHBlZEVycm9yKG9yaWdpbmFsRXJyb3IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIFwiRXJyb3IgaW4gXCIgKyBjb250ZXh0LnNvdXJjZSwgb3JpZ2luYWxFcnJvcik7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBWaWV3V3JhcHBlZEVycm9yO1xuICAgIH0oV3JhcHBlZEVycm9yKSk7XG4gICAgLyoqXG4gICAgICogVGhyb3duIHdoZW4gYSBkZXN0cm95ZWQgdmlldyBpcyB1c2VkLlxuICAgICAqXG4gICAgICogVGhpcyBlcnJvciBpbmRpY2F0ZXMgYSBidWcgaW4gdGhlIGZyYW1ld29yay5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgYW4gaW50ZXJuYWwgQW5ndWxhciBlcnJvci5cbiAgICAgKiBcXEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgVmlld0Rlc3Ryb3llZEVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDcoVmlld0Rlc3Ryb3llZEVycm9yLCBfc3VwZXIpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBkZXRhaWxzXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBWaWV3RGVzdHJveWVkRXJyb3IoZGV0YWlscykge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgXCJBdHRlbXB0IHRvIHVzZSBhIGRlc3Ryb3llZCB2aWV3OiBcIiArIGRldGFpbHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBWaWV3RGVzdHJveWVkRXJyb3I7XG4gICAgfShCYXNlRXJyb3IpKTtcblxuICAgIHZhciBWaWV3VXRpbHMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBfcmVuZGVyZXJcbiAgICAgICAgICogQHBhcmFtIHs/fSBzYW5pdGl6ZXJcbiAgICAgICAgICogQHBhcmFtIHs/fSBhbmltYXRpb25RdWV1ZVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gVmlld1V0aWxzKF9yZW5kZXJlciwgc2FuaXRpemVyLCBhbmltYXRpb25RdWV1ZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvblF1ZXVlID0gYW5pbWF0aW9uUXVldWU7XG4gICAgICAgICAgICB0aGlzLnNhbml0aXplciA9IHNhbml0aXplcjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogXFxAaW50ZXJuYWxcbiAgICAgICAgICogQHBhcmFtIHs/fSByZW5kZXJDb21wb25lbnRUeXBlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBWaWV3VXRpbHMucHJvdG90eXBlLnJlbmRlckNvbXBvbmVudCA9IGZ1bmN0aW9uIChyZW5kZXJDb21wb25lbnRUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyZXIucmVuZGVyQ29tcG9uZW50KHJlbmRlckNvbXBvbmVudFR5cGUpO1xuICAgICAgICB9O1xuICAgICAgICBWaWV3VXRpbHMuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgVmlld1V0aWxzLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICAgICAgeyB0eXBlOiBSb290UmVuZGVyZXIsIH0sXG4gICAgICAgICAgICB7IHR5cGU6IFNhbml0aXplciwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogQW5pbWF0aW9uUXVldWUsIH0sXG4gICAgICAgIF07IH07XG4gICAgICAgIHJldHVybiBWaWV3VXRpbHM7XG4gICAgfSgpKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZXh0UmVuZGVyQ29tcG9uZW50VHlwZUlkID0gMDtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRlbXBsYXRlVXJsXG4gICAgICogQHBhcmFtIHs/fSBzbG90Q291bnRcbiAgICAgKiBAcGFyYW0gez99IGVuY2Fwc3VsYXRpb25cbiAgICAgKiBAcGFyYW0gez99IHN0eWxlc1xuICAgICAqIEBwYXJhbSB7P30gYW5pbWF0aW9uc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUmVuZGVyQ29tcG9uZW50VHlwZSh0ZW1wbGF0ZVVybCwgc2xvdENvdW50LCBlbmNhcHN1bGF0aW9uLCBzdHlsZXMsIGFuaW1hdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZW5kZXJDb21wb25lbnRUeXBlKFwiXCIgKyBuZXh0UmVuZGVyQ29tcG9uZW50VHlwZUlkKyssIHRlbXBsYXRlVXJsLCBzbG90Q291bnQsIGVuY2Fwc3VsYXRpb24sIHN0eWxlcywgYW5pbWF0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZVxuICAgICAqIEBwYXJhbSB7P30gYXJyYXlcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFkZFRvQXJyYXkoZSwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXkucHVzaChlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZUNvdW50XG4gICAgICogQHBhcmFtIHs/fSBjb25zdEFuZEludGVycFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gaW50ZXJwb2xhdGUodmFsdWVDb3VudCwgY29uc3RBbmRJbnRlcnApIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0gJyc7XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCB2YWx1ZUNvdW50ICogMjsgaSA9IGkgKyAyKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQgKyBjb25zdEFuZEludGVycFtpXSArIF90b1N0cmluZ1dpdGhOdWxsKGNvbnN0QW5kSW50ZXJwW2kgKyAxXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdCArIGNvbnN0QW5kSW50ZXJwW3ZhbHVlQ291bnQgKiAyXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZUNvdW50XG4gICAgICogQHBhcmFtIHs/fSBjMFxuICAgICAqIEBwYXJhbSB7P30gYTFcbiAgICAgKiBAcGFyYW0gez99IGMxXG4gICAgICogQHBhcmFtIHs/PX0gYTJcbiAgICAgKiBAcGFyYW0gez89fSBjMlxuICAgICAqIEBwYXJhbSB7Pz19IGEzXG4gICAgICogQHBhcmFtIHs/PX0gYzNcbiAgICAgKiBAcGFyYW0gez89fSBhNFxuICAgICAqIEBwYXJhbSB7Pz19IGM0XG4gICAgICogQHBhcmFtIHs/PX0gYTVcbiAgICAgKiBAcGFyYW0gez89fSBjNVxuICAgICAqIEBwYXJhbSB7Pz19IGE2XG4gICAgICogQHBhcmFtIHs/PX0gYzZcbiAgICAgKiBAcGFyYW0gez89fSBhN1xuICAgICAqIEBwYXJhbSB7Pz19IGM3XG4gICAgICogQHBhcmFtIHs/PX0gYThcbiAgICAgKiBAcGFyYW0gez89fSBjOFxuICAgICAqIEBwYXJhbSB7Pz19IGE5XG4gICAgICogQHBhcmFtIHs/PX0gYzlcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlubGluZUludGVycG9sYXRlKHZhbHVlQ291bnQsIGMwLCBhMSwgYzEsIGEyLCBjMiwgYTMsIGMzLCBhNCwgYzQsIGE1LCBjNSwgYTYsIGM2LCBhNywgYzcsIGE4LCBjOCwgYTksIGM5KSB7XG4gICAgICAgIHN3aXRjaCAodmFsdWVDb3VudCkge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJldHVybiBjMCArIF90b1N0cmluZ1dpdGhOdWxsKGExKSArIGMxO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiBjMCArIF90b1N0cmluZ1dpdGhOdWxsKGExKSArIGMxICsgX3RvU3RyaW5nV2l0aE51bGwoYTIpICsgYzI7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGMwICsgX3RvU3RyaW5nV2l0aE51bGwoYTEpICsgYzEgKyBfdG9TdHJpbmdXaXRoTnVsbChhMikgKyBjMiArIF90b1N0cmluZ1dpdGhOdWxsKGEzKSArXG4gICAgICAgICAgICAgICAgICAgIGMzO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIHJldHVybiBjMCArIF90b1N0cmluZ1dpdGhOdWxsKGExKSArIGMxICsgX3RvU3RyaW5nV2l0aE51bGwoYTIpICsgYzIgKyBfdG9TdHJpbmdXaXRoTnVsbChhMykgK1xuICAgICAgICAgICAgICAgICAgICBjMyArIF90b1N0cmluZ1dpdGhOdWxsKGE0KSArIGM0O1xuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIHJldHVybiBjMCArIF90b1N0cmluZ1dpdGhOdWxsKGExKSArIGMxICsgX3RvU3RyaW5nV2l0aE51bGwoYTIpICsgYzIgKyBfdG9TdHJpbmdXaXRoTnVsbChhMykgK1xuICAgICAgICAgICAgICAgICAgICBjMyArIF90b1N0cmluZ1dpdGhOdWxsKGE0KSArIGM0ICsgX3RvU3RyaW5nV2l0aE51bGwoYTUpICsgYzU7XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGMwICsgX3RvU3RyaW5nV2l0aE51bGwoYTEpICsgYzEgKyBfdG9TdHJpbmdXaXRoTnVsbChhMikgKyBjMiArIF90b1N0cmluZ1dpdGhOdWxsKGEzKSArXG4gICAgICAgICAgICAgICAgICAgIGMzICsgX3RvU3RyaW5nV2l0aE51bGwoYTQpICsgYzQgKyBfdG9TdHJpbmdXaXRoTnVsbChhNSkgKyBjNSArIF90b1N0cmluZ1dpdGhOdWxsKGE2KSArIGM2O1xuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgIHJldHVybiBjMCArIF90b1N0cmluZ1dpdGhOdWxsKGExKSArIGMxICsgX3RvU3RyaW5nV2l0aE51bGwoYTIpICsgYzIgKyBfdG9TdHJpbmdXaXRoTnVsbChhMykgK1xuICAgICAgICAgICAgICAgICAgICBjMyArIF90b1N0cmluZ1dpdGhOdWxsKGE0KSArIGM0ICsgX3RvU3RyaW5nV2l0aE51bGwoYTUpICsgYzUgKyBfdG9TdHJpbmdXaXRoTnVsbChhNikgK1xuICAgICAgICAgICAgICAgICAgICBjNiArIF90b1N0cmluZ1dpdGhOdWxsKGE3KSArIGM3O1xuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgIHJldHVybiBjMCArIF90b1N0cmluZ1dpdGhOdWxsKGExKSArIGMxICsgX3RvU3RyaW5nV2l0aE51bGwoYTIpICsgYzIgKyBfdG9TdHJpbmdXaXRoTnVsbChhMykgK1xuICAgICAgICAgICAgICAgICAgICBjMyArIF90b1N0cmluZ1dpdGhOdWxsKGE0KSArIGM0ICsgX3RvU3RyaW5nV2l0aE51bGwoYTUpICsgYzUgKyBfdG9TdHJpbmdXaXRoTnVsbChhNikgK1xuICAgICAgICAgICAgICAgICAgICBjNiArIF90b1N0cmluZ1dpdGhOdWxsKGE3KSArIGM3ICsgX3RvU3RyaW5nV2l0aE51bGwoYTgpICsgYzg7XG4gICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGMwICsgX3RvU3RyaW5nV2l0aE51bGwoYTEpICsgYzEgKyBfdG9TdHJpbmdXaXRoTnVsbChhMikgKyBjMiArIF90b1N0cmluZ1dpdGhOdWxsKGEzKSArXG4gICAgICAgICAgICAgICAgICAgIGMzICsgX3RvU3RyaW5nV2l0aE51bGwoYTQpICsgYzQgKyBfdG9TdHJpbmdXaXRoTnVsbChhNSkgKyBjNSArIF90b1N0cmluZ1dpdGhOdWxsKGE2KSArXG4gICAgICAgICAgICAgICAgICAgIGM2ICsgX3RvU3RyaW5nV2l0aE51bGwoYTcpICsgYzcgKyBfdG9TdHJpbmdXaXRoTnVsbChhOCkgKyBjOCArIF90b1N0cmluZ1dpdGhOdWxsKGE5KSArIGM5O1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEb2VzIG5vdCBzdXBwb3J0IG1vcmUgdGhhbiA5IGV4cHJlc3Npb25zXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gX3RvU3RyaW5nV2l0aE51bGwodikge1xuICAgICAgICByZXR1cm4gdiAhPSBudWxsID8gdi50b1N0cmluZygpIDogJyc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGhyb3dPbkNoYW5nZVxuICAgICAqIEBwYXJhbSB7P30gb2xkVmFsdWVcbiAgICAgKiBAcGFyYW0gez99IG5ld1ZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaGVja0JpbmRpbmcodGhyb3dPbkNoYW5nZSwgb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgICAgIGlmICh0aHJvd09uQ2hhbmdlKSB7XG4gICAgICAgICAgICBpZiAoIWRldk1vZGVFcXVhbChvbGRWYWx1ZSwgbmV3VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV4cHJlc3Npb25DaGFuZ2VkQWZ0ZXJJdEhhc0JlZW5DaGVja2VkRXJyb3Iob2xkVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAhbG9vc2VJZGVudGljYWwob2xkVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGlucHV0XG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FzdEJ5VmFsdWUoaW5wdXQsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAoaW5wdXQpO1xuICAgIH1cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBFTVBUWV9BUlJBWSA9IFtdO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIEVNUFRZX01BUCA9IHt9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHB1cmVQcm94eTEoZm4pIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2MCA9IFVOSU5JVElBTElaRUQ7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocDApIHtcbiAgICAgICAgICAgIGlmICghbG9vc2VJZGVudGljYWwodjAsIHAwKSkge1xuICAgICAgICAgICAgICAgIHYwID0gcDA7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZm4ocDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBmblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gcHVyZVByb3h5Mihmbikge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQ7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHYwID0gVU5JTklUSUFMSVpFRDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdjEgPSBVTklOSVRJQUxJWkVEO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHAwLCBwMSkge1xuICAgICAgICAgICAgaWYgKCFsb29zZUlkZW50aWNhbCh2MCwgcDApIHx8ICFsb29zZUlkZW50aWNhbCh2MSwgcDEpKSB7XG4gICAgICAgICAgICAgICAgdjAgPSBwMDtcbiAgICAgICAgICAgICAgICB2MSA9IHAxO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZuKHAwLCBwMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwdXJlUHJveHkzKGZuKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdjAgPSBVTklOSVRJQUxJWkVEO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2MSA9IFVOSU5JVElBTElaRUQ7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHYyID0gVU5JTklUSUFMSVpFRDtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwMCwgcDEsIHAyKSB7XG4gICAgICAgICAgICBpZiAoIWxvb3NlSWRlbnRpY2FsKHYwLCBwMCkgfHwgIWxvb3NlSWRlbnRpY2FsKHYxLCBwMSkgfHwgIWxvb3NlSWRlbnRpY2FsKHYyLCBwMikpIHtcbiAgICAgICAgICAgICAgICB2MCA9IHAwO1xuICAgICAgICAgICAgICAgIHYxID0gcDE7XG4gICAgICAgICAgICAgICAgdjIgPSBwMjtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmbihwMCwgcDEsIHAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHB1cmVQcm94eTQoZm4pIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2MCwgLyoqIEB0eXBlIHs/fSAqLyB2MSwgLyoqIEB0eXBlIHs/fSAqLyB2MiwgLyoqIEB0eXBlIHs/fSAqLyB2MztcbiAgICAgICAgdjAgPSB2MSA9IHYyID0gdjMgPSBVTklOSVRJQUxJWkVEO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHAwLCBwMSwgcDIsIHAzKSB7XG4gICAgICAgICAgICBpZiAoIWxvb3NlSWRlbnRpY2FsKHYwLCBwMCkgfHwgIWxvb3NlSWRlbnRpY2FsKHYxLCBwMSkgfHwgIWxvb3NlSWRlbnRpY2FsKHYyLCBwMikgfHxcbiAgICAgICAgICAgICAgICAhbG9vc2VJZGVudGljYWwodjMsIHAzKSkge1xuICAgICAgICAgICAgICAgIHYwID0gcDA7XG4gICAgICAgICAgICAgICAgdjEgPSBwMTtcbiAgICAgICAgICAgICAgICB2MiA9IHAyO1xuICAgICAgICAgICAgICAgIHYzID0gcDM7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZm4ocDAsIHAxLCBwMiwgcDMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBmblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gcHVyZVByb3h5NShmbikge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQ7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHYwLCAvKiogQHR5cGUgez99ICovIHYxLCAvKiogQHR5cGUgez99ICovIHYyLCAvKiogQHR5cGUgez99ICovIHYzLCAvKiogQHR5cGUgez99ICovIHY0O1xuICAgICAgICB2MCA9IHYxID0gdjIgPSB2MyA9IHY0ID0gVU5JTklUSUFMSVpFRDtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwMCwgcDEsIHAyLCBwMywgcDQpIHtcbiAgICAgICAgICAgIGlmICghbG9vc2VJZGVudGljYWwodjAsIHAwKSB8fCAhbG9vc2VJZGVudGljYWwodjEsIHAxKSB8fCAhbG9vc2VJZGVudGljYWwodjIsIHAyKSB8fFxuICAgICAgICAgICAgICAgICFsb29zZUlkZW50aWNhbCh2MywgcDMpIHx8ICFsb29zZUlkZW50aWNhbCh2NCwgcDQpKSB7XG4gICAgICAgICAgICAgICAgdjAgPSBwMDtcbiAgICAgICAgICAgICAgICB2MSA9IHAxO1xuICAgICAgICAgICAgICAgIHYyID0gcDI7XG4gICAgICAgICAgICAgICAgdjMgPSBwMztcbiAgICAgICAgICAgICAgICB2NCA9IHA0O1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZuKHAwLCBwMSwgcDIsIHAzLCBwNCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwdXJlUHJveHk2KGZuKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdjAsIC8qKiBAdHlwZSB7P30gKi8gdjEsIC8qKiBAdHlwZSB7P30gKi8gdjIsIC8qKiBAdHlwZSB7P30gKi8gdjMsIC8qKiBAdHlwZSB7P30gKi8gdjQsIC8qKiBAdHlwZSB7P30gKi8gdjU7XG4gICAgICAgIHYwID0gdjEgPSB2MiA9IHYzID0gdjQgPSB2NSA9IFVOSU5JVElBTElaRUQ7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocDAsIHAxLCBwMiwgcDMsIHA0LCBwNSkge1xuICAgICAgICAgICAgaWYgKCFsb29zZUlkZW50aWNhbCh2MCwgcDApIHx8ICFsb29zZUlkZW50aWNhbCh2MSwgcDEpIHx8ICFsb29zZUlkZW50aWNhbCh2MiwgcDIpIHx8XG4gICAgICAgICAgICAgICAgIWxvb3NlSWRlbnRpY2FsKHYzLCBwMykgfHwgIWxvb3NlSWRlbnRpY2FsKHY0LCBwNCkgfHwgIWxvb3NlSWRlbnRpY2FsKHY1LCBwNSkpIHtcbiAgICAgICAgICAgICAgICB2MCA9IHAwO1xuICAgICAgICAgICAgICAgIHYxID0gcDE7XG4gICAgICAgICAgICAgICAgdjIgPSBwMjtcbiAgICAgICAgICAgICAgICB2MyA9IHAzO1xuICAgICAgICAgICAgICAgIHY0ID0gcDQ7XG4gICAgICAgICAgICAgICAgdjUgPSBwNTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmbihwMCwgcDEsIHAyLCBwMywgcDQsIHA1KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHB1cmVQcm94eTcoZm4pIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2MCwgLyoqIEB0eXBlIHs/fSAqLyB2MSwgLyoqIEB0eXBlIHs/fSAqLyB2MiwgLyoqIEB0eXBlIHs/fSAqLyB2MywgLyoqIEB0eXBlIHs/fSAqLyB2NCwgLyoqIEB0eXBlIHs/fSAqLyB2NSwgLyoqIEB0eXBlIHs/fSAqLyB2NjtcbiAgICAgICAgdjAgPSB2MSA9IHYyID0gdjMgPSB2NCA9IHY1ID0gdjYgPSBVTklOSVRJQUxJWkVEO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHAwLCBwMSwgcDIsIHAzLCBwNCwgcDUsIHA2KSB7XG4gICAgICAgICAgICBpZiAoIWxvb3NlSWRlbnRpY2FsKHYwLCBwMCkgfHwgIWxvb3NlSWRlbnRpY2FsKHYxLCBwMSkgfHwgIWxvb3NlSWRlbnRpY2FsKHYyLCBwMikgfHxcbiAgICAgICAgICAgICAgICAhbG9vc2VJZGVudGljYWwodjMsIHAzKSB8fCAhbG9vc2VJZGVudGljYWwodjQsIHA0KSB8fCAhbG9vc2VJZGVudGljYWwodjUsIHA1KSB8fFxuICAgICAgICAgICAgICAgICFsb29zZUlkZW50aWNhbCh2NiwgcDYpKSB7XG4gICAgICAgICAgICAgICAgdjAgPSBwMDtcbiAgICAgICAgICAgICAgICB2MSA9IHAxO1xuICAgICAgICAgICAgICAgIHYyID0gcDI7XG4gICAgICAgICAgICAgICAgdjMgPSBwMztcbiAgICAgICAgICAgICAgICB2NCA9IHA0O1xuICAgICAgICAgICAgICAgIHY1ID0gcDU7XG4gICAgICAgICAgICAgICAgdjYgPSBwNjtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmbihwMCwgcDEsIHAyLCBwMywgcDQsIHA1LCBwNik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwdXJlUHJveHk4KGZuKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdjAsIC8qKiBAdHlwZSB7P30gKi8gdjEsIC8qKiBAdHlwZSB7P30gKi8gdjIsIC8qKiBAdHlwZSB7P30gKi8gdjMsIC8qKiBAdHlwZSB7P30gKi8gdjQsIC8qKiBAdHlwZSB7P30gKi8gdjUsIC8qKiBAdHlwZSB7P30gKi8gdjYsIC8qKiBAdHlwZSB7P30gKi8gdjc7XG4gICAgICAgIHYwID0gdjEgPSB2MiA9IHYzID0gdjQgPSB2NSA9IHY2ID0gdjcgPSBVTklOSVRJQUxJWkVEO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHAwLCBwMSwgcDIsIHAzLCBwNCwgcDUsIHA2LCBwNykge1xuICAgICAgICAgICAgaWYgKCFsb29zZUlkZW50aWNhbCh2MCwgcDApIHx8ICFsb29zZUlkZW50aWNhbCh2MSwgcDEpIHx8ICFsb29zZUlkZW50aWNhbCh2MiwgcDIpIHx8XG4gICAgICAgICAgICAgICAgIWxvb3NlSWRlbnRpY2FsKHYzLCBwMykgfHwgIWxvb3NlSWRlbnRpY2FsKHY0LCBwNCkgfHwgIWxvb3NlSWRlbnRpY2FsKHY1LCBwNSkgfHxcbiAgICAgICAgICAgICAgICAhbG9vc2VJZGVudGljYWwodjYsIHA2KSB8fCAhbG9vc2VJZGVudGljYWwodjcsIHA3KSkge1xuICAgICAgICAgICAgICAgIHYwID0gcDA7XG4gICAgICAgICAgICAgICAgdjEgPSBwMTtcbiAgICAgICAgICAgICAgICB2MiA9IHAyO1xuICAgICAgICAgICAgICAgIHYzID0gcDM7XG4gICAgICAgICAgICAgICAgdjQgPSBwNDtcbiAgICAgICAgICAgICAgICB2NSA9IHA1O1xuICAgICAgICAgICAgICAgIHY2ID0gcDY7XG4gICAgICAgICAgICAgICAgdjcgPSBwNztcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmbihwMCwgcDEsIHAyLCBwMywgcDQsIHA1LCBwNiwgcDcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBmblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gcHVyZVByb3h5OShmbikge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQ7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHYwLCAvKiogQHR5cGUgez99ICovIHYxLCAvKiogQHR5cGUgez99ICovIHYyLCAvKiogQHR5cGUgez99ICovIHYzLCAvKiogQHR5cGUgez99ICovIHY0LCAvKiogQHR5cGUgez99ICovIHY1LCAvKiogQHR5cGUgez99ICovIHY2LCAvKiogQHR5cGUgez99ICovIHY3LCAvKiogQHR5cGUgez99ICovIHY4O1xuICAgICAgICB2MCA9IHYxID0gdjIgPSB2MyA9IHY0ID0gdjUgPSB2NiA9IHY3ID0gdjggPSBVTklOSVRJQUxJWkVEO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHAwLCBwMSwgcDIsIHAzLCBwNCwgcDUsIHA2LCBwNywgcDgpIHtcbiAgICAgICAgICAgIGlmICghbG9vc2VJZGVudGljYWwodjAsIHAwKSB8fCAhbG9vc2VJZGVudGljYWwodjEsIHAxKSB8fCAhbG9vc2VJZGVudGljYWwodjIsIHAyKSB8fFxuICAgICAgICAgICAgICAgICFsb29zZUlkZW50aWNhbCh2MywgcDMpIHx8ICFsb29zZUlkZW50aWNhbCh2NCwgcDQpIHx8ICFsb29zZUlkZW50aWNhbCh2NSwgcDUpIHx8XG4gICAgICAgICAgICAgICAgIWxvb3NlSWRlbnRpY2FsKHY2LCBwNikgfHwgIWxvb3NlSWRlbnRpY2FsKHY3LCBwNykgfHwgIWxvb3NlSWRlbnRpY2FsKHY4LCBwOCkpIHtcbiAgICAgICAgICAgICAgICB2MCA9IHAwO1xuICAgICAgICAgICAgICAgIHYxID0gcDE7XG4gICAgICAgICAgICAgICAgdjIgPSBwMjtcbiAgICAgICAgICAgICAgICB2MyA9IHAzO1xuICAgICAgICAgICAgICAgIHY0ID0gcDQ7XG4gICAgICAgICAgICAgICAgdjUgPSBwNTtcbiAgICAgICAgICAgICAgICB2NiA9IHA2O1xuICAgICAgICAgICAgICAgIHY3ID0gcDc7XG4gICAgICAgICAgICAgICAgdjggPSBwODtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmbihwMCwgcDEsIHAyLCBwMywgcDQsIHA1LCBwNiwgcDcsIHA4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHB1cmVQcm94eTEwKGZuKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdjAsIC8qKiBAdHlwZSB7P30gKi8gdjEsIC8qKiBAdHlwZSB7P30gKi8gdjIsIC8qKiBAdHlwZSB7P30gKi8gdjMsIC8qKiBAdHlwZSB7P30gKi8gdjQsIC8qKiBAdHlwZSB7P30gKi8gdjUsIC8qKiBAdHlwZSB7P30gKi8gdjYsIC8qKiBAdHlwZSB7P30gKi8gdjcsIC8qKiBAdHlwZSB7P30gKi8gdjgsIC8qKiBAdHlwZSB7P30gKi8gdjk7XG4gICAgICAgIHYwID0gdjEgPSB2MiA9IHYzID0gdjQgPSB2NSA9IHY2ID0gdjcgPSB2OCA9IHY5ID0gVU5JTklUSUFMSVpFRDtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwMCwgcDEsIHAyLCBwMywgcDQsIHA1LCBwNiwgcDcsIHA4LCBwOSkge1xuICAgICAgICAgICAgaWYgKCFsb29zZUlkZW50aWNhbCh2MCwgcDApIHx8ICFsb29zZUlkZW50aWNhbCh2MSwgcDEpIHx8ICFsb29zZUlkZW50aWNhbCh2MiwgcDIpIHx8XG4gICAgICAgICAgICAgICAgIWxvb3NlSWRlbnRpY2FsKHYzLCBwMykgfHwgIWxvb3NlSWRlbnRpY2FsKHY0LCBwNCkgfHwgIWxvb3NlSWRlbnRpY2FsKHY1LCBwNSkgfHxcbiAgICAgICAgICAgICAgICAhbG9vc2VJZGVudGljYWwodjYsIHA2KSB8fCAhbG9vc2VJZGVudGljYWwodjcsIHA3KSB8fCAhbG9vc2VJZGVudGljYWwodjgsIHA4KSB8fFxuICAgICAgICAgICAgICAgICFsb29zZUlkZW50aWNhbCh2OSwgcDkpKSB7XG4gICAgICAgICAgICAgICAgdjAgPSBwMDtcbiAgICAgICAgICAgICAgICB2MSA9IHAxO1xuICAgICAgICAgICAgICAgIHYyID0gcDI7XG4gICAgICAgICAgICAgICAgdjMgPSBwMztcbiAgICAgICAgICAgICAgICB2NCA9IHA0O1xuICAgICAgICAgICAgICAgIHY1ID0gcDU7XG4gICAgICAgICAgICAgICAgdjYgPSBwNjtcbiAgICAgICAgICAgICAgICB2NyA9IHA3O1xuICAgICAgICAgICAgICAgIHY4ID0gcDg7XG4gICAgICAgICAgICAgICAgdjkgPSBwOTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmbihwMCwgcDEsIHAyLCBwMywgcDQsIHA1LCBwNiwgcDcsIHA4LCBwOSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJlbmRlcmVyXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEBwYXJhbSB7P30gY2hhbmdlc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0QmluZGluZ0RlYnVnSW5mb0ZvckNoYW5nZXMocmVuZGVyZXIsIGVsLCBjaGFuZ2VzKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKGNoYW5nZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gICAgICAgICAgICBzZXRCaW5kaW5nRGVidWdJbmZvKHJlbmRlcmVyLCBlbCwgcHJvcE5hbWUsIGNoYW5nZXNbcHJvcE5hbWVdLmN1cnJlbnRWYWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJlbmRlcmVyXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEBwYXJhbSB7P30gcHJvcE5hbWVcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRCaW5kaW5nRGVidWdJbmZvKHJlbmRlcmVyLCBlbCwgcHJvcE5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZW5kZXJlci5zZXRCaW5kaW5nRGVidWdJbmZvKGVsLCBcIm5nLXJlZmxlY3QtXCIgKyBjYW1lbENhc2VUb0Rhc2hDYXNlKHByb3BOYW1lKSwgdmFsdWUgPyB2YWx1ZS50b1N0cmluZygpIDogbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJlbmRlcmVyLnNldEJpbmRpbmdEZWJ1Z0luZm8oZWwsIFwibmctcmVmbGVjdC1cIiArIGNhbWVsQ2FzZVRvRGFzaENhc2UocHJvcE5hbWUpLCAnW0VSUk9SXSBFeGNlcHRpb24gd2hpbGUgdHJ5aW5nIHRvIHNlcmlhbGl6ZSB0aGUgdmFsdWUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBDQU1FTF9DQVNFX1JFR0VYUCA9IC8oW0EtWl0pL2c7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpbnB1dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FtZWxDYXNlVG9EYXNoQ2FzZShpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQucmVwbGFjZShDQU1FTF9DQVNFX1JFR0VYUCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG0gPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgbVtfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAnLScgKyBtWzFdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJlbmRlcmVyXG4gICAgICogQHBhcmFtIHs/fSBwYXJlbnRFbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBhdHRyc1xuICAgICAqIEBwYXJhbSB7Pz19IGRlYnVnSW5mb1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUmVuZGVyRWxlbWVudChyZW5kZXJlciwgcGFyZW50RWxlbWVudCwgbmFtZSwgYXR0cnMsIGRlYnVnSW5mbykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbCA9IHJlbmRlcmVyLmNyZWF0ZUVsZW1lbnQocGFyZW50RWxlbWVudCwgbmFtZSwgZGVidWdJbmZvKTtcbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IGF0dHJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICByZW5kZXJlci5zZXRFbGVtZW50QXR0cmlidXRlKGVsLCBhdHRycy5nZXQoaSksIGF0dHJzLmdldChpICsgMSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByZW5kZXJlclxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudE5hbWVcbiAgICAgKiBAcGFyYW0gez99IGF0dHJzXG4gICAgICogQHBhcmFtIHs/fSByb290U2VsZWN0b3JPck5vZGVcbiAgICAgKiBAcGFyYW0gez89fSBkZWJ1Z0luZm9cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNlbGVjdE9yQ3JlYXRlUmVuZGVySG9zdEVsZW1lbnQocmVuZGVyZXIsIGVsZW1lbnROYW1lLCBhdHRycywgcm9vdFNlbGVjdG9yT3JOb2RlLCBkZWJ1Z0luZm8pIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaG9zdEVsZW1lbnQ7XG4gICAgICAgIGlmIChpc1ByZXNlbnQocm9vdFNlbGVjdG9yT3JOb2RlKSkge1xuICAgICAgICAgICAgaG9zdEVsZW1lbnQgPSByZW5kZXJlci5zZWxlY3RSb290RWxlbWVudChyb290U2VsZWN0b3JPck5vZGUsIGRlYnVnSW5mbyk7XG4gICAgICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlci5zZXRFbGVtZW50QXR0cmlidXRlKGhvc3RFbGVtZW50LCBhdHRycy5nZXQoaSksIGF0dHJzLmdldChpICsgMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVuZGVyZXIuc2V0RWxlbWVudEF0dHJpYnV0ZShob3N0RWxlbWVudCwgJ25nLXZlcnNpb24nLCBWRVJTSU9OLmZ1bGwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaG9zdEVsZW1lbnQgPSBjcmVhdGVSZW5kZXJFbGVtZW50KHJlbmRlcmVyLCBudWxsLCBlbGVtZW50TmFtZSwgYXR0cnMsIGRlYnVnSW5mbyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhvc3RFbGVtZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpZXdcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGV2ZW50TmFtZXNBbmRUYXJnZXRzXG4gICAgICogQHBhcmFtIHs/fSBsaXN0ZW5lclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gc3Vic2NyaWJlVG9SZW5kZXJFbGVtZW50KHZpZXcsIGVsZW1lbnQsIGV2ZW50TmFtZXNBbmRUYXJnZXRzLCBsaXN0ZW5lcikge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkaXNwb3NhYmxlcyA9IGNyZWF0ZUVtcHR5SW5saW5lQXJyYXkoZXZlbnROYW1lc0FuZFRhcmdldHMubGVuZ3RoIC8gMik7XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBldmVudE5hbWVzQW5kVGFyZ2V0cy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXZlbnROYW1lID0gZXZlbnROYW1lc0FuZFRhcmdldHMuZ2V0KGkpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXZlbnRUYXJnZXQgPSBldmVudE5hbWVzQW5kVGFyZ2V0cy5nZXQoaSArIDEpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGlzcG9zYWJsZSA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChldmVudFRhcmdldCkge1xuICAgICAgICAgICAgICAgIGRpc3Bvc2FibGUgPSB2aWV3LnJlbmRlcmVyLmxpc3Rlbkdsb2JhbChldmVudFRhcmdldCwgZXZlbnROYW1lLCBsaXN0ZW5lci5iaW5kKHZpZXcsIGV2ZW50VGFyZ2V0ICsgXCI6XCIgKyBldmVudE5hbWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRpc3Bvc2FibGUgPSB2aWV3LnJlbmRlcmVyLmxpc3RlbihlbGVtZW50LCBldmVudE5hbWUsIGxpc3RlbmVyLmJpbmQodmlldywgZXZlbnROYW1lKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXNwb3NhYmxlcy5zZXQoaSAvIDIsIGRpc3Bvc2FibGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaXNwb3NlSW5saW5lQXJyYXkuYmluZChudWxsLCBkaXNwb3NhYmxlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZGlzcG9zYWJsZXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRpc3Bvc2VJbmxpbmVBcnJheShkaXNwb3NhYmxlcykge1xuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgZGlzcG9zYWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGRpc3Bvc2FibGVzLmdldChpKSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9vcCgpIHsgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbGVuZ3RoXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVFbXB0eUlubGluZUFycmF5KGxlbmd0aCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjdG9yO1xuICAgICAgICBpZiAobGVuZ3RoIDw9IDIpIHtcbiAgICAgICAgICAgIGN0b3IgPSBJbmxpbmVBcnJheTI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGVuZ3RoIDw9IDQpIHtcbiAgICAgICAgICAgIGN0b3IgPSBJbmxpbmVBcnJheTQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGVuZ3RoIDw9IDgpIHtcbiAgICAgICAgICAgIGN0b3IgPSBJbmxpbmVBcnJheTg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGVuZ3RoIDw9IDE2KSB7XG4gICAgICAgICAgICBjdG9yID0gSW5saW5lQXJyYXkxNjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN0b3IgPSBJbmxpbmVBcnJheUR5bmFtaWM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBjdG9yKGxlbmd0aCk7XG4gICAgfVxuICAgIHZhciBJbmxpbmVBcnJheTAgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBJbmxpbmVBcnJheTAoKSB7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gaW5kZXhcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIElubGluZUFycmF5MC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGluZGV4KSB7IHJldHVybiB1bmRlZmluZWQ7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGluZGV4XG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIElubGluZUFycmF5MC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGluZGV4LCB2YWx1ZSkgeyB9O1xuICAgICAgICByZXR1cm4gSW5saW5lQXJyYXkwO1xuICAgIH0oKSk7XG4gICAgdmFyIElubGluZUFycmF5MiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGxlbmd0aFxuICAgICAgICAgKiBAcGFyYW0gez89fSBfdjBcbiAgICAgICAgICogQHBhcmFtIHs/PX0gX3YxXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBJbmxpbmVBcnJheTIobGVuZ3RoLCBfdjAsIF92MSkge1xuICAgICAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgICAgICB0aGlzLl92MCA9IF92MDtcbiAgICAgICAgICAgIHRoaXMuX3YxID0gX3YxO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGluZGV4XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBJbmxpbmVBcnJheTIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgc3dpdGNoIChpbmRleCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3YwO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3YxO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGluZGV4XG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIElubGluZUFycmF5Mi5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGluZGV4LCB2YWx1ZSkge1xuICAgICAgICAgICAgc3dpdGNoIChpbmRleCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdjAgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl92MSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIElubGluZUFycmF5MjtcbiAgICB9KCkpO1xuICAgIHZhciBJbmxpbmVBcnJheTQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBsZW5ndGhcbiAgICAgICAgICogQHBhcmFtIHs/PX0gX3YwXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IF92MVxuICAgICAgICAgKiBAcGFyYW0gez89fSBfdjJcbiAgICAgICAgICogQHBhcmFtIHs/PX0gX3YzXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBJbmxpbmVBcnJheTQobGVuZ3RoLCBfdjAsIF92MSwgX3YyLCBfdjMpIHtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5fdjAgPSBfdjA7XG4gICAgICAgICAgICB0aGlzLl92MSA9IF92MTtcbiAgICAgICAgICAgIHRoaXMuX3YyID0gX3YyO1xuICAgICAgICAgICAgdGhpcy5fdjMgPSBfdjM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gaW5kZXhcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIElubGluZUFycmF5NC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdjA7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdjE7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdjI7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdjM7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gaW5kZXhcbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgSW5saW5lQXJyYXk0LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoaW5kZXgsIHZhbHVlKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl92MCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3YxID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdjIgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl92MyA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIElubGluZUFycmF5NDtcbiAgICB9KCkpO1xuICAgIHZhciBJbmxpbmVBcnJheTggPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBsZW5ndGhcbiAgICAgICAgICogQHBhcmFtIHs/PX0gX3YwXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IF92MVxuICAgICAgICAgKiBAcGFyYW0gez89fSBfdjJcbiAgICAgICAgICogQHBhcmFtIHs/PX0gX3YzXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IF92NFxuICAgICAgICAgKiBAcGFyYW0gez89fSBfdjVcbiAgICAgICAgICogQHBhcmFtIHs/PX0gX3Y2XG4gICAgICAgICAqIEBwYXJhbSB7Pz19IF92N1xuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gSW5saW5lQXJyYXk4KGxlbmd0aCwgX3YwLCBfdjEsIF92MiwgX3YzLCBfdjQsIF92NSwgX3Y2LCBfdjcpIHtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5fdjAgPSBfdjA7XG4gICAgICAgICAgICB0aGlzLl92MSA9IF92MTtcbiAgICAgICAgICAgIHRoaXMuX3YyID0gX3YyO1xuICAgICAgICAgICAgdGhpcy5fdjMgPSBfdjM7XG4gICAgICAgICAgICB0aGlzLl92NCA9IF92NDtcbiAgICAgICAgICAgIHRoaXMuX3Y1ID0gX3Y1O1xuICAgICAgICAgICAgdGhpcy5fdjYgPSBfdjY7XG4gICAgICAgICAgICB0aGlzLl92NyA9IF92NztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBpbmRleFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgSW5saW5lQXJyYXk4LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92MDtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92MTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92MjtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92MztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92NDtcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92NTtcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92NjtcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92NztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBpbmRleFxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBJbmxpbmVBcnJheTgucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChpbmRleCwgdmFsdWUpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3YwID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdjEgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl92MiA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3YzID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdjQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl92NSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Y2ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdjcgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBJbmxpbmVBcnJheTg7XG4gICAgfSgpKTtcbiAgICB2YXIgSW5saW5lQXJyYXkxNiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGxlbmd0aFxuICAgICAgICAgKiBAcGFyYW0gez89fSBfdjBcbiAgICAgICAgICogQHBhcmFtIHs/PX0gX3YxXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IF92MlxuICAgICAgICAgKiBAcGFyYW0gez89fSBfdjNcbiAgICAgICAgICogQHBhcmFtIHs/PX0gX3Y0XG4gICAgICAgICAqIEBwYXJhbSB7Pz19IF92NVxuICAgICAgICAgKiBAcGFyYW0gez89fSBfdjZcbiAgICAgICAgICogQHBhcmFtIHs/PX0gX3Y3XG4gICAgICAgICAqIEBwYXJhbSB7Pz19IF92OFxuICAgICAgICAgKiBAcGFyYW0gez89fSBfdjlcbiAgICAgICAgICogQHBhcmFtIHs/PX0gX3YxMFxuICAgICAgICAgKiBAcGFyYW0gez89fSBfdjExXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IF92MTJcbiAgICAgICAgICogQHBhcmFtIHs/PX0gX3YxM1xuICAgICAgICAgKiBAcGFyYW0gez89fSBfdjE0XG4gICAgICAgICAqIEBwYXJhbSB7Pz19IF92MTVcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIElubGluZUFycmF5MTYobGVuZ3RoLCBfdjAsIF92MSwgX3YyLCBfdjMsIF92NCwgX3Y1LCBfdjYsIF92NywgX3Y4LCBfdjksIF92MTAsIF92MTEsIF92MTIsIF92MTMsIF92MTQsIF92MTUpIHtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5fdjAgPSBfdjA7XG4gICAgICAgICAgICB0aGlzLl92MSA9IF92MTtcbiAgICAgICAgICAgIHRoaXMuX3YyID0gX3YyO1xuICAgICAgICAgICAgdGhpcy5fdjMgPSBfdjM7XG4gICAgICAgICAgICB0aGlzLl92NCA9IF92NDtcbiAgICAgICAgICAgIHRoaXMuX3Y1ID0gX3Y1O1xuICAgICAgICAgICAgdGhpcy5fdjYgPSBfdjY7XG4gICAgICAgICAgICB0aGlzLl92NyA9IF92NztcbiAgICAgICAgICAgIHRoaXMuX3Y4ID0gX3Y4O1xuICAgICAgICAgICAgdGhpcy5fdjkgPSBfdjk7XG4gICAgICAgICAgICB0aGlzLl92MTAgPSBfdjEwO1xuICAgICAgICAgICAgdGhpcy5fdjExID0gX3YxMTtcbiAgICAgICAgICAgIHRoaXMuX3YxMiA9IF92MTI7XG4gICAgICAgICAgICB0aGlzLl92MTMgPSBfdjEzO1xuICAgICAgICAgICAgdGhpcy5fdjE0ID0gX3YxNDtcbiAgICAgICAgICAgIHRoaXMuX3YxNSA9IF92MTU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gaW5kZXhcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIElubGluZUFycmF5MTYucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgc3dpdGNoIChpbmRleCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3YwO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3YxO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3YyO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3YzO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Y0O1xuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Y1O1xuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Y2O1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Y3O1xuICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Y4O1xuICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Y5O1xuICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92MTA7XG4gICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3YxMTtcbiAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdjEyO1xuICAgICAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92MTM7XG4gICAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3YxNDtcbiAgICAgICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdjE1O1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGluZGV4XG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIElubGluZUFycmF5MTYucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChpbmRleCwgdmFsdWUpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3YwID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdjEgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl92MiA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3YzID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdjQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl92NSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Y2ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdjcgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl92OCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Y5ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3YxMCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl92MTEgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdjEyID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3YxMyA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl92MTQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdjE1ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gSW5saW5lQXJyYXkxNjtcbiAgICB9KCkpO1xuICAgIHZhciBJbmxpbmVBcnJheUR5bmFtaWMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBsZW5ndGhcbiAgICAgICAgICogQHBhcmFtIHsuLi4/fSB2YWx1ZXNcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIElubGluZUFycmF5RHluYW1pYyhsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZXMgPSB2YWx1ZXM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gaW5kZXhcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIElubGluZUFycmF5RHluYW1pYy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGluZGV4KSB7IHJldHVybiB0aGlzLl92YWx1ZXNbaW5kZXhdOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBpbmRleFxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBJbmxpbmVBcnJheUR5bmFtaWMucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChpbmRleCwgdmFsdWUpIHsgdGhpcy5fdmFsdWVzW2luZGV4XSA9IHZhbHVlOyB9O1xuICAgICAgICByZXR1cm4gSW5saW5lQXJyYXlEeW5hbWljO1xuICAgIH0oKSk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gRU1QVFlfSU5MSU5FX0FSUkFZID0gbmV3IElubGluZUFycmF5MCgpO1xuXG5cbiAgICB2YXIgdmlld191dGlscyA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBWaWV3VXRpbHM6IFZpZXdVdGlscyxcbiAgICAgICAgY3JlYXRlUmVuZGVyQ29tcG9uZW50VHlwZTogY3JlYXRlUmVuZGVyQ29tcG9uZW50VHlwZSxcbiAgICAgICAgYWRkVG9BcnJheTogYWRkVG9BcnJheSxcbiAgICAgICAgaW50ZXJwb2xhdGU6IGludGVycG9sYXRlLFxuICAgICAgICBpbmxpbmVJbnRlcnBvbGF0ZTogaW5saW5lSW50ZXJwb2xhdGUsXG4gICAgICAgIGNoZWNrQmluZGluZzogY2hlY2tCaW5kaW5nLFxuICAgICAgICBjYXN0QnlWYWx1ZTogY2FzdEJ5VmFsdWUsXG4gICAgICAgIEVNUFRZX0FSUkFZOiBFTVBUWV9BUlJBWSxcbiAgICAgICAgRU1QVFlfTUFQOiBFTVBUWV9NQVAsXG4gICAgICAgIHB1cmVQcm94eTE6IHB1cmVQcm94eTEsXG4gICAgICAgIHB1cmVQcm94eTI6IHB1cmVQcm94eTIsXG4gICAgICAgIHB1cmVQcm94eTM6IHB1cmVQcm94eTMsXG4gICAgICAgIHB1cmVQcm94eTQ6IHB1cmVQcm94eTQsXG4gICAgICAgIHB1cmVQcm94eTU6IHB1cmVQcm94eTUsXG4gICAgICAgIHB1cmVQcm94eTY6IHB1cmVQcm94eTYsXG4gICAgICAgIHB1cmVQcm94eTc6IHB1cmVQcm94eTcsXG4gICAgICAgIHB1cmVQcm94eTg6IHB1cmVQcm94eTgsXG4gICAgICAgIHB1cmVQcm94eTk6IHB1cmVQcm94eTksXG4gICAgICAgIHB1cmVQcm94eTEwOiBwdXJlUHJveHkxMCxcbiAgICAgICAgc2V0QmluZGluZ0RlYnVnSW5mb0ZvckNoYW5nZXM6IHNldEJpbmRpbmdEZWJ1Z0luZm9Gb3JDaGFuZ2VzLFxuICAgICAgICBzZXRCaW5kaW5nRGVidWdJbmZvOiBzZXRCaW5kaW5nRGVidWdJbmZvLFxuICAgICAgICBjcmVhdGVSZW5kZXJFbGVtZW50OiBjcmVhdGVSZW5kZXJFbGVtZW50LFxuICAgICAgICBzZWxlY3RPckNyZWF0ZVJlbmRlckhvc3RFbGVtZW50OiBzZWxlY3RPckNyZWF0ZVJlbmRlckhvc3RFbGVtZW50LFxuICAgICAgICBzdWJzY3JpYmVUb1JlbmRlckVsZW1lbnQ6IHN1YnNjcmliZVRvUmVuZGVyRWxlbWVudCxcbiAgICAgICAgbm9vcDogbm9vcCxcbiAgICAgICAgSW5saW5lQXJyYXkyOiBJbmxpbmVBcnJheTIsXG4gICAgICAgIElubGluZUFycmF5NDogSW5saW5lQXJyYXk0LFxuICAgICAgICBJbmxpbmVBcnJheTg6IElubGluZUFycmF5OCxcbiAgICAgICAgSW5saW5lQXJyYXkxNjogSW5saW5lQXJyYXkxNixcbiAgICAgICAgSW5saW5lQXJyYXlEeW5hbWljOiBJbmxpbmVBcnJheUR5bmFtaWMsXG4gICAgICAgIEVNUFRZX0lOTElORV9BUlJBWTogRU1QVFlfSU5MSU5FX0FSUkFZXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQ1ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhbiBpbnN0YW5jZSBvZiBhIENvbXBvbmVudCBjcmVhdGVkIHZpYSBhIHtcXEBsaW5rIENvbXBvbmVudEZhY3Rvcnl9LlxuICAgICAqXG4gICAgICogYENvbXBvbmVudFJlZmAgcHJvdmlkZXMgYWNjZXNzIHRvIHRoZSBDb21wb25lbnQgSW5zdGFuY2UgYXMgd2VsbCBvdGhlciBvYmplY3RzIHJlbGF0ZWQgdG8gdGhpc1xuICAgICAqIENvbXBvbmVudCBJbnN0YW5jZSBhbmQgYWxsb3dzIHlvdSB0byBkZXN0cm95IHRoZSBDb21wb25lbnQgSW5zdGFuY2UgdmlhIHRoZSB7XFxAbGluayAjZGVzdHJveX1cbiAgICAgKiBtZXRob2QuXG4gICAgICogXFxAc3RhYmxlXG4gICAgICogQGFic3RyYWN0XG4gICAgICovXG4gICAgdmFyIENvbXBvbmVudFJlZiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIENvbXBvbmVudFJlZigpIHtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50UmVmLnByb3RvdHlwZSwgXCJsb2NhdGlvblwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIExvY2F0aW9uIG9mIHRoZSBIb3N0IEVsZW1lbnQgb2YgdGhpcyBDb21wb25lbnQgSW5zdGFuY2UuXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaW1wbGVtZW50ZWQoKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnRSZWYucHJvdG90eXBlLCBcImluamVjdG9yXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIGluamVjdG9yIG9uIHdoaWNoIHRoZSBjb21wb25lbnQgaW5zdGFuY2UgZXhpc3RzLlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmltcGxlbWVudGVkKCk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50UmVmLnByb3RvdHlwZSwgXCJpbnN0YW5jZVwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSBpbnN0YW5jZSBvZiB0aGUgQ29tcG9uZW50LlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmltcGxlbWVudGVkKCk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICA7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnRSZWYucHJvdG90eXBlLCBcImhvc3RWaWV3XCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIHtcXEBsaW5rIFZpZXdSZWZ9IG9mIHRoZSBIb3N0IFZpZXcgb2YgdGhpcyBDb21wb25lbnQgaW5zdGFuY2UuXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaW1wbGVtZW50ZWQoKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIDtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudFJlZi5wcm90b3R5cGUsIFwiY2hhbmdlRGV0ZWN0b3JSZWZcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUge1xcQGxpbmsgQ2hhbmdlRGV0ZWN0b3JSZWZ9IG9mIHRoZSBDb21wb25lbnQgaW5zdGFuY2UuXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaW1wbGVtZW50ZWQoKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnRSZWYucHJvdG90eXBlLCBcImNvbXBvbmVudFR5cGVcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgY29tcG9uZW50IHR5cGUuXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaW1wbGVtZW50ZWQoKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXN0cm95cyB0aGUgY29tcG9uZW50IGluc3RhbmNlIGFuZCBhbGwgb2YgdGhlIGRhdGEgc3RydWN0dXJlcyBhc3NvY2lhdGVkIHdpdGggaXQuXG4gICAgICAgICAqIEBhYnN0cmFjdFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQ29tcG9uZW50UmVmLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQWxsb3dzIHRvIHJlZ2lzdGVyIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgZGVzdHJveWVkLlxuICAgICAgICAgKiBAYWJzdHJhY3RcbiAgICAgICAgICogQHBhcmFtIHs/fSBjYWxsYmFja1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQ29tcG9uZW50UmVmLnByb3RvdHlwZS5vbkRlc3Ryb3kgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHsgfTtcbiAgICAgICAgcmV0dXJuIENvbXBvbmVudFJlZjtcbiAgICB9KCkpO1xuICAgIHZhciBDb21wb25lbnRSZWZfID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDUoQ29tcG9uZW50UmVmXywgX3N1cGVyKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gX2luZGV4XG4gICAgICAgICAqIEBwYXJhbSB7P30gX3BhcmVudFZpZXdcbiAgICAgICAgICogQHBhcmFtIHs/fSBfbmF0aXZlRWxlbWVudFxuICAgICAgICAgKiBAcGFyYW0gez99IF9jb21wb25lbnRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIENvbXBvbmVudFJlZl8oX2luZGV4LCBfcGFyZW50VmlldywgX25hdGl2ZUVsZW1lbnQsIF9jb21wb25lbnQpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5faW5kZXggPSBfaW5kZXg7XG4gICAgICAgICAgICB0aGlzLl9wYXJlbnRWaWV3ID0gX3BhcmVudFZpZXc7XG4gICAgICAgICAgICB0aGlzLl9uYXRpdmVFbGVtZW50ID0gX25hdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLl9jb21wb25lbnQgPSBfY29tcG9uZW50O1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnRSZWZfLnByb3RvdHlwZSwgXCJsb2NhdGlvblwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEVsZW1lbnRSZWYodGhpcy5fbmF0aXZlRWxlbWVudCk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50UmVmXy5wcm90b3R5cGUsIFwiaW5qZWN0b3JcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3BhcmVudFZpZXcuaW5qZWN0b3IodGhpcy5faW5kZXgpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudFJlZl8ucHJvdG90eXBlLCBcImluc3RhbmNlXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jb21wb25lbnQ7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICA7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnRSZWZfLnByb3RvdHlwZSwgXCJob3N0Vmlld1wiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcGFyZW50Vmlldy5yZWY7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICA7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnRSZWZfLnByb3RvdHlwZSwgXCJjaGFuZ2VEZXRlY3RvclJlZlwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcGFyZW50Vmlldy5yZWY7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICA7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnRSZWZfLnByb3RvdHlwZSwgXCJjb21wb25lbnRUeXBlXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy5fY29tcG9uZW50LmNvbnN0cnVjdG9yKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQ29tcG9uZW50UmVmXy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fcGFyZW50Vmlldy5kZXRhY2hBbmREZXN0cm95KCk7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGNhbGxiYWNrXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBDb21wb25lbnRSZWZfLnByb3RvdHlwZS5vbkRlc3Ryb3kgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHsgdGhpcy5ob3N0Vmlldy5vbkRlc3Ryb3koY2FsbGJhY2spOyB9O1xuICAgICAgICByZXR1cm4gQ29tcG9uZW50UmVmXztcbiAgICB9KENvbXBvbmVudFJlZikpO1xuICAgIC8qKlxuICAgICAqIFxcQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBDb21wb25lbnRGYWN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gc2VsZWN0b3JcbiAgICAgICAgICogQHBhcmFtIHs/fSBfdmlld0NsYXNzXG4gICAgICAgICAqIEBwYXJhbSB7P30gX2NvbXBvbmVudFR5cGVcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIENvbXBvbmVudEZhY3Rvcnkoc2VsZWN0b3IsIF92aWV3Q2xhc3MsIF9jb21wb25lbnRUeXBlKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgICAgICAgICB0aGlzLl92aWV3Q2xhc3MgPSBfdmlld0NsYXNzO1xuICAgICAgICAgICAgdGhpcy5fY29tcG9uZW50VHlwZSA9IF9jb21wb25lbnRUeXBlO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnRGYWN0b3J5LnByb3RvdHlwZSwgXCJjb21wb25lbnRUeXBlXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jb21wb25lbnRUeXBlOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgY29tcG9uZW50LlxuICAgICAgICAgKiBAcGFyYW0gez99IGluamVjdG9yXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IHByb2plY3RhYmxlTm9kZXNcbiAgICAgICAgICogQHBhcmFtIHs/PX0gcm9vdFNlbGVjdG9yT3JOb2RlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBDb21wb25lbnRGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoaW5qZWN0b3IsIHByb2plY3RhYmxlTm9kZXMsIHJvb3RTZWxlY3Rvck9yTm9kZSkge1xuICAgICAgICAgICAgaWYgKHByb2plY3RhYmxlTm9kZXMgPT09IHZvaWQgMCkgeyBwcm9qZWN0YWJsZU5vZGVzID0gbnVsbDsgfVxuICAgICAgICAgICAgaWYgKHJvb3RTZWxlY3Rvck9yTm9kZSA9PT0gdm9pZCAwKSB7IHJvb3RTZWxlY3Rvck9yTm9kZSA9IG51bGw7IH1cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZ1ID0gaW5qZWN0b3IuZ2V0KFZpZXdVdGlscyk7XG4gICAgICAgICAgICBpZiAoIXByb2plY3RhYmxlTm9kZXMpIHtcbiAgICAgICAgICAgICAgICBwcm9qZWN0YWJsZU5vZGVzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBob3N0VmlldyA9IG5ldyB0aGlzLl92aWV3Q2xhc3ModnUsIG51bGwsIG51bGwsIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuIGhvc3RWaWV3LmNyZWF0ZUhvc3RWaWV3KHJvb3RTZWxlY3Rvck9yTm9kZSwgaW5qZWN0b3IsIHByb2plY3RhYmxlTm9kZXMpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQ29tcG9uZW50RmFjdG9yeTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkOCA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFxcQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBOb0NvbXBvbmVudEZhY3RvcnlFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQ4KE5vQ29tcG9uZW50RmFjdG9yeUVycm9yLCBfc3VwZXIpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBjb21wb25lbnRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIE5vQ29tcG9uZW50RmFjdG9yeUVycm9yKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgXCJObyBjb21wb25lbnQgZmFjdG9yeSBmb3VuZCBmb3IgXCIgKyBzdHJpbmdpZnkoY29tcG9uZW50KSArIFwiLiBEaWQgeW91IGFkZCBpdCB0byBATmdNb2R1bGUuZW50cnlDb21wb25lbnRzP1wiKTtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBOb0NvbXBvbmVudEZhY3RvcnlFcnJvcjtcbiAgICB9KEJhc2VFcnJvcikpO1xuICAgIHZhciBfTnVsbENvbXBvbmVudEZhY3RvcnlSZXNvbHZlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIF9OdWxsQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyKCkge1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGNvbXBvbmVudFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgX051bGxDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIucHJvdG90eXBlLnJlc29sdmVDb21wb25lbnRGYWN0b3J5ID0gZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE5vQ29tcG9uZW50RmFjdG9yeUVycm9yKGNvbXBvbmVudCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfTnVsbENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcjtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIFxcQHN0YWJsZVxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICAgIHZhciBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIoKSB7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBhYnN0cmFjdFxuICAgICAgICAgKiBAcGFyYW0gez99IGNvbXBvbmVudFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLnByb3RvdHlwZS5yZXNvbHZlQ29tcG9uZW50RmFjdG9yeSA9IGZ1bmN0aW9uIChjb21wb25lbnQpIHsgfTtcbiAgICAgICAgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLk5VTEwgPSBuZXcgX051bGxDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIoKTtcbiAgICAgICAgcmV0dXJuIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcjtcbiAgICB9KCkpO1xuICAgIHZhciBDb2RlZ2VuQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gZmFjdG9yaWVzXG4gICAgICAgICAqIEBwYXJhbSB7P30gX3BhcmVudFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gQ29kZWdlbkNvbXBvbmVudEZhY3RvcnlSZXNvbHZlcihmYWN0b3JpZXMsIF9wYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcmVudCA9IF9wYXJlbnQ7XG4gICAgICAgICAgICB0aGlzLl9mYWN0b3JpZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZhY3Rvcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBmYWN0b3J5ID0gZmFjdG9yaWVzW2ldO1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZhY3Rvcmllcy5zZXQoZmFjdG9yeS5jb21wb25lbnRUeXBlLCBmYWN0b3J5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBjb21wb25lbnRcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIENvZGVnZW5Db21wb25lbnRGYWN0b3J5UmVzb2x2ZXIucHJvdG90eXBlLnJlc29sdmVDb21wb25lbnRGYWN0b3J5ID0gZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0gdGhpcy5fZmFjdG9yaWVzLmdldChjb21wb25lbnQpO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9wYXJlbnQucmVzb2x2ZUNvbXBvbmVudEZhY3RvcnkoY29tcG9uZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBDb2RlZ2VuQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyO1xuICAgIH0oKSk7XG5cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmFjZTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBldmVudHM7XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZXRlY3RXVEYoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHd0ZiA9ICgoZ2xvYmFsJDEpIC8qKiBUT0RPICM5MTAwICovKVsnd3RmJ107XG4gICAgICAgIGlmICh3dGYpIHtcbiAgICAgICAgICAgIHRyYWNlID0gd3RmWyd0cmFjZSddO1xuICAgICAgICAgICAgaWYgKHRyYWNlKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRzID0gdHJhY2VbJ2V2ZW50cyddO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzaWduYXR1cmVcbiAgICAgKiBAcGFyYW0gez89fSBmbGFnc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlU2NvcGUoc2lnbmF0dXJlLCBmbGFncykge1xuICAgICAgICBpZiAoZmxhZ3MgPT09IHZvaWQgMCkgeyBmbGFncyA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIGV2ZW50cy5jcmVhdGVTY29wZShzaWduYXR1cmUsIGZsYWdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzY29wZVxuICAgICAqIEBwYXJhbSB7Pz19IHJldHVyblZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsZWF2ZShzY29wZSwgcmV0dXJuVmFsdWUpIHtcbiAgICAgICAgdHJhY2UubGVhdmVTY29wZShzY29wZSwgcmV0dXJuVmFsdWUpO1xuICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmFuZ2VUeXBlXG4gICAgICogQHBhcmFtIHs/fSBhY3Rpb25cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YXJ0VGltZVJhbmdlKHJhbmdlVHlwZSwgYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiB0cmFjZS5iZWdpblRpbWVSYW5nZShyYW5nZVR5cGUsIGFjdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmFuZ2VcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVuZFRpbWVSYW5nZShyYW5nZSkge1xuICAgICAgICB0cmFjZS5lbmRUaW1lUmFuZ2UocmFuZ2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRydWUgaWYgV1RGIGlzIGVuYWJsZWQuXG4gICAgICovXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gd3RmRW5hYmxlZCA9IGRldGVjdFdURigpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Pz19IGFyZzBcbiAgICAgKiBAcGFyYW0gez89fSBhcmcxXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBub29wU2NvcGUoYXJnMCwgYXJnMSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRyYWNlIHNjb3BlLlxuICAgICAqXG4gICAgICogU2NvcGVzIG11c3QgYmUgc3RyaWN0bHkgbmVzdGVkIGFuZCBhcmUgYW5hbG9nb3VzIHRvIHN0YWNrIGZyYW1lcywgYnV0XG4gICAgICogZG8gbm90IGhhdmUgdG8gZm9sbG93IHRoZSBzdGFjayBmcmFtZXMuIEluc3RlYWQgaXQgaXMgcmVjb21tZW5kZWQgdGhhdCB0aGV5IGZvbGxvdyBsb2dpY2FsXG4gICAgICogbmVzdGluZy4gWW91IG1heSB3YW50IHRvIHVzZVxuICAgICAqIFtFdmVudFxuICAgICAqIFNpZ25hdHVyZXNdKGh0dHA6Ly9nb29nbGUuZ2l0aHViLmlvL3RyYWNpbmctZnJhbWV3b3JrL2luc3RydW1lbnRpbmctY29kZS5odG1sI2N1c3RvbS1ldmVudHMpXG4gICAgICogYXMgdGhleSBhcmUgZGVmaW5lZCBpbiBXVEYuXG4gICAgICpcbiAgICAgKiBVc2VkIHRvIG1hcmsgc2NvcGUgZW50cnkuIFRoZSByZXR1cm4gdmFsdWUgaXMgdXNlZCB0byBsZWF2ZSB0aGUgc2NvcGUuXG4gICAgICpcbiAgICAgKiAgICAgdmFyIG15U2NvcGUgPSB3dGZDcmVhdGVTY29wZSgnTXlDbGFzcyNteU1ldGhvZChhc2NpaSBzb21lVmFsKScpO1xuICAgICAqXG4gICAgICogICAgIHNvbWVNZXRob2QoKSB7XG4gICAgICogICAgICAgIHZhciBzID0gbXlTY29wZSgnRm9vJyk7IC8vICdGb28nIGdldHMgc3RvcmVkIGluIHRyYWNpbmcgVUlcbiAgICAgKiAgICAgICAgLy8gRE8gU09NRSBXT1JLIEhFUkVcbiAgICAgKiAgICAgICAgcmV0dXJuIHd0ZkxlYXZlKHMsIDEyMyk7IC8vIFJldHVybiB2YWx1ZSAxMjNcbiAgICAgKiAgICAgfVxuICAgICAqXG4gICAgICogTm90ZSwgYWRkaW5nIHRyeS1maW5hbGx5IGJsb2NrIGFyb3VuZCB0aGUgd29yayB0byBlbnN1cmUgdGhhdCBgd3RmTGVhdmVgIGdldHMgY2FsbGVkIGNhblxuICAgICAqIG5lZ2F0aXZlbHkgaW1wYWN0IHRoZSBwZXJmb3JtYW5jZSBvZiB5b3VyIGFwcGxpY2F0aW9uLiBGb3IgdGhpcyByZWFzb24gd2UgcmVjb21tZW5kIHRoYXRcbiAgICAgKiB5b3UgZG9uJ3QgYWRkIHRoZW0gdG8gZW5zdXJlIHRoYXQgYHd0ZkxlYXZlYCBnZXRzIGNhbGxlZC4gSW4gcHJvZHVjdGlvbiBgd3RmTGVhdmVgIGlzIGEgbm9vcCBhbmRcbiAgICAgKiBzbyB0cnktZmluYWxseSBibG9jayBoYXMgbm8gdmFsdWUuIFdoZW4gZGVidWdnaW5nIHBlcmYgaXNzdWVzLCBza2lwcGluZyBgd3RmTGVhdmVgLCBkbyB0b1xuICAgICAqIGV4Y2VwdGlvbiwgd2lsbCBwcm9kdWNlIGluY29ycmVjdCB0cmFjZSwgYnV0IHByZXNlbmNlIG9mIGV4Y2VwdGlvbiBzaWduaWZpZXMgbG9naWMgZXJyb3Igd2hpY2hcbiAgICAgKiBuZWVkcyB0byBiZSBmaXhlZCBiZWZvcmUgdGhlIGFwcCBzaG91bGQgYmUgcHJvZmlsZWQuIEFkZCB0cnktZmluYWxseSBvbmx5IHdoZW4geW91IGV4cGVjdCB0aGF0XG4gICAgICogYW4gZXhjZXB0aW9uIGlzIGV4cGVjdGVkIGR1cmluZyBub3JtYWwgZXhlY3V0aW9uIHdoaWxlIHByb2ZpbGluZy5cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB3dGZDcmVhdGVTY29wZSA9IHd0ZkVuYWJsZWQgPyBjcmVhdGVTY29wZSA6IGZ1bmN0aW9uIChzaWduYXR1cmUsIGZsYWdzKSB7IHJldHVybiBub29wU2NvcGU7IH07XG4gICAgLyoqXG4gICAgICogVXNlZCB0byBtYXJrIGVuZCBvZiBTY29wZS5cbiAgICAgKlxuICAgICAqIC0gYHNjb3BlYCB0byBlbmQuXG4gICAgICogLSBgcmV0dXJuVmFsdWVgIChvcHRpb25hbCkgdG8gYmUgcGFzc2VkIHRvIHRoZSBXVEYuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIHRoZSBgcmV0dXJuVmFsdWUgZm9yIGVhc3kgY2hhaW5pbmcuXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHd0ZkxlYXZlID0gd3RmRW5hYmxlZCA/IGxlYXZlIDogZnVuY3Rpb24gKHMsIHIpIHsgcmV0dXJuIHI7IH07XG4gICAgLyoqXG4gICAgICogVXNlZCB0byBtYXJrIEFzeW5jIHN0YXJ0LiBBc3luYyBhcmUgc2ltaWxhciB0byBzY29wZSBidXQgdGhleSBkb24ndCBoYXZlIHRvIGJlIHN0cmljdGx5IG5lc3RlZC5cbiAgICAgKiBUaGUgcmV0dXJuIHZhbHVlIGlzIHVzZWQgaW4gdGhlIGNhbGwgdG8gW2VuZEFzeW5jXS4gQXN5bmMgcmFuZ2VzIG9ubHkgd29yayBpZiBXVEYgaGFzIGJlZW5cbiAgICAgKiBlbmFibGVkLlxuICAgICAqXG4gICAgICogICAgIHNvbWVNZXRob2QoKSB7XG4gICAgICogICAgICAgIHZhciBzID0gd3RmU3RhcnRUaW1lUmFuZ2UoJ0hUVFA6R0VUJywgJ3NvbWUudXJsJyk7XG4gICAgICogICAgICAgIHZhciBmdXR1cmUgPSBuZXcgRnV0dXJlLmRlbGF5KDUpLnRoZW4oKF8pIHtcbiAgICAgKiAgICAgICAgICB3dGZFbmRUaW1lUmFuZ2Uocyk7XG4gICAgICogICAgICAgIH0pO1xuICAgICAqICAgICB9XG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHd0ZlN0YXJ0VGltZVJhbmdlID0gd3RmRW5hYmxlZCA/IHN0YXJ0VGltZVJhbmdlIDogZnVuY3Rpb24gKHJhbmdlVHlwZSwgYWN0aW9uKSB7IHJldHVybiBudWxsOyB9O1xuICAgIC8qKlxuICAgICAqIEVuZHMgYSBhc3luYyB0aW1lIHJhbmdlIG9wZXJhdGlvbi5cbiAgICAgKiBbcmFuZ2VdIGlzIHRoZSByZXR1cm4gdmFsdWUgZnJvbSBbd3RmU3RhcnRUaW1lUmFuZ2VdIEFzeW5jIHJhbmdlcyBvbmx5IHdvcmsgaWYgV1RGIGhhcyBiZWVuXG4gICAgICogZW5hYmxlZC5cbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gd3RmRW5kVGltZVJhbmdlID0gd3RmRW5hYmxlZCA/IGVuZFRpbWVSYW5nZSA6IGZ1bmN0aW9uIChyKSB7IHJldHVybiBudWxsOyB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIFRlc3RhYmlsaXR5IHNlcnZpY2UgcHJvdmlkZXMgdGVzdGluZyBob29rcyB0aGF0IGNhbiBiZSBhY2Nlc3NlZCBmcm9tXG4gICAgICogdGhlIGJyb3dzZXIgYW5kIGJ5IHNlcnZpY2VzIHN1Y2ggYXMgUHJvdHJhY3Rvci4gRWFjaCBib290c3RyYXBwZWQgQW5ndWxhclxuICAgICAqIGFwcGxpY2F0aW9uIG9uIHRoZSBwYWdlIHdpbGwgaGF2ZSBhbiBpbnN0YW5jZSBvZiBUZXN0YWJpbGl0eS5cbiAgICAgKiBcXEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgVGVzdGFiaWxpdHkgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBfbmdab25lXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBUZXN0YWJpbGl0eShfbmdab25lKSB7XG4gICAgICAgICAgICB0aGlzLl9uZ1pvbmUgPSBfbmdab25lO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fcGVuZGluZ0NvdW50ID0gMDtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX2lzWm9uZVN0YWJsZSA9IHRydWU7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdoZXRoZXIgYW55IHdvcmsgd2FzIGRvbmUgc2luY2UgdGhlIGxhc3QgJ3doZW5TdGFibGUnIGNhbGxiYWNrLiBUaGlzIGlzXG4gICAgICAgICAgICAgKiB1c2VmdWwgdG8gZGV0ZWN0IGlmIHRoaXMgY291bGQgaGF2ZSBwb3RlbnRpYWxseSBkZXN0YWJpbGl6ZWQgYW5vdGhlclxuICAgICAgICAgICAgICogY29tcG9uZW50IHdoaWxlIGl0IGlzIHN0YWJpbGl6aW5nLlxuICAgICAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuX2RpZFdvcmsgPSBmYWxzZTtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fd2F0Y2hBbmd1bGFyRXZlbnRzKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxcQGludGVybmFsXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBUZXN0YWJpbGl0eS5wcm90b3R5cGUuX3dhdGNoQW5ndWxhckV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLl9uZ1pvbmUub25VbnN0YWJsZS5zdWJzY3JpYmUoe1xuICAgICAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2RpZFdvcmsgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5faXNab25lU3RhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9uZ1pvbmUub25TdGFibGUuc3Vic2NyaWJlKHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgTmdab25lLmFzc2VydE5vdEluQW5ndWxhclpvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVkdWxlTWljcm9UYXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5faXNab25lU3RhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcnVuQ2FsbGJhY2tzSWZSZWFkeSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFRlc3RhYmlsaXR5LnByb3RvdHlwZS5pbmNyZWFzZVBlbmRpbmdSZXF1ZXN0Q291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nQ291bnQgKz0gMTtcbiAgICAgICAgICAgIHRoaXMuX2RpZFdvcmsgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BlbmRpbmdDb3VudDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBUZXN0YWJpbGl0eS5wcm90b3R5cGUuZGVjcmVhc2VQZW5kaW5nUmVxdWVzdENvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fcGVuZGluZ0NvdW50IC09IDE7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGVuZGluZ0NvdW50IDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGVuZGluZyBhc3luYyByZXF1ZXN0cyBiZWxvdyB6ZXJvJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9ydW5DYWxsYmFja3NJZlJlYWR5KCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGVuZGluZ0NvdW50O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFRlc3RhYmlsaXR5LnByb3RvdHlwZS5pc1N0YWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc1pvbmVTdGFibGUgJiYgdGhpcy5fcGVuZGluZ0NvdW50ID09IDAgJiYgIXRoaXMuX25nWm9uZS5oYXNQZW5kaW5nTWFjcm90YXNrcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxcQGludGVybmFsXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBUZXN0YWJpbGl0eS5wcm90b3R5cGUuX3J1bkNhbGxiYWNrc0lmUmVhZHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNTdGFibGUoKSkge1xuICAgICAgICAgICAgICAgIC8vIFNjaGVkdWxlcyB0aGUgY2FsbCBiYWNrcyBpbiBhIG5ldyBmcmFtZSBzbyB0aGF0IGl0IGlzIGFsd2F5cyBhc3luYy5cbiAgICAgICAgICAgICAgICBzY2hlZHVsZU1pY3JvVGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChfdGhpcy5fY2FsbGJhY2tzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgKF90aGlzLl9jYWxsYmFja3MucG9wKCkpKF90aGlzLl9kaWRXb3JrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fZGlkV29yayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTm90IFJlYWR5XG4gICAgICAgICAgICAgICAgdGhpcy5fZGlkV29yayA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGNhbGxiYWNrXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBUZXN0YWJpbGl0eS5wcm90b3R5cGUud2hlblN0YWJsZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgdGhpcy5fcnVuQ2FsbGJhY2tzSWZSZWFkeSgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFRlc3RhYmlsaXR5LnByb3RvdHlwZS5nZXRQZW5kaW5nUmVxdWVzdENvdW50ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcGVuZGluZ0NvdW50OyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgdXNlIGZpbmRQcm92aWRlcnNcbiAgICAgICAgICogQHBhcmFtIHs/fSB1c2luZ1xuICAgICAgICAgKiBAcGFyYW0gez99IHByb3ZpZGVyXG4gICAgICAgICAqIEBwYXJhbSB7P30gZXhhY3RNYXRjaFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgVGVzdGFiaWxpdHkucHJvdG90eXBlLmZpbmRCaW5kaW5ncyA9IGZ1bmN0aW9uICh1c2luZywgcHJvdmlkZXIsIGV4YWN0TWF0Y2gpIHtcbiAgICAgICAgICAgIC8vIFRPRE8oanVsaWVtcik6IGltcGxlbWVudC5cbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdXNpbmdcbiAgICAgICAgICogQHBhcmFtIHs/fSBwcm92aWRlclxuICAgICAgICAgKiBAcGFyYW0gez99IGV4YWN0TWF0Y2hcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFRlc3RhYmlsaXR5LnByb3RvdHlwZS5maW5kUHJvdmlkZXJzID0gZnVuY3Rpb24gKHVzaW5nLCBwcm92aWRlciwgZXhhY3RNYXRjaCkge1xuICAgICAgICAgICAgLy8gVE9ETyhqdWxpZW1yKTogaW1wbGVtZW50LlxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9O1xuICAgICAgICBUZXN0YWJpbGl0eS5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBUZXN0YWJpbGl0eS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgdHlwZTogTmdab25lLCB9LFxuICAgICAgICBdOyB9O1xuICAgICAgICByZXR1cm4gVGVzdGFiaWxpdHk7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBBIGdsb2JhbCByZWdpc3RyeSBvZiB7XFxAbGluayBUZXN0YWJpbGl0eX0gaW5zdGFuY2VzIGZvciBzcGVjaWZpYyBlbGVtZW50cy5cbiAgICAgKiBcXEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgVGVzdGFiaWxpdHlSZWdpc3RyeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFRlc3RhYmlsaXR5UmVnaXN0cnkoKSB7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9hcHBsaWNhdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBfdGVzdGFiaWxpdHlHZXR0ZXIuYWRkVG9XaW5kb3codGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdG9rZW5cbiAgICAgICAgICogQHBhcmFtIHs/fSB0ZXN0YWJpbGl0eVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgVGVzdGFiaWxpdHlSZWdpc3RyeS5wcm90b3R5cGUucmVnaXN0ZXJBcHBsaWNhdGlvbiA9IGZ1bmN0aW9uICh0b2tlbiwgdGVzdGFiaWxpdHkpIHtcbiAgICAgICAgICAgIHRoaXMuX2FwcGxpY2F0aW9ucy5zZXQodG9rZW4sIHRlc3RhYmlsaXR5KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gZWxlbVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgVGVzdGFiaWxpdHlSZWdpc3RyeS5wcm90b3R5cGUuZ2V0VGVzdGFiaWxpdHkgPSBmdW5jdGlvbiAoZWxlbSkgeyByZXR1cm4gdGhpcy5fYXBwbGljYXRpb25zLmdldChlbGVtKTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBUZXN0YWJpbGl0eVJlZ2lzdHJ5LnByb3RvdHlwZS5nZXRBbGxUZXN0YWJpbGl0aWVzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLl9hcHBsaWNhdGlvbnMudmFsdWVzKCkpOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFRlc3RhYmlsaXR5UmVnaXN0cnkucHJvdG90eXBlLmdldEFsbFJvb3RFbGVtZW50cyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEFycmF5LmZyb20odGhpcy5fYXBwbGljYXRpb25zLmtleXMoKSk7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGVsZW1cbiAgICAgICAgICogQHBhcmFtIHs/PX0gZmluZEluQW5jZXN0b3JzXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBUZXN0YWJpbGl0eVJlZ2lzdHJ5LnByb3RvdHlwZS5maW5kVGVzdGFiaWxpdHlJblRyZWUgPSBmdW5jdGlvbiAoZWxlbSwgZmluZEluQW5jZXN0b3JzKSB7XG4gICAgICAgICAgICBpZiAoZmluZEluQW5jZXN0b3JzID09PSB2b2lkIDApIHsgZmluZEluQW5jZXN0b3JzID0gdHJ1ZTsgfVxuICAgICAgICAgICAgcmV0dXJuIF90ZXN0YWJpbGl0eUdldHRlci5maW5kVGVzdGFiaWxpdHlJblRyZWUodGhpcywgZWxlbSwgZmluZEluQW5jZXN0b3JzKTtcbiAgICAgICAgfTtcbiAgICAgICAgVGVzdGFiaWxpdHlSZWdpc3RyeS5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBUZXN0YWJpbGl0eVJlZ2lzdHJ5LmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4gICAgICAgIHJldHVybiBUZXN0YWJpbGl0eVJlZ2lzdHJ5O1xuICAgIH0oKSk7XG4gICAgdmFyIF9Ob29wR2V0VGVzdGFiaWxpdHkgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBfTm9vcEdldFRlc3RhYmlsaXR5KCkge1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHJlZ2lzdHJ5XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBfTm9vcEdldFRlc3RhYmlsaXR5LnByb3RvdHlwZS5hZGRUb1dpbmRvdyA9IGZ1bmN0aW9uIChyZWdpc3RyeSkgeyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSByZWdpc3RyeVxuICAgICAgICAgKiBAcGFyYW0gez99IGVsZW1cbiAgICAgICAgICogQHBhcmFtIHs/fSBmaW5kSW5BbmNlc3RvcnNcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIF9Ob29wR2V0VGVzdGFiaWxpdHkucHJvdG90eXBlLmZpbmRUZXN0YWJpbGl0eUluVHJlZSA9IGZ1bmN0aW9uIChyZWdpc3RyeSwgZWxlbSwgZmluZEluQW5jZXN0b3JzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF9Ob29wR2V0VGVzdGFiaWxpdHk7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHtcXEBsaW5rIEdldFRlc3RhYmlsaXR5fSBpbXBsZW1lbnRhdGlvbiB1c2VkIGJ5IHRoZSBBbmd1bGFyIHRlc3RpbmcgZnJhbWV3b3JrLlxuICAgICAqIFxcQGV4cGVyaW1lbnRhbFxuICAgICAqIEBwYXJhbSB7P30gZ2V0dGVyXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRUZXN0YWJpbGl0eUdldHRlcihnZXR0ZXIpIHtcbiAgICAgICAgX3Rlc3RhYmlsaXR5R2V0dGVyID0gZ2V0dGVyO1xuICAgIH1cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBfdGVzdGFiaWxpdHlHZXR0ZXIgPSBuZXcgX05vb3BHZXRUZXN0YWJpbGl0eSgpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkMyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIF9kZXZNb2RlID0gdHJ1ZTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBfcnVuTW9kZUxvY2tlZCA9IGZhbHNlO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIF9wbGF0Zm9ybTtcbiAgICAvKipcbiAgICAgKiBEaXNhYmxlIEFuZ3VsYXIncyBkZXZlbG9wbWVudCBtb2RlLCB3aGljaCB0dXJucyBvZmYgYXNzZXJ0aW9ucyBhbmQgb3RoZXJcbiAgICAgKiBjaGVja3Mgd2l0aGluIHRoZSBmcmFtZXdvcmsuXG4gICAgICpcbiAgICAgKiBPbmUgaW1wb3J0YW50IGFzc2VydGlvbiB0aGlzIGRpc2FibGVzIHZlcmlmaWVzIHRoYXQgYSBjaGFuZ2UgZGV0ZWN0aW9uIHBhc3NcbiAgICAgKiBkb2VzIG5vdCByZXN1bHQgaW4gYWRkaXRpb25hbCBjaGFuZ2VzIHRvIGFueSBiaW5kaW5ncyAoYWxzbyBrbm93biBhc1xuICAgICAqIHVuaWRpcmVjdGlvbmFsIGRhdGEgZmxvdykuXG4gICAgICpcbiAgICAgKiBcXEBzdGFibGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVuYWJsZVByb2RNb2RlKCkge1xuICAgICAgICBpZiAoX3J1bk1vZGVMb2NrZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGVuYWJsZSBwcm9kIG1vZGUgYWZ0ZXIgcGxhdGZvcm0gc2V0dXAuJyk7XG4gICAgICAgIH1cbiAgICAgICAgX2Rldk1vZGUgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIEFuZ3VsYXIgaXMgaW4gZGV2ZWxvcG1lbnQgbW9kZS4gQWZ0ZXIgY2FsbGVkIG9uY2UsXG4gICAgICogdGhlIHZhbHVlIGlzIGxvY2tlZCBhbmQgd29uJ3QgY2hhbmdlIGFueSBtb3JlLlxuICAgICAqXG4gICAgICogQnkgZGVmYXVsdCwgdGhpcyBpcyB0cnVlLCB1bmxlc3MgYSB1c2VyIGNhbGxzIGBlbmFibGVQcm9kTW9kZWAgYmVmb3JlIGNhbGxpbmcgdGhpcy5cbiAgICAgKlxuICAgICAqIFxcQGV4cGVyaW1lbnRhbCBBUElzIHJlbGF0ZWQgdG8gYXBwbGljYXRpb24gYm9vdHN0cmFwIGFyZSBjdXJyZW50bHkgdW5kZXIgcmV2aWV3LlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNEZXZNb2RlKCkge1xuICAgICAgICBfcnVuTW9kZUxvY2tlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBfZGV2TW9kZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSB0b2tlbiBmb3IgdGhpcmQtcGFydHkgY29tcG9uZW50cyB0aGF0IGNhbiByZWdpc3RlciB0aGVtc2VsdmVzIHdpdGggTmdQcm9iZS5cbiAgICAgKlxuICAgICAqIFxcQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBOZ1Byb2JlVG9rZW4gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICAgICAqIEBwYXJhbSB7P30gdG9rZW5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIE5nUHJvYmVUb2tlbihuYW1lLCB0b2tlbikge1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTmdQcm9iZVRva2VuO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHBsYXRmb3JtLlxuICAgICAqIFBsYXRmb3JtcyBoYXZlIHRvIGJlIGVhZ2VybHkgY3JlYXRlZCB2aWEgdGhpcyBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIFxcQGV4cGVyaW1lbnRhbCBBUElzIHJlbGF0ZWQgdG8gYXBwbGljYXRpb24gYm9vdHN0cmFwIGFyZSBjdXJyZW50bHkgdW5kZXIgcmV2aWV3LlxuICAgICAqIEBwYXJhbSB7P30gaW5qZWN0b3JcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVBsYXRmb3JtKGluamVjdG9yKSB7XG4gICAgICAgIGlmIChfcGxhdGZvcm0gJiYgIV9wbGF0Zm9ybS5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlcmUgY2FuIGJlIG9ubHkgb25lIHBsYXRmb3JtLiBEZXN0cm95IHRoZSBwcmV2aW91cyBvbmUgdG8gY3JlYXRlIGEgbmV3IG9uZS4nKTtcbiAgICAgICAgfVxuICAgICAgICBfcGxhdGZvcm0gPSBpbmplY3Rvci5nZXQoUGxhdGZvcm1SZWYpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbml0cyA9IChpbmplY3Rvci5nZXQoUExBVEZPUk1fSU5JVElBTElaRVIsIG51bGwpKTtcbiAgICAgICAgaWYgKGluaXRzKVxuICAgICAgICAgICAgaW5pdHMuZm9yRWFjaChmdW5jdGlvbiAoaW5pdCkgeyByZXR1cm4gaW5pdCgpOyB9KTtcbiAgICAgICAgcmV0dXJuIF9wbGF0Zm9ybTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZhY3RvcnkgZm9yIGEgcGxhdGZvcm1cbiAgICAgKlxuICAgICAqIFxcQGV4cGVyaW1lbnRhbCBBUElzIHJlbGF0ZWQgdG8gYXBwbGljYXRpb24gYm9vdHN0cmFwIGFyZSBjdXJyZW50bHkgdW5kZXIgcmV2aWV3LlxuICAgICAqIEBwYXJhbSB7P30gcGFyZW50UGxhdGZvcm1GYWN0b3J5XG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/PX0gcHJvdmlkZXJzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVQbGF0Zm9ybUZhY3RvcnkocGFyZW50UGxhdGZvcm1GYWN0b3J5LCBuYW1lLCBwcm92aWRlcnMpIHtcbiAgICAgICAgaWYgKHByb3ZpZGVycyA9PT0gdm9pZCAwKSB7IHByb3ZpZGVycyA9IFtdOyB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1hcmtlciA9IG5ldyBPcGFxdWVUb2tlbihcIlBsYXRmb3JtOiBcIiArIG5hbWUpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGV4dHJhUHJvdmlkZXJzKSB7XG4gICAgICAgICAgICBpZiAoZXh0cmFQcm92aWRlcnMgPT09IHZvaWQgMCkgeyBleHRyYVByb3ZpZGVycyA9IFtdOyB9XG4gICAgICAgICAgICBpZiAoIWdldFBsYXRmb3JtKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50UGxhdGZvcm1GYWN0b3J5KSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudFBsYXRmb3JtRmFjdG9yeShwcm92aWRlcnMuY29uY2F0KGV4dHJhUHJvdmlkZXJzKS5jb25jYXQoeyBwcm92aWRlOiBtYXJrZXIsIHVzZVZhbHVlOiB0cnVlIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZVBsYXRmb3JtKFJlZmxlY3RpdmVJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKHByb3ZpZGVycy5jb25jYXQoZXh0cmFQcm92aWRlcnMpLmNvbmNhdCh7IHByb3ZpZGU6IG1hcmtlciwgdXNlVmFsdWU6IHRydWUgfSkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXNzZXJ0UGxhdGZvcm0obWFya2VyKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHRoYXQgdGhlcmUgY3VycmVudGx5IGlzIGEgcGxhdGZvcm1cbiAgICAgKiB3aGljaCBjb250YWlucyB0aGUgZ2l2ZW4gdG9rZW4gYXMgYSBwcm92aWRlci5cbiAgICAgKlxuICAgICAqIFxcQGV4cGVyaW1lbnRhbCBBUElzIHJlbGF0ZWQgdG8gYXBwbGljYXRpb24gYm9vdHN0cmFwIGFyZSBjdXJyZW50bHkgdW5kZXIgcmV2aWV3LlxuICAgICAqIEBwYXJhbSB7P30gcmVxdWlyZWRUb2tlblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gYXNzZXJ0UGxhdGZvcm0ocmVxdWlyZWRUb2tlbikge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwbGF0Zm9ybSA9IGdldFBsYXRmb3JtKCk7XG4gICAgICAgIGlmICghcGxhdGZvcm0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gcGxhdGZvcm0gZXhpc3RzIScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGxhdGZvcm0uaW5qZWN0b3IuZ2V0KHJlcXVpcmVkVG9rZW4sIG51bGwpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgcGxhdGZvcm0gd2l0aCBhIGRpZmZlcmVudCBjb25maWd1cmF0aW9uIGhhcyBiZWVuIGNyZWF0ZWQuIFBsZWFzZSBkZXN0cm95IGl0IGZpcnN0LicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwbGF0Zm9ybTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVzdHJveSB0aGUgZXhpc3RpbmcgcGxhdGZvcm0uXG4gICAgICpcbiAgICAgKiBcXEBleHBlcmltZW50YWwgQVBJcyByZWxhdGVkIHRvIGFwcGxpY2F0aW9uIGJvb3RzdHJhcCBhcmUgY3VycmVudGx5IHVuZGVyIHJldmlldy5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlc3Ryb3lQbGF0Zm9ybSgpIHtcbiAgICAgICAgaWYgKF9wbGF0Zm9ybSAmJiAhX3BsYXRmb3JtLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgX3BsYXRmb3JtLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHBsYXRmb3JtLlxuICAgICAqXG4gICAgICogXFxAZXhwZXJpbWVudGFsIEFQSXMgcmVsYXRlZCB0byBhcHBsaWNhdGlvbiBib290c3RyYXAgYXJlIGN1cnJlbnRseSB1bmRlciByZXZpZXcuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRQbGF0Zm9ybSgpIHtcbiAgICAgICAgcmV0dXJuIF9wbGF0Zm9ybSAmJiAhX3BsYXRmb3JtLmRlc3Ryb3llZCA/IF9wbGF0Zm9ybSA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBBbmd1bGFyIHBsYXRmb3JtIGlzIHRoZSBlbnRyeSBwb2ludCBmb3IgQW5ndWxhciBvbiBhIHdlYiBwYWdlLiBFYWNoIHBhZ2VcbiAgICAgKiBoYXMgZXhhY3RseSBvbmUgcGxhdGZvcm0sIGFuZCBzZXJ2aWNlcyAoc3VjaCBhcyByZWZsZWN0aW9uKSB3aGljaCBhcmUgY29tbW9uXG4gICAgICogdG8gZXZlcnkgQW5ndWxhciBhcHBsaWNhdGlvbiBydW5uaW5nIG9uIHRoZSBwYWdlIGFyZSBib3VuZCBpbiBpdHMgc2NvcGUuXG4gICAgICpcbiAgICAgKiBBIHBhZ2UncyBwbGF0Zm9ybSBpcyBpbml0aWFsaXplZCBpbXBsaWNpdGx5IHdoZW4ge1xcQGxpbmsgYm9vdHN0cmFwfSgpIGlzIGNhbGxlZCwgb3JcbiAgICAgKiBleHBsaWNpdGx5IGJ5IGNhbGxpbmcge1xcQGxpbmsgY3JlYXRlUGxhdGZvcm19KCkuXG4gICAgICpcbiAgICAgKiBcXEBzdGFibGVcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICB2YXIgUGxhdGZvcm1SZWYgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBQbGF0Zm9ybVJlZigpIHtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBhbiBgXFxATmdNb2R1bGVgIGZvciB0aGUgZ2l2ZW4gcGxhdGZvcm1cbiAgICAgICAgICogZm9yIG9mZmxpbmUgY29tcGlsYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIFNpbXBsZSBFeGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgICAgICogbXlfbW9kdWxlLnRzOlxuICAgICAgICAgKlxuICAgICAgICAgKiBcXEBOZ01vZHVsZSh7XG4gICAgICAgICAqICAgaW1wb3J0czogW0Jyb3dzZXJNb2R1bGVdXG4gICAgICAgICAqIH0pXG4gICAgICAgICAqIGNsYXNzIE15TW9kdWxlIHt9XG4gICAgICAgICAqXG4gICAgICAgICAqIG1haW4udHM6XG4gICAgICAgICAqIGltcG9ydCB7TXlNb2R1bGVOZ0ZhY3Rvcnl9IGZyb20gJy4vbXlfbW9kdWxlLm5nZmFjdG9yeSc7XG4gICAgICAgICAqIGltcG9ydCB7cGxhdGZvcm1Ccm93c2VyfSBmcm9tICdcXEBhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInO1xuICAgICAgICAgKlxuICAgICAgICAgKiBsZXQgbW9kdWxlUmVmID0gcGxhdGZvcm1Ccm93c2VyKCkuYm9vdHN0cmFwTW9kdWxlRmFjdG9yeShNeU1vZHVsZU5nRmFjdG9yeSk7XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKlxuICAgICAgICAgKiBcXEBleHBlcmltZW50YWwgQVBJcyByZWxhdGVkIHRvIGFwcGxpY2F0aW9uIGJvb3RzdHJhcCBhcmUgY3VycmVudGx5IHVuZGVyIHJldmlldy5cbiAgICAgICAgICogQHBhcmFtIHs/fSBtb2R1bGVGYWN0b3J5XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBQbGF0Zm9ybVJlZi5wcm90b3R5cGUuYm9vdHN0cmFwTW9kdWxlRmFjdG9yeSA9IGZ1bmN0aW9uIChtb2R1bGVGYWN0b3J5KSB7XG4gICAgICAgICAgICB0aHJvdyB1bmltcGxlbWVudGVkKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGFuIGBcXEBOZ01vZHVsZWAgZm9yIGEgZ2l2ZW4gcGxhdGZvcm0gdXNpbmcgdGhlIGdpdmVuIHJ1bnRpbWUgY29tcGlsZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIFNpbXBsZSBFeGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgICAgICogXFxATmdNb2R1bGUoe1xuICAgICAgICAgKiAgIGltcG9ydHM6IFtCcm93c2VyTW9kdWxlXVxuICAgICAgICAgKiB9KVxuICAgICAgICAgKiBjbGFzcyBNeU1vZHVsZSB7fVxuICAgICAgICAgKlxuICAgICAgICAgKiBsZXQgbW9kdWxlUmVmID0gcGxhdGZvcm1Ccm93c2VyKCkuYm9vdHN0cmFwTW9kdWxlKE15TW9kdWxlKTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqIFxcQHN0YWJsZVxuICAgICAgICAgKiBAcGFyYW0gez99IG1vZHVsZVR5cGVcbiAgICAgICAgICogQHBhcmFtIHs/PX0gY29tcGlsZXJPcHRpb25zXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBQbGF0Zm9ybVJlZi5wcm90b3R5cGUuYm9vdHN0cmFwTW9kdWxlID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUsIGNvbXBpbGVyT3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKGNvbXBpbGVyT3B0aW9ucyA9PT0gdm9pZCAwKSB7IGNvbXBpbGVyT3B0aW9ucyA9IFtdOyB9XG4gICAgICAgICAgICB0aHJvdyB1bmltcGxlbWVudGVkKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWdpc3RlciBhIGxpc3RlbmVyIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBwbGF0Zm9ybSBpcyBkaXNwb3NlZC5cbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqIEBwYXJhbSB7P30gY2FsbGJhY2tcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFBsYXRmb3JtUmVmLnByb3RvdHlwZS5vbkRlc3Ryb3kgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHsgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBsYXRmb3JtUmVmLnByb3RvdHlwZSwgXCJpbmplY3RvclwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHJpZXZlIHRoZSBwbGF0Zm9ybSB7XFxAbGluayBJbmplY3Rvcn0sIHdoaWNoIGlzIHRoZSBwYXJlbnQgaW5qZWN0b3IgZm9yXG4gICAgICAgICAgICAgKiBldmVyeSBBbmd1bGFyIGFwcGxpY2F0aW9uIG9uIHRoZSBwYWdlIGFuZCBwcm92aWRlcyBzaW5nbGV0b24gcHJvdmlkZXJzLlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHRocm93IHVuaW1wbGVtZW50ZWQoKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlc3Ryb3kgdGhlIEFuZ3VsYXIgcGxhdGZvcm0gYW5kIGFsbCBBbmd1bGFyIGFwcGxpY2F0aW9ucyBvbiB0aGUgcGFnZS5cbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBQbGF0Zm9ybVJlZi5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBsYXRmb3JtUmVmLnByb3RvdHlwZSwgXCJkZXN0cm95ZWRcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgdGhyb3cgdW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFBsYXRmb3JtUmVmO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlcnJvckhhbmRsZXJcbiAgICAgKiBAcGFyYW0gez99IGNhbGxiYWNrXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfY2FsbEFuZFJlcG9ydFRvRXJyb3JIYW5kbGVyKGVycm9ySGFuZGxlciwgY2FsbGJhY2spIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBpZiAoaXNQcm9taXNlKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LmNhdGNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ySGFuZGxlci5oYW5kbGVFcnJvcihlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmV0aHJvdyBhcyB0aGUgZXhjZXB0aW9uIGhhbmRsZXIgbWlnaHQgbm90IGRvIGl0XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBlcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoZSk7XG4gICAgICAgICAgICAvLyByZXRocm93IGFzIHRoZSBleGNlcHRpb24gaGFuZGxlciBtaWdodCBub3QgZG8gaXRcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIFBsYXRmb3JtUmVmXyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQzKFBsYXRmb3JtUmVmXywgX3N1cGVyKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gX2luamVjdG9yXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBQbGF0Zm9ybVJlZl8oX2luamVjdG9yKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX2luamVjdG9yID0gX2luamVjdG9yO1xuICAgICAgICAgICAgdGhpcy5fbW9kdWxlcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fZGVzdHJveUxpc3RlbmVycyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gY2FsbGJhY2tcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFBsYXRmb3JtUmVmXy5wcm90b3R5cGUub25EZXN0cm95ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7IHRoaXMuX2Rlc3Ryb3lMaXN0ZW5lcnMucHVzaChjYWxsYmFjayk7IH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQbGF0Zm9ybVJlZl8ucHJvdG90eXBlLCBcImluamVjdG9yXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9pbmplY3RvcjsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQbGF0Zm9ybVJlZl8ucHJvdG90eXBlLCBcImRlc3Ryb3llZFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGVzdHJveWVkOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBQbGF0Zm9ybVJlZl8ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgcGxhdGZvcm0gaGFzIGFscmVhZHkgYmVlbiBkZXN0cm95ZWQhJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9tb2R1bGVzLnNsaWNlKCkuZm9yRWFjaChmdW5jdGlvbiAobW9kdWxlKSB7IHJldHVybiBtb2R1bGUuZGVzdHJveSgpOyB9KTtcbiAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3lMaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHsgcmV0dXJuIGxpc3RlbmVyKCk7IH0pO1xuICAgICAgICAgICAgdGhpcy5fZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gbW9kdWxlRmFjdG9yeVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgUGxhdGZvcm1SZWZfLnByb3RvdHlwZS5ib290c3RyYXBNb2R1bGVGYWN0b3J5ID0gZnVuY3Rpb24gKG1vZHVsZUZhY3RvcnkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ib290c3RyYXBNb2R1bGVGYWN0b3J5V2l0aFpvbmUobW9kdWxlRmFjdG9yeSwgbnVsbCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IG1vZHVsZUZhY3RvcnlcbiAgICAgICAgICogQHBhcmFtIHs/fSBuZ1pvbmVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFBsYXRmb3JtUmVmXy5wcm90b3R5cGUuX2Jvb3RzdHJhcE1vZHVsZUZhY3RvcnlXaXRoWm9uZSA9IGZ1bmN0aW9uIChtb2R1bGVGYWN0b3J5LCBuZ1pvbmUpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAvLyBOb3RlOiBXZSBuZWVkIHRvIGNyZWF0ZSB0aGUgTmdab25lIF9iZWZvcmVfIHdlIGluc3RhbnRpYXRlIHRoZSBtb2R1bGUsXG4gICAgICAgICAgICAvLyBhcyBpbnN0YW50aWF0aW5nIHRoZSBtb2R1bGUgY3JlYXRlcyBzb21lIHByb3ZpZGVycyBlYWdlcmx5LlxuICAgICAgICAgICAgLy8gU28gd2UgY3JlYXRlIGEgbWluaSBwYXJlbnQgaW5qZWN0b3IgdGhhdCBqdXN0IGNvbnRhaW5zIHRoZSBuZXcgTmdab25lIGFuZFxuICAgICAgICAgICAgLy8gcGFzcyB0aGF0IGFzIHBhcmVudCB0byB0aGUgTmdNb2R1bGVGYWN0b3J5LlxuICAgICAgICAgICAgaWYgKCFuZ1pvbmUpXG4gICAgICAgICAgICAgICAgbmdab25lID0gbmV3IE5nWm9uZSh7IGVuYWJsZUxvbmdTdGFja1RyYWNlOiBpc0Rldk1vZGUoKSB9KTtcbiAgICAgICAgICAgIC8vIEF0dGVudGlvbjogRG9uJ3QgdXNlIEFwcGxpY2F0aW9uUmVmLnJ1biBoZXJlLFxuICAgICAgICAgICAgLy8gYXMgd2Ugd2FudCB0byBiZSBzdXJlIHRoYXQgYWxsIHBvc3NpYmxlIGNvbnN0cnVjdG9yIGNhbGxzIGFyZSBpbnNpZGUgYG5nWm9uZS5ydW5gIVxuICAgICAgICAgICAgcmV0dXJuIG5nWm9uZS5ydW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5nWm9uZUluamVjdG9yID0gUmVmbGVjdGl2ZUluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW3sgcHJvdmlkZTogTmdab25lLCB1c2VWYWx1ZTogbmdab25lIH1dLCBfdGhpcy5pbmplY3Rvcik7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbW9kdWxlUmVmID0gKG1vZHVsZUZhY3RvcnkuY3JlYXRlKG5nWm9uZUluamVjdG9yKSk7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXhjZXB0aW9uSGFuZGxlciA9IG1vZHVsZVJlZi5pbmplY3Rvci5nZXQoRXJyb3JIYW5kbGVyLCBudWxsKTtcbiAgICAgICAgICAgICAgICBpZiAoIWV4Y2VwdGlvbkhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBFcnJvckhhbmRsZXIuIElzIHBsYXRmb3JtIG1vZHVsZSAoQnJvd3Nlck1vZHVsZSkgaW5jbHVkZWQ/Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1vZHVsZVJlZi5vbkRlc3Ryb3koZnVuY3Rpb24gKCkgeyByZXR1cm4gTGlzdFdyYXBwZXIucmVtb3ZlKF90aGlzLl9tb2R1bGVzLCBtb2R1bGVSZWYpOyB9KTtcbiAgICAgICAgICAgICAgICBuZ1pvbmUub25FcnJvci5zdWJzY3JpYmUoeyBuZXh0OiBmdW5jdGlvbiAoZXJyb3IpIHsgZXhjZXB0aW9uSGFuZGxlci5oYW5kbGVFcnJvcihlcnJvcik7IH0gfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jYWxsQW5kUmVwb3J0VG9FcnJvckhhbmRsZXIoZXhjZXB0aW9uSGFuZGxlciwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbml0U3RhdHVzID0gbW9kdWxlUmVmLmluamVjdG9yLmdldChBcHBsaWNhdGlvbkluaXRTdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5pdFN0YXR1cy5kb25lUHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9tb2R1bGVEb0Jvb3RzdHJhcChtb2R1bGVSZWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vZHVsZVJlZjtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gbW9kdWxlVHlwZVxuICAgICAgICAgKiBAcGFyYW0gez89fSBjb21waWxlck9wdGlvbnNcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFBsYXRmb3JtUmVmXy5wcm90b3R5cGUuYm9vdHN0cmFwTW9kdWxlID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUsIGNvbXBpbGVyT3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKGNvbXBpbGVyT3B0aW9ucyA9PT0gdm9pZCAwKSB7IGNvbXBpbGVyT3B0aW9ucyA9IFtdOyB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYm9vdHN0cmFwTW9kdWxlV2l0aFpvbmUobW9kdWxlVHlwZSwgY29tcGlsZXJPcHRpb25zLCBudWxsKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gbW9kdWxlVHlwZVxuICAgICAgICAgKiBAcGFyYW0gez89fSBjb21waWxlck9wdGlvbnNcbiAgICAgICAgICogQHBhcmFtIHs/fSBuZ1pvbmVcbiAgICAgICAgICogQHBhcmFtIHs/PX0gY29tcG9uZW50RmFjdG9yeUNhbGxiYWNrXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBQbGF0Zm9ybVJlZl8ucHJvdG90eXBlLl9ib290c3RyYXBNb2R1bGVXaXRoWm9uZSA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlLCBjb21waWxlck9wdGlvbnMsIG5nWm9uZSwgY29tcG9uZW50RmFjdG9yeUNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKGNvbXBpbGVyT3B0aW9ucyA9PT0gdm9pZCAwKSB7IGNvbXBpbGVyT3B0aW9ucyA9IFtdOyB9XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb21waWxlckZhY3RvcnkgPSB0aGlzLmluamVjdG9yLmdldChDb21waWxlckZhY3RvcnkpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29tcGlsZXIgPSBjb21waWxlckZhY3RvcnkuY3JlYXRlQ29tcGlsZXIoQXJyYXkuaXNBcnJheShjb21waWxlck9wdGlvbnMpID8gY29tcGlsZXJPcHRpb25zIDogW2NvbXBpbGVyT3B0aW9uc10pO1xuICAgICAgICAgICAgLy8gdWdseSBpbnRlcm5hbCBhcGkgaGFjazogZ2VuZXJhdGUgaG9zdCBjb21wb25lbnQgZmFjdG9yaWVzIGZvciBhbGwgZGVjbGFyZWQgY29tcG9uZW50cyBhbmRcbiAgICAgICAgICAgIC8vIHBhc3MgdGhlIGZhY3RvcmllcyBpbnRvIHRoZSBjYWxsYmFjayAtIHRoaXMgaXMgdXNlZCBieSBVcGRhdGVBZGFwdGVyIHRvIGdldCBob2xkIG9mIGFsbFxuICAgICAgICAgICAgLy8gZmFjdG9yaWVzLlxuICAgICAgICAgICAgaWYgKGNvbXBvbmVudEZhY3RvcnlDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21waWxlci5jb21waWxlTW9kdWxlQW5kQWxsQ29tcG9uZW50c0FzeW5jKG1vZHVsZVR5cGUpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmdNb2R1bGVGYWN0b3J5ID0gX2EubmdNb2R1bGVGYWN0b3J5LCBjb21wb25lbnRGYWN0b3JpZXMgPSBfYS5jb21wb25lbnRGYWN0b3JpZXM7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZhY3RvcnlDYWxsYmFjayhjb21wb25lbnRGYWN0b3JpZXMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX2Jvb3RzdHJhcE1vZHVsZUZhY3RvcnlXaXRoWm9uZShuZ01vZHVsZUZhY3RvcnksIG5nWm9uZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29tcGlsZXIuY29tcGlsZU1vZHVsZUFzeW5jKG1vZHVsZVR5cGUpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKG1vZHVsZUZhY3RvcnkpIHsgcmV0dXJuIF90aGlzLl9ib290c3RyYXBNb2R1bGVGYWN0b3J5V2l0aFpvbmUobW9kdWxlRmFjdG9yeSwgbmdab25lKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IG1vZHVsZVJlZlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgUGxhdGZvcm1SZWZfLnByb3RvdHlwZS5fbW9kdWxlRG9Cb290c3RyYXAgPSBmdW5jdGlvbiAobW9kdWxlUmVmKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhcHBSZWYgPSBtb2R1bGVSZWYuaW5qZWN0b3IuZ2V0KEFwcGxpY2F0aW9uUmVmKTtcbiAgICAgICAgICAgIGlmIChtb2R1bGVSZWYuYm9vdHN0cmFwRmFjdG9yaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVSZWYuYm9vdHN0cmFwRmFjdG9yaWVzLmZvckVhY2goZnVuY3Rpb24gKGNvbXBGYWN0b3J5KSB7IHJldHVybiBhcHBSZWYuYm9vdHN0cmFwKGNvbXBGYWN0b3J5KTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtb2R1bGVSZWYuaW5zdGFuY2UubmdEb0Jvb3RzdHJhcCkge1xuICAgICAgICAgICAgICAgIG1vZHVsZVJlZi5pbnN0YW5jZS5uZ0RvQm9vdHN0cmFwKGFwcFJlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKFwiVGhlIG1vZHVsZSBcIiArIHN0cmluZ2lmeShtb2R1bGVSZWYuaW5zdGFuY2UuY29uc3RydWN0b3IpICsgXCIgd2FzIGJvb3RzdHJhcHBlZCwgYnV0IGl0IGRvZXMgbm90IGRlY2xhcmUgXFxcIkBOZ01vZHVsZS5ib290c3RyYXBcXFwiIGNvbXBvbmVudHMgbm9yIGEgXFxcIm5nRG9Cb290c3RyYXBcXFwiIG1ldGhvZC4gXCIpICtcbiAgICAgICAgICAgICAgICAgICAgXCJQbGVhc2UgZGVmaW5lIG9uZSBvZiB0aGVzZS5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFBsYXRmb3JtUmVmXy5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBQbGF0Zm9ybVJlZl8uY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgICAgICB7IHR5cGU6IEluamVjdG9yLCB9LFxuICAgICAgICBdOyB9O1xuICAgICAgICByZXR1cm4gUGxhdGZvcm1SZWZfO1xuICAgIH0oUGxhdGZvcm1SZWYpKTtcbiAgICAvKipcbiAgICAgKiBBIHJlZmVyZW5jZSB0byBhbiBBbmd1bGFyIGFwcGxpY2F0aW9uIHJ1bm5pbmcgb24gYSBwYWdlLlxuICAgICAqXG4gICAgICogRm9yIG1vcmUgYWJvdXQgQW5ndWxhciBhcHBsaWNhdGlvbnMsIHNlZSB0aGUgZG9jdW1lbnRhdGlvbiBmb3Ige1xcQGxpbmsgYm9vdHN0cmFwfS5cbiAgICAgKlxuICAgICAqIFxcQHN0YWJsZVxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICAgIHZhciBBcHBsaWNhdGlvblJlZiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFwcGxpY2F0aW9uUmVmKCkge1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCb290c3RyYXAgYSBuZXcgY29tcG9uZW50IGF0IHRoZSByb290IGxldmVsIG9mIHRoZSBhcHBsaWNhdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIEJvb3RzdHJhcCBwcm9jZXNzXG4gICAgICAgICAqXG4gICAgICAgICAqIFdoZW4gYm9vdHN0cmFwcGluZyBhIG5ldyByb290IGNvbXBvbmVudCBpbnRvIGFuIGFwcGxpY2F0aW9uLCBBbmd1bGFyIG1vdW50cyB0aGVcbiAgICAgICAgICogc3BlY2lmaWVkIGFwcGxpY2F0aW9uIGNvbXBvbmVudCBvbnRvIERPTSBlbGVtZW50cyBpZGVudGlmaWVkIGJ5IHRoZSBbY29tcG9uZW50VHlwZV0nc1xuICAgICAgICAgKiBzZWxlY3RvciBhbmQga2lja3Mgb2ZmIGF1dG9tYXRpYyBjaGFuZ2UgZGV0ZWN0aW9uIHRvIGZpbmlzaCBpbml0aWFsaXppbmcgdGhlIGNvbXBvbmVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIEV4YW1wbGVcbiAgICAgICAgICoge1xcQGV4YW1wbGUgY29yZS90cy9wbGF0Zm9ybS9wbGF0Zm9ybS50cyByZWdpb249J2xvbmdmb3JtJ31cbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqIEBwYXJhbSB7P30gY29tcG9uZW50RmFjdG9yeVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQXBwbGljYXRpb25SZWYucHJvdG90eXBlLmJvb3RzdHJhcCA9IGZ1bmN0aW9uIChjb21wb25lbnRGYWN0b3J5KSB7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnZva2UgdGhpcyBtZXRob2QgdG8gZXhwbGljaXRseSBwcm9jZXNzIGNoYW5nZSBkZXRlY3Rpb24gYW5kIGl0cyBzaWRlLWVmZmVjdHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEluIGRldmVsb3BtZW50IG1vZGUsIGB0aWNrKClgIGFsc28gcGVyZm9ybXMgYSBzZWNvbmQgY2hhbmdlIGRldGVjdGlvbiBjeWNsZSB0byBlbnN1cmUgdGhhdCBub1xuICAgICAgICAgKiBmdXJ0aGVyIGNoYW5nZXMgYXJlIGRldGVjdGVkLiBJZiBhZGRpdGlvbmFsIGNoYW5nZXMgYXJlIHBpY2tlZCB1cCBkdXJpbmcgdGhpcyBzZWNvbmQgY3ljbGUsXG4gICAgICAgICAqIGJpbmRpbmdzIGluIHRoZSBhcHAgaGF2ZSBzaWRlLWVmZmVjdHMgdGhhdCBjYW5ub3QgYmUgcmVzb2x2ZWQgaW4gYSBzaW5nbGUgY2hhbmdlIGRldGVjdGlvblxuICAgICAgICAgKiBwYXNzLlxuICAgICAgICAgKiBJbiB0aGlzIGNhc2UsIEFuZ3VsYXIgdGhyb3dzIGFuIGVycm9yLCBzaW5jZSBhbiBBbmd1bGFyIGFwcGxpY2F0aW9uIGNhbiBvbmx5IGhhdmUgb25lIGNoYW5nZVxuICAgICAgICAgKiBkZXRlY3Rpb24gcGFzcyBkdXJpbmcgd2hpY2ggYWxsIGNoYW5nZSBkZXRlY3Rpb24gbXVzdCBjb21wbGV0ZS5cbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBcHBsaWNhdGlvblJlZi5wcm90b3R5cGUudGljayA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFwcGxpY2F0aW9uUmVmLnByb3RvdHlwZSwgXCJjb21wb25lbnRUeXBlc1wiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldCBhIGxpc3Qgb2YgY29tcG9uZW50IHR5cGVzIHJlZ2lzdGVyZWQgdG8gdGhpcyBhcHBsaWNhdGlvbi5cbiAgICAgICAgICAgICAqIFRoaXMgbGlzdCBpcyBwb3B1bGF0ZWQgZXZlbiBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyBjcmVhdGVkLlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiAodW5pbXBsZW1lbnRlZCgpKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIDtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFwcGxpY2F0aW9uUmVmLnByb3RvdHlwZSwgXCJjb21wb25lbnRzXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0IGEgbGlzdCBvZiBjb21wb25lbnRzIHJlZ2lzdGVyZWQgdG8gdGhpcyBhcHBsaWNhdGlvbi5cbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gKHVuaW1wbGVtZW50ZWQoKSk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBdHRhY2hlcyBhIHZpZXcgc28gdGhhdCBpdCB3aWxsIGJlIGRpcnR5IGNoZWNrZWQuXG4gICAgICAgICAqIFRoZSB2aWV3IHdpbGwgYmUgYXV0b21hdGljYWxseSBkZXRhY2hlZCB3aGVuIGl0IGlzIGRlc3Ryb3llZC5cbiAgICAgICAgICogVGhpcyB3aWxsIHRocm93IGlmIHRoZSB2aWV3IGlzIGFscmVhZHkgYXR0YWNoZWQgdG8gYSBWaWV3Q29udGFpbmVyLlxuICAgICAgICAgKiBAcGFyYW0gez99IHZpZXdcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEFwcGxpY2F0aW9uUmVmLnByb3RvdHlwZS5hdHRhY2hWaWV3ID0gZnVuY3Rpb24gKHZpZXcpIHsgdW5pbXBsZW1lbnRlZCgpOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRGV0YWNoZXMgYSB2aWV3IGZyb20gZGlydHkgY2hlY2tpbmcgYWdhaW4uXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmlld1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQXBwbGljYXRpb25SZWYucHJvdG90eXBlLmRldGFjaFZpZXcgPSBmdW5jdGlvbiAodmlldykgeyB1bmltcGxlbWVudGVkKCk7IH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcHBsaWNhdGlvblJlZi5wcm90b3R5cGUsIFwidmlld0NvdW50XCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGF0dGFjaGVkIHZpZXdzLlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmltcGxlbWVudGVkKCk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gQXBwbGljYXRpb25SZWY7XG4gICAgfSgpKTtcbiAgICB2YXIgQXBwbGljYXRpb25SZWZfID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDMoQXBwbGljYXRpb25SZWZfLCBfc3VwZXIpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBfem9uZVxuICAgICAgICAgKiBAcGFyYW0gez99IF9jb25zb2xlXG4gICAgICAgICAqIEBwYXJhbSB7P30gX2luamVjdG9yXG4gICAgICAgICAqIEBwYXJhbSB7P30gX2V4Y2VwdGlvbkhhbmRsZXJcbiAgICAgICAgICogQHBhcmFtIHs/fSBfY29tcG9uZW50RmFjdG9yeVJlc29sdmVyXG4gICAgICAgICAqIEBwYXJhbSB7P30gX2luaXRTdGF0dXNcbiAgICAgICAgICogQHBhcmFtIHs/fSBfdGVzdGFiaWxpdHlSZWdpc3RyeVxuICAgICAgICAgKiBAcGFyYW0gez99IF90ZXN0YWJpbGl0eVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gQXBwbGljYXRpb25SZWZfKF96b25lLCBfY29uc29sZSwgX2luamVjdG9yLCBfZXhjZXB0aW9uSGFuZGxlciwgX2NvbXBvbmVudEZhY3RvcnlSZXNvbHZlciwgX2luaXRTdGF0dXMsIF90ZXN0YWJpbGl0eVJlZ2lzdHJ5LCBfdGVzdGFiaWxpdHkpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX3pvbmUgPSBfem9uZTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnNvbGUgPSBfY29uc29sZTtcbiAgICAgICAgICAgIHRoaXMuX2luamVjdG9yID0gX2luamVjdG9yO1xuICAgICAgICAgICAgdGhpcy5fZXhjZXB0aW9uSGFuZGxlciA9IF9leGNlcHRpb25IYW5kbGVyO1xuICAgICAgICAgICAgdGhpcy5fY29tcG9uZW50RmFjdG9yeVJlc29sdmVyID0gX2NvbXBvbmVudEZhY3RvcnlSZXNvbHZlcjtcbiAgICAgICAgICAgIHRoaXMuX2luaXRTdGF0dXMgPSBfaW5pdFN0YXR1cztcbiAgICAgICAgICAgIHRoaXMuX3Rlc3RhYmlsaXR5UmVnaXN0cnkgPSBfdGVzdGFiaWxpdHlSZWdpc3RyeTtcbiAgICAgICAgICAgIHRoaXMuX3Rlc3RhYmlsaXR5ID0gX3Rlc3RhYmlsaXR5O1xuICAgICAgICAgICAgdGhpcy5fYm9vdHN0cmFwTGlzdGVuZXJzID0gW107XG4gICAgICAgICAgICB0aGlzLl9yb290Q29tcG9uZW50cyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fcm9vdENvbXBvbmVudFR5cGVzID0gW107XG4gICAgICAgICAgICB0aGlzLl92aWV3cyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fcnVubmluZ1RpY2sgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2VuZm9yY2VOb05ld0NoYW5nZXMgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2VuZm9yY2VOb05ld0NoYW5nZXMgPSBpc0Rldk1vZGUoKTtcbiAgICAgICAgICAgIHRoaXMuX3pvbmUub25NaWNyb3Rhc2tFbXB0eS5zdWJzY3JpYmUoeyBuZXh0OiBmdW5jdGlvbiAoKSB7IF90aGlzLl96b25lLnJ1bihmdW5jdGlvbiAoKSB7IF90aGlzLnRpY2soKTsgfSk7IH0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmlld1JlZlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQXBwbGljYXRpb25SZWZfLnByb3RvdHlwZS5hdHRhY2hWaWV3ID0gZnVuY3Rpb24gKHZpZXdSZWYpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpZXcgPSAoKHZpZXdSZWYpKS5pbnRlcm5hbFZpZXc7XG4gICAgICAgICAgICB0aGlzLl92aWV3cy5wdXNoKHZpZXcpO1xuICAgICAgICAgICAgdmlldy5hdHRhY2hUb0FwcFJlZih0aGlzKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmlld1JlZlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQXBwbGljYXRpb25SZWZfLnByb3RvdHlwZS5kZXRhY2hWaWV3ID0gZnVuY3Rpb24gKHZpZXdSZWYpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpZXcgPSAoKHZpZXdSZWYpKS5pbnRlcm5hbFZpZXc7XG4gICAgICAgICAgICBMaXN0V3JhcHBlci5yZW1vdmUodGhpcy5fdmlld3MsIHZpZXcpO1xuICAgICAgICAgICAgdmlldy5kZXRhY2goKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gY29tcG9uZW50T3JGYWN0b3J5XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBcHBsaWNhdGlvblJlZl8ucHJvdG90eXBlLmJvb3RzdHJhcCA9IGZ1bmN0aW9uIChjb21wb25lbnRPckZhY3RvcnkpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2luaXRTdGF0dXMuZG9uZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGJvb3RzdHJhcCBhcyB0aGVyZSBhcmUgc3RpbGwgYXN5bmNocm9ub3VzIGluaXRpYWxpemVycyBydW5uaW5nLiBCb290c3RyYXAgY29tcG9uZW50cyBpbiB0aGUgYG5nRG9Cb290c3RyYXBgIG1ldGhvZCBvZiB0aGUgcm9vdCBtb2R1bGUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb21wb25lbnRGYWN0b3J5O1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudE9yRmFjdG9yeSBpbnN0YW5jZW9mIENvbXBvbmVudEZhY3RvcnkpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRGYWN0b3J5ID0gY29tcG9uZW50T3JGYWN0b3J5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50RmFjdG9yeSA9IHRoaXMuX2NvbXBvbmVudEZhY3RvcnlSZXNvbHZlci5yZXNvbHZlQ29tcG9uZW50RmFjdG9yeShjb21wb25lbnRPckZhY3RvcnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcm9vdENvbXBvbmVudFR5cGVzLnB1c2goY29tcG9uZW50RmFjdG9yeS5jb21wb25lbnRUeXBlKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbXBSZWYgPSBjb21wb25lbnRGYWN0b3J5LmNyZWF0ZSh0aGlzLl9pbmplY3RvciwgW10sIGNvbXBvbmVudEZhY3Rvcnkuc2VsZWN0b3IpO1xuICAgICAgICAgICAgY29tcFJlZi5vbkRlc3Ryb3koZnVuY3Rpb24gKCkgeyBfdGhpcy5fdW5sb2FkQ29tcG9uZW50KGNvbXBSZWYpOyB9KTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRlc3RhYmlsaXR5ID0gY29tcFJlZi5pbmplY3Rvci5nZXQoVGVzdGFiaWxpdHksIG51bGwpO1xuICAgICAgICAgICAgaWYgKHRlc3RhYmlsaXR5KSB7XG4gICAgICAgICAgICAgICAgY29tcFJlZi5pbmplY3Rvci5nZXQoVGVzdGFiaWxpdHlSZWdpc3RyeSlcbiAgICAgICAgICAgICAgICAgICAgLnJlZ2lzdGVyQXBwbGljYXRpb24oY29tcFJlZi5sb2NhdGlvbi5uYXRpdmVFbGVtZW50LCB0ZXN0YWJpbGl0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9sb2FkQ29tcG9uZW50KGNvbXBSZWYpO1xuICAgICAgICAgICAgaWYgKGlzRGV2TW9kZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29uc29sZS5sb2coXCJBbmd1bGFyIGlzIHJ1bm5pbmcgaW4gdGhlIGRldmVsb3BtZW50IG1vZGUuIENhbGwgZW5hYmxlUHJvZE1vZGUoKSB0byBlbmFibGUgdGhlIHByb2R1Y3Rpb24gbW9kZS5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29tcFJlZjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gY29tcG9uZW50UmVmXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBcHBsaWNhdGlvblJlZl8ucHJvdG90eXBlLl9sb2FkQ29tcG9uZW50ID0gZnVuY3Rpb24gKGNvbXBvbmVudFJlZikge1xuICAgICAgICAgICAgdGhpcy5hdHRhY2hWaWV3KGNvbXBvbmVudFJlZi5ob3N0Vmlldyk7XG4gICAgICAgICAgICB0aGlzLnRpY2soKTtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RDb21wb25lbnRzLnB1c2goY29tcG9uZW50UmVmKTtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgbGlzdGVuZXJzIGxhemlseSB0byBwcmV2ZW50IERJIGN5Y2xlcy5cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxpc3RlbmVycyA9ICh0aGlzLl9pbmplY3Rvci5nZXQoQVBQX0JPT1RTVFJBUF9MSVNURU5FUiwgW10pXG4gICAgICAgICAgICAgICAgLmNvbmNhdCh0aGlzLl9ib290c3RyYXBMaXN0ZW5lcnMpKTtcbiAgICAgICAgICAgIGxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikgeyByZXR1cm4gbGlzdGVuZXIoY29tcG9uZW50UmVmKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGNvbXBvbmVudFJlZlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQXBwbGljYXRpb25SZWZfLnByb3RvdHlwZS5fdW5sb2FkQ29tcG9uZW50ID0gZnVuY3Rpb24gKGNvbXBvbmVudFJlZikge1xuICAgICAgICAgICAgdGhpcy5kZXRhY2hWaWV3KGNvbXBvbmVudFJlZi5ob3N0Vmlldyk7XG4gICAgICAgICAgICBMaXN0V3JhcHBlci5yZW1vdmUodGhpcy5fcm9vdENvbXBvbmVudHMsIGNvbXBvbmVudFJlZik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQXBwbGljYXRpb25SZWZfLnByb3RvdHlwZS50aWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3J1bm5pbmdUaWNrKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBcHBsaWNhdGlvblJlZi50aWNrIGlzIGNhbGxlZCByZWN1cnNpdmVseScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2NvcGUgPSBBcHBsaWNhdGlvblJlZl8uX3RpY2tTY29wZSgpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9ydW5uaW5nVGljayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmlld3MuZm9yRWFjaChmdW5jdGlvbiAodmlldykgeyByZXR1cm4gdmlldy5yZWYuZGV0ZWN0Q2hhbmdlcygpOyB9KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZW5mb3JjZU5vTmV3Q2hhbmdlcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl92aWV3cy5mb3JFYWNoKGZ1bmN0aW9uICh2aWV3KSB7IHJldHVybiB2aWV3LnJlZi5jaGVja05vQ2hhbmdlcygpOyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9ydW5uaW5nVGljayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHd0ZkxlYXZlKHNjb3BlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBcHBsaWNhdGlvblJlZl8ucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gVE9ETyhhbHhodWIpOiBEaXNwb3NlIG9mIHRoZSBOZ1pvbmUuXG4gICAgICAgICAgICB0aGlzLl92aWV3cy5zbGljZSgpLmZvckVhY2goZnVuY3Rpb24gKHZpZXcpIHsgcmV0dXJuIHZpZXcuZGVzdHJveSgpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFwcGxpY2F0aW9uUmVmXy5wcm90b3R5cGUsIFwidmlld0NvdW50XCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl92aWV3cy5sZW5ndGg7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXBwbGljYXRpb25SZWZfLnByb3RvdHlwZSwgXCJjb21wb25lbnRUeXBlc1wiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcm9vdENvbXBvbmVudFR5cGVzOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFwcGxpY2F0aW9uUmVmXy5wcm90b3R5cGUsIFwiY29tcG9uZW50c1wiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcm9vdENvbXBvbmVudHM7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEFwcGxpY2F0aW9uUmVmXy5fdGlja1Njb3BlID0gd3RmQ3JlYXRlU2NvcGUoJ0FwcGxpY2F0aW9uUmVmI3RpY2soKScpO1xuICAgICAgICBBcHBsaWNhdGlvblJlZl8uZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgQXBwbGljYXRpb25SZWZfLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICAgICAgeyB0eXBlOiBOZ1pvbmUsIH0sXG4gICAgICAgICAgICB7IHR5cGU6IENvbnNvbGUsIH0sXG4gICAgICAgICAgICB7IHR5cGU6IEluamVjdG9yLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBFcnJvckhhbmRsZXIsIH0sXG4gICAgICAgICAgICB7IHR5cGU6IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlciwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogQXBwbGljYXRpb25Jbml0U3RhdHVzLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBUZXN0YWJpbGl0eVJlZ2lzdHJ5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgICAgIHsgdHlwZTogVGVzdGFiaWxpdHksIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgICAgICBdOyB9O1xuICAgICAgICByZXR1cm4gQXBwbGljYXRpb25SZWZfO1xuICAgIH0oQXBwbGljYXRpb25SZWYpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDkgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGFuIGluc3RhbmNlIG9mIGFuIE5nTW9kdWxlIGNyZWF0ZWQgdmlhIGEge1xcQGxpbmsgTmdNb2R1bGVGYWN0b3J5fS5cbiAgICAgKlxuICAgICAqIGBOZ01vZHVsZVJlZmAgcHJvdmlkZXMgYWNjZXNzIHRvIHRoZSBOZ01vZHVsZSBJbnN0YW5jZSBhcyB3ZWxsIG90aGVyIG9iamVjdHMgcmVsYXRlZCB0byB0aGlzXG4gICAgICogTmdNb2R1bGUgSW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBcXEBzdGFibGVcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICB2YXIgTmdNb2R1bGVSZWYgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBOZ01vZHVsZVJlZigpIHtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdNb2R1bGVSZWYucHJvdG90eXBlLCBcImluamVjdG9yXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIGluamVjdG9yIHRoYXQgY29udGFpbnMgYWxsIG9mIHRoZSBwcm92aWRlcnMgb2YgdGhlIE5nTW9kdWxlLlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmltcGxlbWVudGVkKCk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdNb2R1bGVSZWYucHJvdG90eXBlLCBcImNvbXBvbmVudEZhY3RvcnlSZXNvbHZlclwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIgdG8gZ2V0IGhvbGQgb2YgdGhlIENvbXBvbmVudEZhY3Rvcmllc1xuICAgICAgICAgICAgICogZGVjbGFyZWQgaW4gdGhlIGBlbnRyeUNvbXBvbmVudHNgIHByb3BlcnR5IG9mIHRoZSBtb2R1bGUuXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaW1wbGVtZW50ZWQoKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ01vZHVsZVJlZi5wcm90b3R5cGUsIFwiaW5zdGFuY2VcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgTmdNb2R1bGUgaW5zdGFuY2UuXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaW1wbGVtZW50ZWQoKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXN0cm95cyB0aGUgbW9kdWxlIGluc3RhbmNlIGFuZCBhbGwgb2YgdGhlIGRhdGEgc3RydWN0dXJlcyBhc3NvY2lhdGVkIHdpdGggaXQuXG4gICAgICAgICAqIEBhYnN0cmFjdFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgTmdNb2R1bGVSZWYucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGxvd3MgdG8gcmVnaXN0ZXIgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIG1vZHVsZSBpcyBkZXN0cm95ZWQuXG4gICAgICAgICAqIEBhYnN0cmFjdFxuICAgICAgICAgKiBAcGFyYW0gez99IGNhbGxiYWNrXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBOZ01vZHVsZVJlZi5wcm90b3R5cGUub25EZXN0cm95ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7IH07XG4gICAgICAgIHJldHVybiBOZ01vZHVsZVJlZjtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIFxcQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBOZ01vZHVsZUZhY3RvcnkgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBfaW5qZWN0b3JDbGFzc1xuICAgICAgICAgKiBAcGFyYW0gez99IF9tb2R1bGVUeXBlXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBOZ01vZHVsZUZhY3RvcnkoX2luamVjdG9yQ2xhc3MsIF9tb2R1bGVUeXBlKSB7XG4gICAgICAgICAgICB0aGlzLl9pbmplY3RvckNsYXNzID0gX2luamVjdG9yQ2xhc3M7XG4gICAgICAgICAgICB0aGlzLl9tb2R1bGVUeXBlID0gX21vZHVsZVR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nTW9kdWxlRmFjdG9yeS5wcm90b3R5cGUsIFwibW9kdWxlVHlwZVwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbW9kdWxlVHlwZTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHBhcmVudEluamVjdG9yXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBOZ01vZHVsZUZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uIChwYXJlbnRJbmplY3Rvcikge1xuICAgICAgICAgICAgaWYgKCFwYXJlbnRJbmplY3Rvcikge1xuICAgICAgICAgICAgICAgIHBhcmVudEluamVjdG9yID0gSW5qZWN0b3IuTlVMTDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGluc3RhbmNlID0gbmV3IHRoaXMuX2luamVjdG9yQ2xhc3MocGFyZW50SW5qZWN0b3IpO1xuICAgICAgICAgICAgaW5zdGFuY2UuY3JlYXRlKCk7XG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBOZ01vZHVsZUZhY3Rvcnk7XG4gICAgfSgpKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBfVU5ERUZJTkVEID0gbmV3IE9iamVjdCgpO1xuICAgIC8qKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICAgIHZhciBOZ01vZHVsZUluamVjdG9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDkoTmdNb2R1bGVJbmplY3RvciwgX3N1cGVyKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gcGFyZW50XG4gICAgICAgICAqIEBwYXJhbSB7P30gZmFjdG9yaWVzXG4gICAgICAgICAqIEBwYXJhbSB7P30gYm9vdHN0cmFwRmFjdG9yaWVzXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBOZ01vZHVsZUluamVjdG9yKHBhcmVudCwgZmFjdG9yaWVzLCBib290c3RyYXBGYWN0b3JpZXMpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGZhY3RvcmllcywgcGFyZW50LmdldChDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlci5OVUxMKSk7XG4gICAgICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgICAgIHRoaXMuYm9vdHN0cmFwRmFjdG9yaWVzID0gYm9vdHN0cmFwRmFjdG9yaWVzO1xuICAgICAgICAgICAgdGhpcy5fZGVzdHJveUxpc3RlbmVycyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBOZ01vZHVsZUluamVjdG9yLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7IHRoaXMuaW5zdGFuY2UgPSB0aGlzLmNyZWF0ZUludGVybmFsKCk7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAYWJzdHJhY3RcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIE5nTW9kdWxlSW5qZWN0b3IucHJvdG90eXBlLmNyZWF0ZUludGVybmFsID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB0b2tlblxuICAgICAgICAgKiBAcGFyYW0gez89fSBub3RGb3VuZFZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBOZ01vZHVsZUluamVjdG9yLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodG9rZW4sIG5vdEZvdW5kVmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChub3RGb3VuZFZhbHVlID09PSB2b2lkIDApIHsgbm90Rm91bmRWYWx1ZSA9IFRIUk9XX0lGX05PVF9GT1VORDsgfVxuICAgICAgICAgICAgaWYgKHRva2VuID09PSBJbmplY3RvciB8fCB0b2tlbiA9PT0gQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSB0aGlzLmdldEludGVybmFsKHRva2VuLCBfVU5ERUZJTkVEKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgPT09IF9VTkRFRklORUQgPyB0aGlzLnBhcmVudC5nZXQodG9rZW4sIG5vdEZvdW5kVmFsdWUpIDogcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqIEBwYXJhbSB7P30gdG9rZW5cbiAgICAgICAgICogQHBhcmFtIHs/fSBub3RGb3VuZFZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBOZ01vZHVsZUluamVjdG9yLnByb3RvdHlwZS5nZXRJbnRlcm5hbCA9IGZ1bmN0aW9uICh0b2tlbiwgbm90Rm91bmRWYWx1ZSkgeyB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdNb2R1bGVJbmplY3Rvci5wcm90b3R5cGUsIFwiaW5qZWN0b3JcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdNb2R1bGVJbmplY3Rvci5wcm90b3R5cGUsIFwiY29tcG9uZW50RmFjdG9yeVJlc29sdmVyXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBOZ01vZHVsZUluamVjdG9yLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2Rlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBuZyBtb2R1bGUgXCIgKyBzdHJpbmdpZnkodGhpcy5pbnN0YW5jZS5jb25zdHJ1Y3RvcikgKyBcIiBoYXMgYWxyZWFkeSBiZWVuIGRlc3Ryb3llZC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5kZXN0cm95SW50ZXJuYWwoKTtcbiAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3lMaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHsgcmV0dXJuIGxpc3RlbmVyKCk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBjYWxsYmFja1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgTmdNb2R1bGVJbmplY3Rvci5wcm90b3R5cGUub25EZXN0cm95ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7IHRoaXMuX2Rlc3Ryb3lMaXN0ZW5lcnMucHVzaChjYWxsYmFjayk7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAYWJzdHJhY3RcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIE5nTW9kdWxlSW5qZWN0b3IucHJvdG90eXBlLmRlc3Ryb3lJbnRlcm5hbCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgcmV0dXJuIE5nTW9kdWxlSW5qZWN0b3I7XG4gICAgfShDb2RlZ2VuQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgLyoqXG4gICAgICogVXNlZCB0byBsb2FkIG5nIG1vZHVsZSBmYWN0b3JpZXMuXG4gICAgICogXFxAc3RhYmxlXG4gICAgICogQGFic3RyYWN0XG4gICAgICovXG4gICAgdmFyIE5nTW9kdWxlRmFjdG9yeUxvYWRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE5nTW9kdWxlRmFjdG9yeUxvYWRlcigpIHtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqIEBwYXJhbSB7P30gcGF0aFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgTmdNb2R1bGVGYWN0b3J5TG9hZGVyLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKHBhdGgpIHsgfTtcbiAgICAgICAgcmV0dXJuIE5nTW9kdWxlRmFjdG9yeUxvYWRlcjtcbiAgICB9KCkpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIG1vZHVsZUZhY3RvcmllcyA9IG5ldyBNYXAoKTtcbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBsb2FkZWQgbW9kdWxlLiBTaG91bGQgb25seSBiZSBjYWxsZWQgZnJvbSBnZW5lcmF0ZWQgTmdNb2R1bGVGYWN0b3J5IGNvZGUuXG4gICAgICogXFxAZXhwZXJpbWVudGFsXG4gICAgICogQHBhcmFtIHs/fSBpZFxuICAgICAqIEBwYXJhbSB7P30gZmFjdG9yeVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJNb2R1bGVGYWN0b3J5KGlkLCBmYWN0b3J5KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4aXN0aW5nID0gbW9kdWxlRmFjdG9yaWVzLmdldChpZCk7XG4gICAgICAgIGlmIChleGlzdGluZykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIG1vZHVsZSByZWdpc3RlcmVkIGZvciBcIiArIGlkICsgXCIgLSBcIiArIGV4aXN0aW5nLm1vZHVsZVR5cGUubmFtZSArIFwiIHZzIFwiICsgZmFjdG9yeS5tb2R1bGVUeXBlLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIG1vZHVsZUZhY3Rvcmllcy5zZXQoaWQsIGZhY3RvcnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBOZ01vZHVsZUZhY3Rvcnkgd2l0aCB0aGUgZ2l2ZW4gaWQsIGlmIGl0IGV4aXN0cyBhbmQgaGFzIGJlZW4gbG9hZGVkLlxuICAgICAqIEZhY3RvcmllcyBmb3IgbW9kdWxlcyB0aGF0IGRvIG5vdCBzcGVjaWZ5IGFuIGBpZGAgY2Fubm90IGJlIHJldHJpZXZlZC4gVGhyb3dzIGlmIHRoZSBtb2R1bGVcbiAgICAgKiBjYW5ub3QgYmUgZm91bmQuXG4gICAgICogXFxAZXhwZXJpbWVudGFsXG4gICAgICogQHBhcmFtIHs/fSBpZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0TW9kdWxlRmFjdG9yeShpZCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmYWN0b3J5ID0gbW9kdWxlRmFjdG9yaWVzLmdldChpZCk7XG4gICAgICAgIGlmICghZmFjdG9yeSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIG1vZHVsZSB3aXRoIElEIFwiICsgaWQgKyBcIiBsb2FkZWRcIik7XG4gICAgICAgIHJldHVybiBmYWN0b3J5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuIHVubW9kaWZpYWJsZSBsaXN0IG9mIGl0ZW1zIHRoYXQgQW5ndWxhciBrZWVwcyB1cCB0byBkYXRlIHdoZW4gdGhlIHN0YXRlXG4gICAgICogb2YgdGhlIGFwcGxpY2F0aW9uIGNoYW5nZXMuXG4gICAgICpcbiAgICAgKiBUaGUgdHlwZSBvZiBvYmplY3QgdGhhdCB7XFxAbGluayBRdWVyeX0gYW5kIHtcXEBsaW5rIFZpZXdRdWVyeU1ldGFkYXRhfSBwcm92aWRlLlxuICAgICAqXG4gICAgICogSW1wbGVtZW50cyBhbiBpdGVyYWJsZSBpbnRlcmZhY2UsIHRoZXJlZm9yZSBpdCBjYW4gYmUgdXNlZCBpbiBib3RoIEVTNlxuICAgICAqIGphdmFzY3JpcHQgYGZvciAodmFyIGkgb2YgaXRlbXMpYCBsb29wcyBhcyB3ZWxsIGFzIGluIEFuZ3VsYXIgdGVtcGxhdGVzIHdpdGhcbiAgICAgKiBgKm5nRm9yPVwibGV0IGkgb2YgbXlMaXN0XCJgLlxuICAgICAqXG4gICAgICogQ2hhbmdlcyBjYW4gYmUgb2JzZXJ2ZWQgYnkgc3Vic2NyaWJpbmcgdG8gdGhlIGNoYW5nZXMgYE9ic2VydmFibGVgLlxuICAgICAqXG4gICAgICogTk9URTogSW4gdGhlIGZ1dHVyZSB0aGlzIGNsYXNzIHdpbGwgaW1wbGVtZW50IGFuIGBPYnNlcnZhYmxlYCBpbnRlcmZhY2UuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvUlg4c0puUVlsOUZXdVNDV21lNXo/cD1wcmV2aWV3KSlcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogXFxAQ29tcG9uZW50KHsuLi59KVxuICAgICAqIGNsYXNzIENvbnRhaW5lciB7XG4gICAgICogICBcXEBWaWV3Q2hpbGRyZW4oSXRlbSkgaXRlbXM6UXVlcnlMaXN0PEl0ZW0+O1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKiBcXEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgUXVlcnlMaXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUXVlcnlMaXN0KCkge1xuICAgICAgICAgICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fZW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUXVlcnlMaXN0LnByb3RvdHlwZSwgXCJjaGFuZ2VzXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9lbWl0dGVyOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFF1ZXJ5TGlzdC5wcm90b3R5cGUsIFwibGVuZ3RoXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9yZXN1bHRzLmxlbmd0aDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShRdWVyeUxpc3QucHJvdG90eXBlLCBcImZpcnN0XCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9yZXN1bHRzWzBdOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFF1ZXJ5TGlzdC5wcm90b3R5cGUsIFwibGFzdFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcmVzdWx0c1t0aGlzLmxlbmd0aCAtIDFdOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlZVxuICAgICAgICAgKiBbQXJyYXkubWFwXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9tYXApXG4gICAgICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFF1ZXJ5TGlzdC5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gKGZuKSB7IHJldHVybiB0aGlzLl9yZXN1bHRzLm1hcChmbik7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZWVcbiAgICAgICAgICogW0FycmF5LmZpbHRlcl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvZmlsdGVyKVxuICAgICAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBRdWVyeUxpc3QucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc3VsdHMuZmlsdGVyKGZuKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlZVxuICAgICAgICAgKiBbQXJyYXkuZmluZF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvZmluZClcbiAgICAgICAgICogQHBhcmFtIHs/fSBmblxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgUXVlcnlMaXN0LnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKGZuKSB7IHJldHVybiB0aGlzLl9yZXN1bHRzLmZpbmQoZm4pOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2VlXG4gICAgICAgICAqIFtBcnJheS5yZWR1Y2VdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3JlZHVjZSlcbiAgICAgICAgICogQHBhcmFtIHs/fSBmblxuICAgICAgICAgKiBAcGFyYW0gez99IGluaXRcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFF1ZXJ5TGlzdC5wcm90b3R5cGUucmVkdWNlID0gZnVuY3Rpb24gKGZuLCBpbml0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVzdWx0cy5yZWR1Y2UoZm4sIGluaXQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2VlXG4gICAgICAgICAqIFtBcnJheS5mb3JFYWNoXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9mb3JFYWNoKVxuICAgICAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBRdWVyeUxpc3QucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5fcmVzdWx0cy5mb3JFYWNoKGZuKTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlZVxuICAgICAgICAgKiBbQXJyYXkuc29tZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvc29tZSlcbiAgICAgICAgICogQHBhcmFtIHs/fSBmblxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgUXVlcnlMaXN0LnByb3RvdHlwZS5zb21lID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVzdWx0cy5zb21lKGZuKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBRdWVyeUxpc3QucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9yZXN1bHRzLnNsaWNlKCk7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgUXVlcnlMaXN0LnByb3RvdHlwZVtnZXRTeW1ib2xJdGVyYXRvcigpXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICgodGhpcy5fcmVzdWx0cykpW2dldFN5bWJvbEl0ZXJhdG9yKCldKCk7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgUXVlcnlMaXN0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Jlc3VsdHMudG9TdHJpbmcoKTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gcmVzXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBRdWVyeUxpc3QucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgICAgdGhpcy5fcmVzdWx0cyA9IExpc3RXcmFwcGVyLmZsYXR0ZW4ocmVzKTtcbiAgICAgICAgICAgIHRoaXMuX2RpcnR5ID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgUXVlcnlMaXN0LnByb3RvdHlwZS5ub3RpZnlPbkNoYW5nZXMgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX2VtaXR0ZXIuZW1pdCh0aGlzKTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGludGVybmFsXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBRdWVyeUxpc3QucHJvdG90eXBlLnNldERpcnR5ID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9kaXJ0eSA9IHRydWU7IH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShRdWVyeUxpc3QucHJvdG90eXBlLCBcImRpcnR5XCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogaW50ZXJuYWxcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGlydHk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUXVlcnlMaXN0O1xuICAgIH0oKSk7XG5cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBfU0VQQVJBVE9SID0gJyMnO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIEZBQ1RPUllfQ0xBU1NfU1VGRklYID0gJ05nRmFjdG9yeSc7XG4gICAgLyoqXG4gICAgICogQ29uZmlndXJhdGlvbiBmb3IgU3lzdGVtSnNOZ01vZHVsZUxvYWRlci5cbiAgICAgKiB0b2tlbi5cbiAgICAgKlxuICAgICAqIFxcQGV4cGVyaW1lbnRhbFxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICAgIHZhciBTeXN0ZW1Kc05nTW9kdWxlTG9hZGVyQ29uZmlnID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gU3lzdGVtSnNOZ01vZHVsZUxvYWRlckNvbmZpZygpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU3lzdGVtSnNOZ01vZHVsZUxvYWRlckNvbmZpZztcbiAgICB9KCkpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIERFRkFVTFRfQ09ORklHID0ge1xuICAgICAgICBmYWN0b3J5UGF0aFByZWZpeDogJycsXG4gICAgICAgIGZhY3RvcnlQYXRoU3VmZml4OiAnLm5nZmFjdG9yeScsXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBOZ01vZHVsZUZhY3RvcnlMb2FkZXIgdGhhdCB1c2VzIFN5c3RlbUpTIHRvIGxvYWQgTmdNb2R1bGVGYWN0b3J5XG4gICAgICogXFxAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIFN5c3RlbUpzTmdNb2R1bGVMb2FkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBfY29tcGlsZXJcbiAgICAgICAgICogQHBhcmFtIHs/PX0gY29uZmlnXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBTeXN0ZW1Kc05nTW9kdWxlTG9hZGVyKF9jb21waWxlciwgY29uZmlnKSB7XG4gICAgICAgICAgICB0aGlzLl9jb21waWxlciA9IF9jb21waWxlcjtcbiAgICAgICAgICAgIHRoaXMuX2NvbmZpZyA9IGNvbmZpZyB8fCBERUZBVUxUX0NPTkZJRztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBwYXRoXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBTeXN0ZW1Kc05nTW9kdWxlTG9hZGVyLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9mZmxpbmVNb2RlID0gdGhpcy5fY29tcGlsZXIgaW5zdGFuY2VvZiBDb21waWxlcjtcbiAgICAgICAgICAgIHJldHVybiBvZmZsaW5lTW9kZSA/IHRoaXMubG9hZEZhY3RvcnkocGF0aCkgOiB0aGlzLmxvYWRBbmRDb21waWxlKHBhdGgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBwYXRoXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBTeXN0ZW1Kc05nTW9kdWxlTG9hZGVyLnByb3RvdHlwZS5sb2FkQW5kQ29tcGlsZSA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIF9hID0gcGF0aC5zcGxpdChfU0VQQVJBVE9SKSwgbW9kdWxlID0gX2FbMF0sIGV4cG9ydE5hbWUgPSBfYVsxXTtcbiAgICAgICAgICAgIGlmIChleHBvcnROYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBleHBvcnROYW1lID0gJ2RlZmF1bHQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFN5c3RlbS5pbXBvcnQobW9kdWxlKVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChtb2R1bGUpIHsgcmV0dXJuIG1vZHVsZVtleHBvcnROYW1lXTsgfSlcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gY2hlY2tOb3RFbXB0eSh0eXBlLCBtb2R1bGUsIGV4cG9ydE5hbWUpOyB9KVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiBfdGhpcy5fY29tcGlsZXIuY29tcGlsZU1vZHVsZUFzeW5jKHR5cGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gcGF0aFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgU3lzdGVtSnNOZ01vZHVsZUxvYWRlci5wcm90b3R5cGUubG9hZEZhY3RvcnkgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICAgICAgdmFyIF9hID0gcGF0aC5zcGxpdChfU0VQQVJBVE9SKSwgbW9kdWxlID0gX2FbMF0sIGV4cG9ydE5hbWUgPSBfYVsxXTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZhY3RvcnlDbGFzc1N1ZmZpeCA9IEZBQ1RPUllfQ0xBU1NfU1VGRklYO1xuICAgICAgICAgICAgaWYgKGV4cG9ydE5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGV4cG9ydE5hbWUgPSAnZGVmYXVsdCc7XG4gICAgICAgICAgICAgICAgZmFjdG9yeUNsYXNzU3VmZml4ID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gU3lzdGVtLmltcG9ydCh0aGlzLl9jb25maWcuZmFjdG9yeVBhdGhQcmVmaXggKyBtb2R1bGUgKyB0aGlzLl9jb25maWcuZmFjdG9yeVBhdGhTdWZmaXgpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKG1vZHVsZSkgeyByZXR1cm4gbW9kdWxlW2V4cG9ydE5hbWUgKyBmYWN0b3J5Q2xhc3NTdWZmaXhdOyB9KVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChmYWN0b3J5KSB7IHJldHVybiBjaGVja05vdEVtcHR5KGZhY3RvcnksIG1vZHVsZSwgZXhwb3J0TmFtZSk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICBTeXN0ZW1Kc05nTW9kdWxlTG9hZGVyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IEluamVjdGFibGUgfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIFN5c3RlbUpzTmdNb2R1bGVMb2FkZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgICAgICB7IHR5cGU6IENvbXBpbGVyLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBTeXN0ZW1Kc05nTW9kdWxlTG9hZGVyQ29uZmlnLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgXTsgfTtcbiAgICAgICAgcmV0dXJuIFN5c3RlbUpzTmdNb2R1bGVMb2FkZXI7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/fSBtb2R1bGVQYXRoXG4gICAgICogQHBhcmFtIHs/fSBleHBvcnROYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaGVja05vdEVtcHR5KHZhbHVlLCBtb2R1bGVQYXRoLCBleHBvcnROYW1lKSB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kICdcIiArIGV4cG9ydE5hbWUgKyBcIicgaW4gJ1wiICsgbW9kdWxlUGF0aCArIFwiJ1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkMTAgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGFuIEVtYmVkZGVkIFRlbXBsYXRlIHRoYXQgY2FuIGJlIHVzZWQgdG8gaW5zdGFudGlhdGUgRW1iZWRkZWQgVmlld3MuXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIGFjY2VzcyBhIGBUZW1wbGF0ZVJlZmAsIGluIHR3byB3YXlzLiBWaWEgYSBkaXJlY3RpdmUgcGxhY2VkIG9uIGEgYDx0ZW1wbGF0ZT5gIGVsZW1lbnQgKG9yXG4gICAgICogZGlyZWN0aXZlIHByZWZpeGVkIHdpdGggYCpgKSBhbmQgaGF2ZSB0aGUgYFRlbXBsYXRlUmVmYCBmb3IgdGhpcyBFbWJlZGRlZCBWaWV3IGluamVjdGVkIGludG8gdGhlXG4gICAgICogY29uc3RydWN0b3Igb2YgdGhlIGRpcmVjdGl2ZSB1c2luZyB0aGUgYFRlbXBsYXRlUmVmYCBUb2tlbi4gQWx0ZXJuYXRpdmVseSB5b3UgY2FuIHF1ZXJ5IGZvciB0aGVcbiAgICAgKiBgVGVtcGxhdGVSZWZgIGZyb20gYSBDb21wb25lbnQgb3IgYSBEaXJlY3RpdmUgdmlhIHtcXEBsaW5rIFF1ZXJ5fS5cbiAgICAgKlxuICAgICAqIFRvIGluc3RhbnRpYXRlIEVtYmVkZGVkIFZpZXdzIGJhc2VkIG9uIGEgVGVtcGxhdGUsIHVzZVxuICAgICAqIHtcXEBsaW5rIFZpZXdDb250YWluZXJSZWYjY3JlYXRlRW1iZWRkZWRWaWV3fSwgd2hpY2ggd2lsbCBjcmVhdGUgdGhlIFZpZXcgYW5kIGF0dGFjaCBpdCB0byB0aGVcbiAgICAgKiBWaWV3IENvbnRhaW5lci5cbiAgICAgKiBcXEBzdGFibGVcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICB2YXIgVGVtcGxhdGVSZWYgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBUZW1wbGF0ZVJlZigpIHtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGVtcGxhdGVSZWYucHJvdG90eXBlLCBcImVsZW1lbnRSZWZcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgVGVtcGxhdGVSZWYucHJvdG90eXBlLmNyZWF0ZUVtYmVkZGVkVmlldyA9IGZ1bmN0aW9uIChjb250ZXh0KSB7IH07XG4gICAgICAgIHJldHVybiBUZW1wbGF0ZVJlZjtcbiAgICB9KCkpO1xuICAgIHZhciBUZW1wbGF0ZVJlZl8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMTAoVGVtcGxhdGVSZWZfLCBfc3VwZXIpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBfcGFyZW50Vmlld1xuICAgICAgICAgKiBAcGFyYW0gez99IF9ub2RlSW5kZXhcbiAgICAgICAgICogQHBhcmFtIHs/fSBfbmF0aXZlRWxlbWVudFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gVGVtcGxhdGVSZWZfKF9wYXJlbnRWaWV3LCBfbm9kZUluZGV4LCBfbmF0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9wYXJlbnRWaWV3ID0gX3BhcmVudFZpZXc7XG4gICAgICAgICAgICB0aGlzLl9ub2RlSW5kZXggPSBfbm9kZUluZGV4O1xuICAgICAgICAgICAgdGhpcy5fbmF0aXZlRWxlbWVudCA9IF9uYXRpdmVFbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFRlbXBsYXRlUmVmXy5wcm90b3R5cGUuY3JlYXRlRW1iZWRkZWRWaWV3ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpZXcgPSB0aGlzLl9wYXJlbnRWaWV3LmNyZWF0ZUVtYmVkZGVkVmlld0ludGVybmFsKHRoaXMuX25vZGVJbmRleCk7XG4gICAgICAgICAgICB2aWV3LmNyZWF0ZShjb250ZXh0IHx8ICh7fSkpO1xuICAgICAgICAgICAgcmV0dXJuIHZpZXcucmVmO1xuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGVtcGxhdGVSZWZfLnByb3RvdHlwZSwgXCJlbGVtZW50UmVmXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgRWxlbWVudFJlZih0aGlzLl9uYXRpdmVFbGVtZW50KTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBUZW1wbGF0ZVJlZl87XG4gICAgfShUZW1wbGF0ZVJlZikpO1xuXG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhIGNvbnRhaW5lciB3aGVyZSBvbmUgb3IgbW9yZSBWaWV3cyBjYW4gYmUgYXR0YWNoZWQuXG4gICAgICpcbiAgICAgKiBUaGUgY29udGFpbmVyIGNhbiBjb250YWluIHR3byBraW5kcyBvZiBWaWV3cy4gSG9zdCBWaWV3cywgY3JlYXRlZCBieSBpbnN0YW50aWF0aW5nIGFcbiAgICAgKiB7XFxAbGluayBDb21wb25lbnR9IHZpYSB7XFxAbGluayAjY3JlYXRlQ29tcG9uZW50fSwgYW5kIEVtYmVkZGVkIFZpZXdzLCBjcmVhdGVkIGJ5IGluc3RhbnRpYXRpbmcgYW5cbiAgICAgKiB7XFxAbGluayBUZW1wbGF0ZVJlZiBFbWJlZGRlZCBUZW1wbGF0ZX0gdmlhIHtcXEBsaW5rICNjcmVhdGVFbWJlZGRlZFZpZXd9LlxuICAgICAqXG4gICAgICogVGhlIGxvY2F0aW9uIG9mIHRoZSBWaWV3IENvbnRhaW5lciB3aXRoaW4gdGhlIGNvbnRhaW5pbmcgVmlldyBpcyBzcGVjaWZpZWQgYnkgdGhlIEFuY2hvclxuICAgICAqIGBlbGVtZW50YC4gRWFjaCBWaWV3IENvbnRhaW5lciBjYW4gaGF2ZSBvbmx5IG9uZSBBbmNob3IgRWxlbWVudCBhbmQgZWFjaCBBbmNob3IgRWxlbWVudCBjYW4gb25seVxuICAgICAqIGhhdmUgYSBzaW5nbGUgVmlldyBDb250YWluZXIuXG4gICAgICpcbiAgICAgKiBSb290IGVsZW1lbnRzIG9mIFZpZXdzIGF0dGFjaGVkIHRvIHRoaXMgY29udGFpbmVyIGJlY29tZSBzaWJsaW5ncyBvZiB0aGUgQW5jaG9yIEVsZW1lbnQgaW5cbiAgICAgKiB0aGUgUmVuZGVyZWQgVmlldy5cbiAgICAgKlxuICAgICAqIFRvIGFjY2VzcyBhIGBWaWV3Q29udGFpbmVyUmVmYCBvZiBhbiBFbGVtZW50LCB5b3UgY2FuIGVpdGhlciBwbGFjZSBhIHtcXEBsaW5rIERpcmVjdGl2ZX0gaW5qZWN0ZWRcbiAgICAgKiB3aXRoIGBWaWV3Q29udGFpbmVyUmVmYCBvbiB0aGUgRWxlbWVudCwgb3IgeW91IG9idGFpbiBpdCB2aWEgYSB7XFxAbGluayBWaWV3Q2hpbGR9IHF1ZXJ5LlxuICAgICAqIFxcQHN0YWJsZVxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICAgIHZhciBWaWV3Q29udGFpbmVyUmVmID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gVmlld0NvbnRhaW5lclJlZigpIHtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVmlld0NvbnRhaW5lclJlZi5wcm90b3R5cGUsIFwiZWxlbWVudFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEFuY2hvciBlbGVtZW50IHRoYXQgc3BlY2lmaWVzIHRoZSBsb2NhdGlvbiBvZiB0aGlzIGNvbnRhaW5lciBpbiB0aGUgY29udGFpbmluZyBWaWV3LlxuICAgICAgICAgICAgICogPCEtLSBUT0RPOiByZW5hbWUgdG8gYW5jaG9yRWxlbWVudCAtLT5cbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gKHVuaW1wbGVtZW50ZWQoKSk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVmlld0NvbnRhaW5lclJlZi5wcm90b3R5cGUsIFwiaW5qZWN0b3JcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh1bmltcGxlbWVudGVkKCkpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdDb250YWluZXJSZWYucHJvdG90eXBlLCBcInBhcmVudEluamVjdG9yXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiAodW5pbXBsZW1lbnRlZCgpKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXN0cm95cyBhbGwgVmlld3MgaW4gdGhpcyBjb250YWluZXIuXG4gICAgICAgICAqIEBhYnN0cmFjdFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgVmlld0NvbnRhaW5lclJlZi5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSB7XFxAbGluayBWaWV3UmVmfSBmb3IgdGhlIFZpZXcgbG9jYXRlZCBpbiB0aGlzIGNvbnRhaW5lciBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LlxuICAgICAgICAgKiBAYWJzdHJhY3RcbiAgICAgICAgICogQHBhcmFtIHs/fSBpbmRleFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgVmlld0NvbnRhaW5lclJlZi5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGluZGV4KSB7IH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaWV3Q29udGFpbmVyUmVmLnByb3RvdHlwZSwgXCJsZW5ndGhcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgVmlld3MgY3VycmVudGx5IGF0dGFjaGVkIHRvIHRoaXMgY29udGFpbmVyLlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiAodW5pbXBsZW1lbnRlZCgpKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluc3RhbnRpYXRlcyBhbiBFbWJlZGRlZCBWaWV3IGJhc2VkIG9uIHRoZSB7XFxAbGluayBUZW1wbGF0ZVJlZiBgdGVtcGxhdGVSZWZgfSBhbmQgaW5zZXJ0cyBpdFxuICAgICAgICAgKiBpbnRvIHRoaXMgY29udGFpbmVyIGF0IHRoZSBzcGVjaWZpZWQgYGluZGV4YC5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgYGluZGV4YCBpcyBub3Qgc3BlY2lmaWVkLCB0aGUgbmV3IFZpZXcgd2lsbCBiZSBpbnNlcnRlZCBhcyB0aGUgbGFzdCBWaWV3IGluIHRoZSBjb250YWluZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIFJldHVybnMgdGhlIHtcXEBsaW5rIFZpZXdSZWZ9IGZvciB0aGUgbmV3bHkgY3JlYXRlZCBWaWV3LlxuICAgICAgICAgKiBAYWJzdHJhY3RcbiAgICAgICAgICogQHBhcmFtIHs/fSB0ZW1wbGF0ZVJlZlxuICAgICAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICAgICAqIEBwYXJhbSB7Pz19IGluZGV4XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBWaWV3Q29udGFpbmVyUmVmLnByb3RvdHlwZS5jcmVhdGVFbWJlZGRlZFZpZXcgPSBmdW5jdGlvbiAodGVtcGxhdGVSZWYsIGNvbnRleHQsIGluZGV4KSB7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnN0YW50aWF0ZXMgYSBzaW5nbGUge1xcQGxpbmsgQ29tcG9uZW50fSBhbmQgaW5zZXJ0cyBpdHMgSG9zdCBWaWV3IGludG8gdGhpcyBjb250YWluZXIgYXQgdGhlXG4gICAgICAgICAqIHNwZWNpZmllZCBgaW5kZXhgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgY29tcG9uZW50IGlzIGluc3RhbnRpYXRlZCB1c2luZyBpdHMge1xcQGxpbmsgQ29tcG9uZW50RmFjdG9yeX0gd2hpY2ggY2FuIGJlXG4gICAgICAgICAqIG9idGFpbmVkIHZpYSB7XFxAbGluayBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIjcmVzb2x2ZUNvbXBvbmVudEZhY3Rvcnl9LlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBgaW5kZXhgIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBuZXcgVmlldyB3aWxsIGJlIGluc2VydGVkIGFzIHRoZSBsYXN0IFZpZXcgaW4gdGhlIGNvbnRhaW5lci5cbiAgICAgICAgICpcbiAgICAgICAgICogWW91IGNhbiBvcHRpb25hbGx5IHNwZWNpZnkgdGhlIHtcXEBsaW5rIEluamVjdG9yfSB0aGF0IHdpbGwgYmUgdXNlZCBhcyBwYXJlbnQgZm9yIHRoZSBDb21wb25lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFJldHVybnMgdGhlIHtcXEBsaW5rIENvbXBvbmVudFJlZn0gb2YgdGhlIEhvc3QgVmlldyBjcmVhdGVkIGZvciB0aGUgbmV3bHkgaW5zdGFudGlhdGVkIENvbXBvbmVudC5cbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqIEBwYXJhbSB7P30gY29tcG9uZW50RmFjdG9yeVxuICAgICAgICAgKiBAcGFyYW0gez89fSBpbmRleFxuICAgICAgICAgKiBAcGFyYW0gez89fSBpbmplY3RvclxuICAgICAgICAgKiBAcGFyYW0gez89fSBwcm9qZWN0YWJsZU5vZGVzXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBWaWV3Q29udGFpbmVyUmVmLnByb3RvdHlwZS5jcmVhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAoY29tcG9uZW50RmFjdG9yeSwgaW5kZXgsIGluamVjdG9yLCBwcm9qZWN0YWJsZU5vZGVzKSB7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnNlcnRzIGEgVmlldyBpZGVudGlmaWVkIGJ5IGEge1xcQGxpbmsgVmlld1JlZn0gaW50byB0aGUgY29udGFpbmVyIGF0IHRoZSBzcGVjaWZpZWQgYGluZGV4YC5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgYGluZGV4YCBpcyBub3Qgc3BlY2lmaWVkLCB0aGUgbmV3IFZpZXcgd2lsbCBiZSBpbnNlcnRlZCBhcyB0aGUgbGFzdCBWaWV3IGluIHRoZSBjb250YWluZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGluc2VydGVkIHtcXEBsaW5rIFZpZXdSZWZ9LlxuICAgICAgICAgKiBAYWJzdHJhY3RcbiAgICAgICAgICogQHBhcmFtIHs/fSB2aWV3UmVmXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IGluZGV4XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBWaWV3Q29udGFpbmVyUmVmLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAodmlld1JlZiwgaW5kZXgpIHsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1vdmVzIGEgVmlldyBpZGVudGlmaWVkIGJ5IGEge1xcQGxpbmsgVmlld1JlZn0gaW50byB0aGUgY29udGFpbmVyIGF0IHRoZSBzcGVjaWZpZWQgYGluZGV4YC5cbiAgICAgICAgICpcbiAgICAgICAgICogUmV0dXJucyB0aGUgaW5zZXJ0ZWQge1xcQGxpbmsgVmlld1JlZn0uXG4gICAgICAgICAqIEBhYnN0cmFjdFxuICAgICAgICAgKiBAcGFyYW0gez99IHZpZXdSZWZcbiAgICAgICAgICogQHBhcmFtIHs/fSBjdXJyZW50SW5kZXhcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFZpZXdDb250YWluZXJSZWYucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbiAodmlld1JlZiwgY3VycmVudEluZGV4KSB7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgVmlldywgc3BlY2lmaWVkIHZpYSB7XFxAbGluayBWaWV3UmVmfSwgd2l0aGluIHRoZSBjdXJyZW50IGNvbnRhaW5lciBvclxuICAgICAgICAgKiBgLTFgIGlmIHRoaXMgY29udGFpbmVyIGRvZXNuJ3QgY29udGFpbiB0aGUgVmlldy5cbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqIEBwYXJhbSB7P30gdmlld1JlZlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgVmlld0NvbnRhaW5lclJlZi5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uICh2aWV3UmVmKSB7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXN0cm95cyBhIFZpZXcgYXR0YWNoZWQgdG8gdGhpcyBjb250YWluZXIgYXQgdGhlIHNwZWNpZmllZCBgaW5kZXhgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBgaW5kZXhgIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBsYXN0IFZpZXcgaW4gdGhlIGNvbnRhaW5lciB3aWxsIGJlIHJlbW92ZWQuXG4gICAgICAgICAqIEBhYnN0cmFjdFxuICAgICAgICAgKiBAcGFyYW0gez89fSBpbmRleFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgVmlld0NvbnRhaW5lclJlZi5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGluZGV4KSB7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2UgYWxvbmcgd2l0aCB7XFxAbGluayAjaW5zZXJ0fSB0byBtb3ZlIGEgVmlldyB3aXRoaW4gdGhlIGN1cnJlbnQgY29udGFpbmVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiB0aGUgYGluZGV4YCBwYXJhbSBpcyBvbWl0dGVkLCB0aGUgbGFzdCB7XFxAbGluayBWaWV3UmVmfSBpcyBkZXRhY2hlZC5cbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqIEBwYXJhbSB7Pz19IGluZGV4XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBWaWV3Q29udGFpbmVyUmVmLnByb3RvdHlwZS5kZXRhY2ggPSBmdW5jdGlvbiAoaW5kZXgpIHsgfTtcbiAgICAgICAgcmV0dXJuIFZpZXdDb250YWluZXJSZWY7XG4gICAgfSgpKTtcbiAgICB2YXIgVmlld0NvbnRhaW5lclJlZl8gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBfZWxlbWVudFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gVmlld0NvbnRhaW5lclJlZl8oX2VsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnQgPSBfZWxlbWVudDtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZUNvbXBvbmVudEluQ29udGFpbmVyU2NvcGUgPSB3dGZDcmVhdGVTY29wZSgnVmlld0NvbnRhaW5lclJlZiNjcmVhdGVDb21wb25lbnQoKScpO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5faW5zZXJ0U2NvcGUgPSB3dGZDcmVhdGVTY29wZSgnVmlld0NvbnRhaW5lclJlZiNpbnNlcnQoKScpO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlU2NvcGUgPSB3dGZDcmVhdGVTY29wZSgnVmlld0NvbnRhaW5lclJlZiNyZW1vdmUoKScpO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fZGV0YWNoU2NvcGUgPSB3dGZDcmVhdGVTY29wZSgnVmlld0NvbnRhaW5lclJlZiNkZXRhY2goKScpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGluZGV4XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBWaWV3Q29udGFpbmVyUmVmXy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGluZGV4KSB7IHJldHVybiB0aGlzLl9lbGVtZW50Lm5lc3RlZFZpZXdzW2luZGV4XS5yZWY7IH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaWV3Q29udGFpbmVyUmVmXy5wcm90b3R5cGUsIFwibGVuZ3RoXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlld3MgPSB0aGlzLl9lbGVtZW50Lm5lc3RlZFZpZXdzO1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1ByZXNlbnQodmlld3MpID8gdmlld3MubGVuZ3RoIDogMDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVmlld0NvbnRhaW5lclJlZl8ucHJvdG90eXBlLCBcImVsZW1lbnRcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2VsZW1lbnQuZWxlbWVudFJlZjsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaWV3Q29udGFpbmVyUmVmXy5wcm90b3R5cGUsIFwiaW5qZWN0b3JcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2VsZW1lbnQuaW5qZWN0b3I7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVmlld0NvbnRhaW5lclJlZl8ucHJvdG90eXBlLCBcInBhcmVudEluamVjdG9yXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9lbGVtZW50LnBhcmVudEluamVjdG9yOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdGVtcGxhdGVSZWZcbiAgICAgICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAgICAgKiBAcGFyYW0gez89fSBpbmRleFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgVmlld0NvbnRhaW5lclJlZl8ucHJvdG90eXBlLmNyZWF0ZUVtYmVkZGVkVmlldyA9IGZ1bmN0aW9uICh0ZW1wbGF0ZVJlZiwgY29udGV4dCwgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gdm9pZCAwKSB7IGluZGV4ID0gLTE7IH1cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpZXdSZWYgPSB0ZW1wbGF0ZVJlZi5jcmVhdGVFbWJlZGRlZFZpZXcoY29udGV4dCk7XG4gICAgICAgICAgICB0aGlzLmluc2VydCh2aWV3UmVmLCBpbmRleCk7XG4gICAgICAgICAgICByZXR1cm4gdmlld1JlZjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gY29tcG9uZW50RmFjdG9yeVxuICAgICAgICAgKiBAcGFyYW0gez89fSBpbmRleFxuICAgICAgICAgKiBAcGFyYW0gez89fSBpbmplY3RvclxuICAgICAgICAgKiBAcGFyYW0gez89fSBwcm9qZWN0YWJsZU5vZGVzXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBWaWV3Q29udGFpbmVyUmVmXy5wcm90b3R5cGUuY3JlYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKGNvbXBvbmVudEZhY3RvcnksIGluZGV4LCBpbmplY3RvciwgcHJvamVjdGFibGVOb2Rlcykge1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSB2b2lkIDApIHsgaW5kZXggPSAtMTsgfVxuICAgICAgICAgICAgaWYgKGluamVjdG9yID09PSB2b2lkIDApIHsgaW5qZWN0b3IgPSBudWxsOyB9XG4gICAgICAgICAgICBpZiAocHJvamVjdGFibGVOb2RlcyA9PT0gdm9pZCAwKSB7IHByb2plY3RhYmxlTm9kZXMgPSBudWxsOyB9XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzID0gdGhpcy5fY3JlYXRlQ29tcG9uZW50SW5Db250YWluZXJTY29wZSgpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29udGV4dEluamVjdG9yID0gaW5qZWN0b3IgfHwgdGhpcy5fZWxlbWVudC5wYXJlbnRJbmplY3RvcjtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbXBvbmVudFJlZiA9IGNvbXBvbmVudEZhY3RvcnkuY3JlYXRlKGNvbnRleHRJbmplY3RvciwgcHJvamVjdGFibGVOb2Rlcyk7XG4gICAgICAgICAgICB0aGlzLmluc2VydChjb21wb25lbnRSZWYuaG9zdFZpZXcsIGluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiB3dGZMZWF2ZShzLCBjb21wb25lbnRSZWYpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2aWV3UmVmXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IGluZGV4XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBWaWV3Q29udGFpbmVyUmVmXy5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKHZpZXdSZWYsIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IHZvaWQgMCkgeyBpbmRleCA9IC0xOyB9XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzID0gdGhpcy5faW5zZXJ0U2NvcGUoKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PSAtMSlcbiAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlld1JlZl8gPSAodmlld1JlZik7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50LmF0dGFjaFZpZXcodmlld1JlZl8uaW50ZXJuYWxWaWV3LCBpbmRleCk7XG4gICAgICAgICAgICByZXR1cm4gd3RmTGVhdmUocywgdmlld1JlZl8pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2aWV3UmVmXG4gICAgICAgICAqIEBwYXJhbSB7P30gY3VycmVudEluZGV4XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBWaWV3Q29udGFpbmVyUmVmXy5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uICh2aWV3UmVmLCBjdXJyZW50SW5kZXgpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHMgPSB0aGlzLl9pbnNlcnRTY29wZSgpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA9PSAtMSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2aWV3UmVmXyA9ICh2aWV3UmVmKTtcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnQubW92ZVZpZXcodmlld1JlZl8uaW50ZXJuYWxWaWV3LCBjdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuIHd0ZkxlYXZlKHMsIHZpZXdSZWZfKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmlld1JlZlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgVmlld0NvbnRhaW5lclJlZl8ucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiAodmlld1JlZikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQubmVzdGVkVmlld3MuaW5kZXhPZigoKHZpZXdSZWYpKS5pbnRlcm5hbFZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/PX0gaW5kZXhcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFZpZXdDb250YWluZXJSZWZfLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gdm9pZCAwKSB7IGluZGV4ID0gLTE7IH1cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHMgPSB0aGlzLl9yZW1vdmVTY29wZSgpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IC0xKVxuICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlldyA9IHRoaXMuX2VsZW1lbnQuZGV0YWNoVmlldyhpbmRleCk7XG4gICAgICAgICAgICB2aWV3LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIC8vIHZpZXcgaXMgaW50ZW50aW9uYWxseSBub3QgcmV0dXJuZWQgdG8gdGhlIGNsaWVudC5cbiAgICAgICAgICAgIHd0ZkxlYXZlKHMpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/PX0gaW5kZXhcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFZpZXdDb250YWluZXJSZWZfLnByb3RvdHlwZS5kZXRhY2ggPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gdm9pZCAwKSB7IGluZGV4ID0gLTE7IH1cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHMgPSB0aGlzLl9kZXRhY2hTY29wZSgpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IC0xKVxuICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlldyA9IHRoaXMuX2VsZW1lbnQuZGV0YWNoVmlldyhpbmRleCk7XG4gICAgICAgICAgICByZXR1cm4gd3RmTGVhdmUocywgdmlldy5yZWYpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFZpZXdDb250YWluZXJSZWZfLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZShpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFZpZXdDb250YWluZXJSZWZfO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQxMSA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFxcQHN0YWJsZVxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICAgIHZhciBWaWV3UmVmID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDExKFZpZXdSZWYsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFZpZXdSZWYoKSB7XG4gICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRGVzdHJveXMgdGhlIHZpZXcgYW5kIGFsbCBvZiB0aGUgZGF0YSBzdHJ1Y3R1cmVzIGFzc29jaWF0ZWQgd2l0aCBpdC5cbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBWaWV3UmVmLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVmlld1JlZi5wcm90b3R5cGUsIFwiZGVzdHJveWVkXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiAodW5pbXBsZW1lbnRlZCgpKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAYWJzdHJhY3RcbiAgICAgICAgICogQHBhcmFtIHs/fSBjYWxsYmFja1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgVmlld1JlZi5wcm90b3R5cGUub25EZXN0cm95ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7IH07XG4gICAgICAgIHJldHVybiBWaWV3UmVmO1xuICAgIH0oQ2hhbmdlRGV0ZWN0b3JSZWYpKTtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGFuIEFuZ3VsYXIgVmlldy5cbiAgICAgKlxuICAgICAqIDwhLS0gVE9ETzogbW92ZSB0aGUgbmV4dCB0d28gcGFyYWdyYXBocyB0byB0aGUgZGV2IGd1aWRlIC0tPlxuICAgICAqIEEgVmlldyBpcyBhIGZ1bmRhbWVudGFsIGJ1aWxkaW5nIGJsb2NrIG9mIHRoZSBhcHBsaWNhdGlvbiBVSS4gSXQgaXMgdGhlIHNtYWxsZXN0IGdyb3VwaW5nIG9mXG4gICAgICogRWxlbWVudHMgd2hpY2ggYXJlIGNyZWF0ZWQgYW5kIGRlc3Ryb3llZCB0b2dldGhlci5cbiAgICAgKlxuICAgICAqIFByb3BlcnRpZXMgb2YgZWxlbWVudHMgaW4gYSBWaWV3IGNhbiBjaGFuZ2UsIGJ1dCB0aGUgc3RydWN0dXJlIChudW1iZXIgYW5kIG9yZGVyKSBvZiBlbGVtZW50cyBpblxuICAgICAqIGEgVmlldyBjYW5ub3QuIENoYW5naW5nIHRoZSBzdHJ1Y3R1cmUgb2YgRWxlbWVudHMgY2FuIG9ubHkgYmUgZG9uZSBieSBpbnNlcnRpbmcsIG1vdmluZyBvclxuICAgICAqIHJlbW92aW5nIG5lc3RlZCBWaWV3cyB2aWEgYSB7XFxAbGluayBWaWV3Q29udGFpbmVyUmVmfS4gRWFjaCBWaWV3IGNhbiBjb250YWluIG1hbnkgVmlldyBDb250YWluZXJzLlxuICAgICAqIDwhLS0gL1RPRE8gLS0+XG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICogR2l2ZW4gdGhpcyB0ZW1wbGF0ZS4uLlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogQ291bnQ6IHt7aXRlbXMubGVuZ3RofX1cbiAgICAgKiA8dWw+XG4gICAgICogICA8bGkgKm5nRm9yPVwibGV0ICBpdGVtIG9mIGl0ZW1zXCI+e3tpdGVtfX08L2xpPlxuICAgICAqIDwvdWw+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBXZSBoYXZlIHR3byB7XFxAbGluayBUZW1wbGF0ZVJlZn1zOlxuICAgICAqXG4gICAgICogT3V0ZXIge1xcQGxpbmsgVGVtcGxhdGVSZWZ9OlxuICAgICAqIGBgYFxuICAgICAqIENvdW50OiB7e2l0ZW1zLmxlbmd0aH19XG4gICAgICogPHVsPlxuICAgICAqICAgPHRlbXBsYXRlIG5nRm9yIGxldC1pdGVtIFtuZ0Zvck9mXT1cIml0ZW1zXCI+PC90ZW1wbGF0ZT5cbiAgICAgKiA8L3VsPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogSW5uZXIge1xcQGxpbmsgVGVtcGxhdGVSZWZ9OlxuICAgICAqIGBgYFxuICAgICAqICAgPGxpPnt7aXRlbX19PC9saT5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIE5vdGljZSB0aGF0IHRoZSBvcmlnaW5hbCB0ZW1wbGF0ZSBpcyBicm9rZW4gZG93biBpbnRvIHR3byBzZXBhcmF0ZSB7XFxAbGluayBUZW1wbGF0ZVJlZn1zLlxuICAgICAqXG4gICAgICogVGhlIG91dGVyL2lubmVyIHtcXEBsaW5rIFRlbXBsYXRlUmVmfXMgYXJlIHRoZW4gYXNzZW1ibGVkIGludG8gdmlld3MgbGlrZSBzbzpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIDwhLS0gVmlld1JlZjogb3V0ZXItMCAtLT5cbiAgICAgKiBDb3VudDogMlxuICAgICAqIDx1bD5cbiAgICAgKiAgIDx0ZW1wbGF0ZSB2aWV3LWNvbnRhaW5lci1yZWY+PC90ZW1wbGF0ZT5cbiAgICAgKiAgIDwhLS0gVmlld1JlZjogaW5uZXItMSAtLT48bGk+Zmlyc3Q8L2xpPjwhLS0gL1ZpZXdSZWY6IGlubmVyLTEgLS0+XG4gICAgICogICA8IS0tIFZpZXdSZWY6IGlubmVyLTIgLS0+PGxpPnNlY29uZDwvbGk+PCEtLSAvVmlld1JlZjogaW5uZXItMiAtLT5cbiAgICAgKiA8L3VsPlxuICAgICAqIDwhLS0gL1ZpZXdSZWY6IG91dGVyLTAgLS0+XG4gICAgICogYGBgXG4gICAgICogXFxAZXhwZXJpbWVudGFsXG4gICAgICogQGFic3RyYWN0XG4gICAgICovXG4gICAgdmFyIEVtYmVkZGVkVmlld1JlZiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQxMShFbWJlZGRlZFZpZXdSZWYsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEVtYmVkZGVkVmlld1JlZigpIHtcbiAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbWJlZGRlZFZpZXdSZWYucHJvdG90eXBlLCBcImNvbnRleHRcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaW1wbGVtZW50ZWQoKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbWJlZGRlZFZpZXdSZWYucHJvdG90eXBlLCBcInJvb3ROb2Rlc1wiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gKHVuaW1wbGVtZW50ZWQoKSk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICA7XG4gICAgICAgIHJldHVybiBFbWJlZGRlZFZpZXdSZWY7XG4gICAgfShWaWV3UmVmKSk7XG4gICAgdmFyIFZpZXdSZWZfID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gX3ZpZXdcbiAgICAgICAgICogQHBhcmFtIHs/fSBhbmltYXRpb25RdWV1ZVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gVmlld1JlZl8oX3ZpZXcsIGFuaW1hdGlvblF1ZXVlKSB7XG4gICAgICAgICAgICB0aGlzLl92aWV3ID0gX3ZpZXc7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvblF1ZXVlID0gYW5pbWF0aW9uUXVldWU7XG4gICAgICAgICAgICB0aGlzLl92aWV3ID0gX3ZpZXc7XG4gICAgICAgICAgICB0aGlzLl9vcmlnaW5hbE1vZGUgPSB0aGlzLl92aWV3LmNkTW9kZTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVmlld1JlZl8ucHJvdG90eXBlLCBcImludGVybmFsVmlld1wiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fdmlldzsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaWV3UmVmXy5wcm90b3R5cGUsIFwicm9vdE5vZGVzXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl92aWV3LmZsYXRSb290Tm9kZXM7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVmlld1JlZl8ucHJvdG90eXBlLCBcImNvbnRleHRcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3ZpZXcuY29udGV4dDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaWV3UmVmXy5wcm90b3R5cGUsIFwiZGVzdHJveWVkXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl92aWV3LmRlc3Ryb3llZDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgVmlld1JlZl8ucHJvdG90eXBlLm1hcmtGb3JDaGVjayA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fdmlldy5tYXJrUGF0aFRvUm9vdEFzQ2hlY2tPbmNlKCk7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgVmlld1JlZl8ucHJvdG90eXBlLmRldGFjaCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fdmlldy5jZE1vZGUgPSBDaGFuZ2VEZXRlY3RvclN0YXR1cy5EZXRhY2hlZDsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBWaWV3UmVmXy5wcm90b3R5cGUuZGV0ZWN0Q2hhbmdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZpZXcuZGV0ZWN0Q2hhbmdlcyhmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvblF1ZXVlLmZsdXNoKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgVmlld1JlZl8ucHJvdG90eXBlLmNoZWNrTm9DaGFuZ2VzID0gZnVuY3Rpb24gKCkgeyB0aGlzLl92aWV3LmRldGVjdENoYW5nZXModHJ1ZSk7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgVmlld1JlZl8ucHJvdG90eXBlLnJlYXR0YWNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fdmlldy5jZE1vZGUgPSB0aGlzLl9vcmlnaW5hbE1vZGU7XG4gICAgICAgICAgICB0aGlzLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBjYWxsYmFja1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgVmlld1JlZl8ucHJvdG90eXBlLm9uRGVzdHJveSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl92aWV3LmRpc3Bvc2FibGVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmlldy5kaXNwb3NhYmxlcyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdmlldy5kaXNwb3NhYmxlcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBWaWV3UmVmXy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fdmlldy5kZXRhY2hBbmREZXN0cm95KCk7IH07XG4gICAgICAgIHJldHVybiBWaWV3UmVmXztcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkMTIgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICB2YXIgRXZlbnRMaXN0ZW5lciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgICAgICogQHBhcmFtIHs/fSBjYWxsYmFja1xuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gRXZlbnRMaXN0ZW5lcihuYW1lLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgfVxuICAgICAgICA7XG4gICAgICAgIHJldHVybiBFdmVudExpc3RlbmVyO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogXFxAZXhwZXJpbWVudGFsIEFsbCBkZWJ1Z2dpbmcgYXBpcyBhcmUgY3VycmVudGx5IGV4cGVyaW1lbnRhbC5cbiAgICAgKi9cbiAgICB2YXIgRGVidWdOb2RlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gbmF0aXZlTm9kZVxuICAgICAgICAgKiBAcGFyYW0gez99IHBhcmVudFxuICAgICAgICAgKiBAcGFyYW0gez99IF9kZWJ1Z0luZm9cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIERlYnVnTm9kZShuYXRpdmVOb2RlLCBwYXJlbnQsIF9kZWJ1Z0luZm8pIHtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnSW5mbyA9IF9kZWJ1Z0luZm87XG4gICAgICAgICAgICB0aGlzLm5hdGl2ZU5vZGUgPSBuYXRpdmVOb2RlO1xuICAgICAgICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQgaW5zdGFuY2VvZiBEZWJ1Z0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQuYWRkQ2hpbGQodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxpc3RlbmVycyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWJ1Z05vZGUucHJvdG90eXBlLCBcImluamVjdG9yXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kZWJ1Z0luZm8gPyB0aGlzLl9kZWJ1Z0luZm8uaW5qZWN0b3IgOiBudWxsOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlYnVnTm9kZS5wcm90b3R5cGUsIFwiY29tcG9uZW50SW5zdGFuY2VcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RlYnVnSW5mbyA/IHRoaXMuX2RlYnVnSW5mby5jb21wb25lbnQgOiBudWxsOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlYnVnTm9kZS5wcm90b3R5cGUsIFwiY29udGV4dFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGVidWdJbmZvID8gdGhpcy5fZGVidWdJbmZvLmNvbnRleHQgOiBudWxsOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlYnVnTm9kZS5wcm90b3R5cGUsIFwicmVmZXJlbmNlc1wiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWJ1Z0luZm8gPyB0aGlzLl9kZWJ1Z0luZm8ucmVmZXJlbmNlcyA6IG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlYnVnTm9kZS5wcm90b3R5cGUsIFwicHJvdmlkZXJUb2tlbnNcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RlYnVnSW5mbyA/IHRoaXMuX2RlYnVnSW5mby5wcm92aWRlclRva2VucyA6IG51bGw7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVidWdOb2RlLnByb3RvdHlwZSwgXCJzb3VyY2VcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RlYnVnSW5mbyA/IHRoaXMuX2RlYnVnSW5mby5zb3VyY2UgOiBudWxsOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIERlYnVnTm9kZTtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIFxcQGV4cGVyaW1lbnRhbCBBbGwgZGVidWdnaW5nIGFwaXMgYXJlIGN1cnJlbnRseSBleHBlcmltZW50YWwuXG4gICAgICovXG4gICAgdmFyIERlYnVnRWxlbWVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQxMihEZWJ1Z0VsZW1lbnQsIF9zdXBlcik7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IG5hdGl2ZU5vZGVcbiAgICAgICAgICogQHBhcmFtIHs/fSBwYXJlbnRcbiAgICAgICAgICogQHBhcmFtIHs/fSBfZGVidWdJbmZvXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBEZWJ1Z0VsZW1lbnQobmF0aXZlTm9kZSwgcGFyZW50LCBfZGVidWdJbmZvKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBuYXRpdmVOb2RlLCBwYXJlbnQsIF9kZWJ1Z0luZm8pO1xuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0ge307XG4gICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NlcyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5zdHlsZXMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuY2hpbGROb2RlcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5uYXRpdmVFbGVtZW50ID0gbmF0aXZlTm9kZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBjaGlsZFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRGVidWdFbGVtZW50LnByb3RvdHlwZS5hZGRDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZE5vZGVzLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgIGNoaWxkLnBhcmVudCA9IHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGNoaWxkXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBEZWJ1Z0VsZW1lbnQucHJvdG90eXBlLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjaGlsZEluZGV4ID0gdGhpcy5jaGlsZE5vZGVzLmluZGV4T2YoY2hpbGQpO1xuICAgICAgICAgICAgaWYgKGNoaWxkSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQucGFyZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkTm9kZXMuc3BsaWNlKGNoaWxkSW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBjaGlsZFxuICAgICAgICAgKiBAcGFyYW0gez99IG5ld0NoaWxkcmVuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBEZWJ1Z0VsZW1lbnQucHJvdG90eXBlLmluc2VydENoaWxkcmVuQWZ0ZXIgPSBmdW5jdGlvbiAoY2hpbGQsIG5ld0NoaWxkcmVuKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzaWJsaW5nSW5kZXggPSB0aGlzLmNoaWxkTm9kZXMuaW5kZXhPZihjaGlsZCk7XG4gICAgICAgICAgICBpZiAoc2libGluZ0luZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZXZpb3VzQ2hpbGRyZW4gPSB0aGlzLmNoaWxkTm9kZXMuc2xpY2UoMCwgc2libGluZ0luZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmV4dENoaWxkcmVuID0gdGhpcy5jaGlsZE5vZGVzLnNsaWNlKHNpYmxpbmdJbmRleCArIDEpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGROb2RlcyA9IHByZXZpb3VzQ2hpbGRyZW4uY29uY2F0KG5ld0NoaWxkcmVuLCBuZXh0Q2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBuZXdDaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZXdDaGlsZCA9IG5ld0NoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV3Q2hpbGQucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZC5wYXJlbnQucmVtb3ZlQ2hpbGQobmV3Q2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkLnBhcmVudCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBwcmVkaWNhdGVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIERlYnVnRWxlbWVudC5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbiAocHJlZGljYXRlKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHRzID0gdGhpcy5xdWVyeUFsbChwcmVkaWNhdGUpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHNbMF0gfHwgbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gcHJlZGljYXRlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBEZWJ1Z0VsZW1lbnQucHJvdG90eXBlLnF1ZXJ5QWxsID0gZnVuY3Rpb24gKHByZWRpY2F0ZSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWF0Y2hlcyA9IFtdO1xuICAgICAgICAgICAgX3F1ZXJ5RWxlbWVudENoaWxkcmVuKHRoaXMsIHByZWRpY2F0ZSwgbWF0Y2hlcyk7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlcztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gcHJlZGljYXRlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBEZWJ1Z0VsZW1lbnQucHJvdG90eXBlLnF1ZXJ5QWxsTm9kZXMgPSBmdW5jdGlvbiAocHJlZGljYXRlKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYXRjaGVzID0gW107XG4gICAgICAgICAgICBfcXVlcnlOb2RlQ2hpbGRyZW4odGhpcywgcHJlZGljYXRlLCBtYXRjaGVzKTtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaGVzO1xuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVidWdFbGVtZW50LnByb3RvdHlwZSwgXCJjaGlsZHJlblwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5jaGlsZE5vZGVzLmZpbHRlcihmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIERlYnVnRWxlbWVudDsgfSkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGV2ZW50TmFtZVxuICAgICAgICAgKiBAcGFyYW0gez99IGV2ZW50T2JqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBEZWJ1Z0VsZW1lbnQucHJvdG90eXBlLnRyaWdnZXJFdmVudEhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBldmVudE9iaikge1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXIubmFtZSA9PSBldmVudE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIuY2FsbGJhY2soZXZlbnRPYmopO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRGVidWdFbGVtZW50O1xuICAgIH0oRGVidWdOb2RlKSk7XG4gICAgLyoqXG4gICAgICogXFxAZXhwZXJpbWVudGFsXG4gICAgICogQHBhcmFtIHs/fSBkZWJ1Z0Vsc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gYXNOYXRpdmVFbGVtZW50cyhkZWJ1Z0Vscykge1xuICAgICAgICByZXR1cm4gZGVidWdFbHMubWFwKGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gZWwubmF0aXZlRWxlbWVudDsgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7P30gcHJlZGljYXRlXG4gICAgICogQHBhcmFtIHs/fSBtYXRjaGVzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfcXVlcnlFbGVtZW50Q2hpbGRyZW4oZWxlbWVudCwgcHJlZGljYXRlLCBtYXRjaGVzKSB7XG4gICAgICAgIGVsZW1lbnQuY2hpbGROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIERlYnVnRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGlmIChwcmVkaWNhdGUobm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfcXVlcnlFbGVtZW50Q2hpbGRyZW4obm9kZSwgcHJlZGljYXRlLCBtYXRjaGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGFyZW50Tm9kZVxuICAgICAqIEBwYXJhbSB7P30gcHJlZGljYXRlXG4gICAgICogQHBhcmFtIHs/fSBtYXRjaGVzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfcXVlcnlOb2RlQ2hpbGRyZW4ocGFyZW50Tm9kZSwgcHJlZGljYXRlLCBtYXRjaGVzKSB7XG4gICAgICAgIGlmIChwYXJlbnROb2RlIGluc3RhbmNlb2YgRGVidWdFbGVtZW50KSB7XG4gICAgICAgICAgICBwYXJlbnROb2RlLmNoaWxkTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChwcmVkaWNhdGUobm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIERlYnVnRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBfcXVlcnlOb2RlQ2hpbGRyZW4obm9kZSwgcHJlZGljYXRlLCBtYXRjaGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBOZWVkIHRvIGtlZXAgdGhlIG5vZGVzIGluIGEgZ2xvYmFsIE1hcCBzbyB0aGF0IG11bHRpcGxlIGFuZ3VsYXIgYXBwcyBhcmUgc3VwcG9ydGVkLlxuICAgIHZhciAvKiogQHR5cGUgez99ICovIF9uYXRpdmVOb2RlVG9EZWJ1Z05vZGUgPSBuZXcgTWFwKCk7XG4gICAgLyoqXG4gICAgICogXFxAZXhwZXJpbWVudGFsXG4gICAgICogQHBhcmFtIHs/fSBuYXRpdmVOb2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXREZWJ1Z05vZGUobmF0aXZlTm9kZSkge1xuICAgICAgICByZXR1cm4gX25hdGl2ZU5vZGVUb0RlYnVnTm9kZS5nZXQobmF0aXZlTm9kZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbm9kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5kZXhEZWJ1Z05vZGUobm9kZSkge1xuICAgICAgICBfbmF0aXZlTm9kZVRvRGVidWdOb2RlLnNldChub2RlLm5hdGl2ZU5vZGUsIG5vZGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlbW92ZURlYnVnTm9kZUZyb21JbmRleChub2RlKSB7XG4gICAgICAgIF9uYXRpdmVOb2RlVG9EZWJ1Z05vZGUuZGVsZXRlKG5vZGUubmF0aXZlTm9kZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfcmVmbGVjdG9yKCkge1xuICAgICAgICByZXR1cm4gcmVmbGVjdG9yO1xuICAgIH1cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBfQ09SRV9QTEFURk9STV9QUk9WSURFUlMgPSBbXG4gICAgICAgIFBsYXRmb3JtUmVmXyxcbiAgICAgICAgeyBwcm92aWRlOiBQbGF0Zm9ybVJlZiwgdXNlRXhpc3Rpbmc6IFBsYXRmb3JtUmVmXyB9LFxuICAgICAgICB7IHByb3ZpZGU6IFJlZmxlY3RvciwgdXNlRmFjdG9yeTogX3JlZmxlY3RvciwgZGVwczogW10gfSxcbiAgICAgICAgeyBwcm92aWRlOiBSZWZsZWN0b3JSZWFkZXIsIHVzZUV4aXN0aW5nOiBSZWZsZWN0b3IgfSxcbiAgICAgICAgVGVzdGFiaWxpdHlSZWdpc3RyeSxcbiAgICAgICAgQ29uc29sZSxcbiAgICBdO1xuICAgIC8qKlxuICAgICAqIFRoaXMgcGxhdGZvcm0gaGFzIHRvIGJlIGluY2x1ZGVkIGluIGFueSBvdGhlciBwbGF0Zm9ybVxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHBsYXRmb3JtQ29yZSA9IGNyZWF0ZVBsYXRmb3JtRmFjdG9yeShudWxsLCAnY29yZScsIF9DT1JFX1BMQVRGT1JNX1BST1ZJREVSUyk7XG5cbiAgICAvKipcbiAgICAgKiBAZXhwZXJpbWVudGFsIGkxOG4gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gICAgICovXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gTE9DQUxFX0lEID0gbmV3IE9wYXF1ZVRva2VuKCdMb2NhbGVJZCcpO1xuICAgIC8qKlxuICAgICAqIEBleHBlcmltZW50YWwgaTE4biBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAgICAgKi9cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBUUkFOU0xBVElPTlMgPSBuZXcgT3BhcXVlVG9rZW4oJ1RyYW5zbGF0aW9ucycpO1xuICAgIC8qKlxuICAgICAqIEBleHBlcmltZW50YWwgaTE4biBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAgICAgKi9cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBUUkFOU0xBVElPTlNfRk9STUFUID0gbmV3IE9wYXF1ZVRva2VuKCdUcmFuc2xhdGlvbnNGb3JtYXQnKTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gX2l0ZXJhYmxlRGlmZmVyc0ZhY3RvcnkoKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0SXRlcmFibGVEaWZmZXJzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9rZXlWYWx1ZURpZmZlcnNGYWN0b3J5KCkge1xuICAgICAgICByZXR1cm4gZGVmYXVsdEtleVZhbHVlRGlmZmVycztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/PX0gbG9jYWxlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfbG9jYWxlRmFjdG9yeShsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZSB8fCAnZW4tVVMnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1vZHVsZSBpbmNsdWRlcyB0aGUgcHJvdmlkZXJzIG9mIFxcQGFuZ3VsYXIvY29yZSB0aGF0IGFyZSBuZWVkZWRcbiAgICAgKiB0byBib290c3RyYXAgY29tcG9uZW50cyB2aWEgYEFwcGxpY2F0aW9uUmVmYC5cbiAgICAgKlxuICAgICAqIFxcQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBBcHBsaWNhdGlvbk1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFwcGxpY2F0aW9uTW9kdWxlKCkge1xuICAgICAgICB9XG4gICAgICAgIEFwcGxpY2F0aW9uTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQXBwbGljYXRpb25SZWZfLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogQXBwbGljYXRpb25SZWYsIHVzZUV4aXN0aW5nOiBBcHBsaWNhdGlvblJlZl8gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBBcHBsaWNhdGlvbkluaXRTdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29tcGlsZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQVBQX0lEX1JBTkRPTV9QUk9WSURFUixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBWaWV3VXRpbHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQW5pbWF0aW9uUXVldWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBwcm92aWRlOiBJdGVyYWJsZURpZmZlcnMsIHVzZUZhY3Rvcnk6IF9pdGVyYWJsZURpZmZlcnNGYWN0b3J5IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBwcm92aWRlOiBLZXlWYWx1ZURpZmZlcnMsIHVzZUZhY3Rvcnk6IF9rZXlWYWx1ZURpZmZlcnNGYWN0b3J5IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBMT0NBTEVfSUQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZUZhY3Rvcnk6IF9sb2NhbGVGYWN0b3J5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXBzOiBbW25ldyBJbmplY3QoTE9DQUxFX0lEKSwgbmV3IE9wdGlvbmFsKCksIG5ldyBTa2lwU2VsZigpXV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIEFwcGxpY2F0aW9uTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4gICAgICAgIHJldHVybiBBcHBsaWNhdGlvbk1vZHVsZTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIEZJTExfU1RZTEVfRkxBRyA9ICd0cnVlJzsgLy8gVE9ETyAobWF0c2tvKTogY2hhbmdlIHRvIGJvb2xlYW5cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBBTllfU1RBVEUgPSAnKic7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gREVGQVVMVF9TVEFURSA9ICcqJztcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBFTVBUWV9TVEFURSA9ICd2b2lkJztcblxuICAgIHZhciBBbmltYXRpb25Hcm91cFBsYXllciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IF9wbGF5ZXJzXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBBbmltYXRpb25Hcm91cFBsYXllcihfcGxheWVycykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuX3BsYXllcnMgPSBfcGxheWVycztcbiAgICAgICAgICAgIHRoaXMuX29uRG9uZUZucyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fb25TdGFydEZucyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnRQbGF5ZXIgPSBudWxsO1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgICAgIHZhciB0b3RhbCA9IHRoaXMuX3BsYXllcnMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHRvdGFsID09IDApIHtcbiAgICAgICAgICAgICAgICBzY2hlZHVsZU1pY3JvVGFzayhmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fb25GaW5pc2goKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBsYXllcikge1xuICAgICAgICAgICAgICAgICAgICBwbGF5ZXIucGFyZW50UGxheWVyID0gX3RoaXM7XG4gICAgICAgICAgICAgICAgICAgIHBsYXllci5vbkRvbmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCsrY291bnQgPj0gdG90YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fb25GaW5pc2goKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBbmltYXRpb25Hcm91cFBsYXllci5wcm90b3R5cGUuX29uRmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9maW5pc2hlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vbkRvbmVGbnMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKCk7IH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX29uRG9uZUZucyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEFuaW1hdGlvbkdyb3VwUGxheWVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9wbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBsYXllcikgeyByZXR1cm4gcGxheWVyLmluaXQoKTsgfSk7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBbmltYXRpb25Hcm91cFBsYXllci5wcm90b3R5cGUub25TdGFydCA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLl9vblN0YXJ0Rm5zLnB1c2goZm4pOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBmblxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQW5pbWF0aW9uR3JvdXBQbGF5ZXIucHJvdG90eXBlLm9uRG9uZSA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLl9vbkRvbmVGbnMucHVzaChmbik7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQW5pbWF0aW9uR3JvdXBQbGF5ZXIucHJvdG90eXBlLmhhc1N0YXJ0ZWQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zdGFydGVkOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEFuaW1hdGlvbkdyb3VwUGxheWVyLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFpc1ByZXNlbnQodGhpcy5wYXJlbnRQbGF5ZXIpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzU3RhcnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25TdGFydEZucy5mb3JFYWNoKGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25TdGFydEZucyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHsgcmV0dXJuIHBsYXllci5wbGF5KCk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEFuaW1hdGlvbkdyb3VwUGxheWVyLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fcGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHsgcmV0dXJuIHBsYXllci5wYXVzZSgpOyB9KTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBbmltYXRpb25Hcm91cFBsYXllci5wcm90b3R5cGUucmVzdGFydCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fcGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHsgcmV0dXJuIHBsYXllci5yZXN0YXJ0KCk7IH0pOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEFuaW1hdGlvbkdyb3VwUGxheWVyLnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9vbkZpbmlzaCgpO1xuICAgICAgICAgICAgdGhpcy5fcGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHsgcmV0dXJuIHBsYXllci5maW5pc2goKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQW5pbWF0aW9uR3JvdXBQbGF5ZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2Rlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX29uRmluaXNoKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHsgcmV0dXJuIHBsYXllci5kZXN0cm95KCk7IH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQW5pbWF0aW9uR3JvdXBQbGF5ZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fcGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHsgcmV0dXJuIHBsYXllci5yZXNldCgpOyB9KTtcbiAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gcFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQW5pbWF0aW9uR3JvdXBQbGF5ZXIucHJvdG90eXBlLnNldFBvc2l0aW9uID0gZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgIHRoaXMuX3BsYXllcnMuZm9yRWFjaChmdW5jdGlvbiAocGxheWVyKSB7IHBsYXllci5zZXRQb3NpdGlvbihwKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQW5pbWF0aW9uR3JvdXBQbGF5ZXIucHJvdG90eXBlLmdldFBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWluID0gMDtcbiAgICAgICAgICAgIHRoaXMuX3BsYXllcnMuZm9yRWFjaChmdW5jdGlvbiAocGxheWVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcCA9IHBsYXllci5nZXRQb3NpdGlvbigpO1xuICAgICAgICAgICAgICAgIG1pbiA9IE1hdGgubWluKHAsIG1pbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBtaW47XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBbmltYXRpb25Hcm91cFBsYXllci5wcm90b3R5cGUsIFwicGxheWVyc1wiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcGxheWVyczsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBBbmltYXRpb25Hcm91cFBsYXllcjtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIGBBbmltYXRpb25LZXlmcmFtZWAgY29uc2lzdHMgb2YgYSBzZXJpZXMgb2Ygc3R5bGVzIChjb250YWluZWQgd2l0aGluIHtcXEBsaW5rIEFuaW1hdGlvblN0eWxlc1xuICAgICAqIGBBbmltYXRpb25TdHlsZXNgfSlcbiAgICAgKiBhbmQgYW4gb2Zmc2V0IHZhbHVlIGluZGljYXRpbmcgd2hlbiB0aG9zZSBzdHlsZXMgYXJlIGFwcGxpZWQgd2l0aGluIHRoZSBgZHVyYXRpb24vZGVsYXkvZWFzaW5nYFxuICAgICAqIHRpbWluZ3MuXG4gICAgICogYEFuaW1hdGlvbktleWZyYW1lYCBpcyBtb3N0bHkgYW4gaW50ZXJuYWwgY2xhc3Mgd2hpY2ggaXMgZGVzaWduZWQgdG8gYmUgdXNlZCBhbG9uZ3NpZGUge1xcQGxpbmtcbiAgICAgKiBSZW5kZXJlciNhbmltYXRlLWFuY2hvciBgUmVuZGVyZXIuYW5pbWF0ZWB9LlxuICAgICAqXG4gICAgICogXFxAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBBbmltYXRpb25LZXlmcmFtZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IG9mZnNldFxuICAgICAgICAgKiBAcGFyYW0gez99IHN0eWxlc1xuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gQW5pbWF0aW9uS2V5ZnJhbWUob2Zmc2V0LCBzdHlsZXMpIHtcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgdGhpcy5zdHlsZXMgPSBzdHlsZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFuaW1hdGlvbktleWZyYW1lO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBcXEBleHBlcmltZW50YWwgQW5pbWF0aW9uIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICAgIHZhciBBbmltYXRpb25QbGF5ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBBbmltYXRpb25QbGF5ZXIoKSB7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBhYnN0cmFjdFxuICAgICAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLm9uRG9uZSA9IGZ1bmN0aW9uIChmbikgeyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEFuaW1hdGlvblBsYXllci5wcm90b3R5cGUub25TdGFydCA9IGZ1bmN0aW9uIChmbikgeyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAYWJzdHJhY3RcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEFuaW1hdGlvblBsYXllci5wcm90b3R5cGUuaGFzU3RhcnRlZCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBhYnN0cmFjdFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLnJlc3RhcnQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAYWJzdHJhY3RcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEFuaW1hdGlvblBsYXllci5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAYWJzdHJhY3RcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEFuaW1hdGlvblBsYXllci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAYWJzdHJhY3RcbiAgICAgICAgICogQHBhcmFtIHs/fSBwXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLnNldFBvc2l0aW9uID0gZnVuY3Rpb24gKHApIHsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBhYnN0cmFjdFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5nZXRQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFuaW1hdGlvblBsYXllci5wcm90b3R5cGUsIFwicGFyZW50UGxheWVyXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHRocm93IG5ldyBFcnJvcignTk9UIElNUExFTUVOVEVEOiBCYXNlIENsYXNzJyk7IH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gcGxheWVyXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwbGF5ZXIpIHsgdGhyb3cgbmV3IEVycm9yKCdOT1QgSU1QTEVNRU5URUQ6IEJhc2UgQ2xhc3MnKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBBbmltYXRpb25QbGF5ZXI7XG4gICAgfSgpKTtcbiAgICB2YXIgTm9PcEFuaW1hdGlvblBsYXllciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE5vT3BBbmltYXRpb25QbGF5ZXIoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5fb25Eb25lRm5zID0gW107XG4gICAgICAgICAgICB0aGlzLl9vblN0YXJ0Rm5zID0gW107XG4gICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnBhcmVudFBsYXllciA9IG51bGw7XG4gICAgICAgICAgICBzY2hlZHVsZU1pY3JvVGFzayhmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fb25GaW5pc2goKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFxcQGludGVybmFsXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBOb09wQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5fb25GaW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9vbkRvbmVGbnMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKCk7IH0pO1xuICAgICAgICAgICAgdGhpcy5fb25Eb25lRm5zID0gW107XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBOb09wQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5vblN0YXJ0ID0gZnVuY3Rpb24gKGZuKSB7IHRoaXMuX29uU3RhcnRGbnMucHVzaChmbik7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBOb09wQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5vbkRvbmUgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5fb25Eb25lRm5zLnB1c2goZm4pOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIE5vT3BBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLmhhc1N0YXJ0ZWQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zdGFydGVkOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIE5vT3BBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgTm9PcEFuaW1hdGlvblBsYXllci5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5oYXNTdGFydGVkKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vblN0YXJ0Rm5zLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmbigpOyB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vblN0YXJ0Rm5zID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBOb09wQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBOb09wQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5yZXN0YXJ0ID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIE5vT3BBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fb25GaW5pc2goKTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBOb09wQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIE5vT3BBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBwXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBOb09wQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uIChwKSB7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgTm9PcEFuaW1hdGlvblBsYXllci5wcm90b3R5cGUuZ2V0UG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7IHJldHVybiAwOyB9O1xuICAgICAgICByZXR1cm4gTm9PcEFuaW1hdGlvblBsYXllcjtcbiAgICB9KCkpO1xuXG4gICAgdmFyIEFuaW1hdGlvblNlcXVlbmNlUGxheWVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gX3BsYXllcnNcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvblNlcXVlbmNlUGxheWVyKF9wbGF5ZXJzKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5fcGxheWVycyA9IF9wbGF5ZXJzO1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudEluZGV4ID0gMDtcbiAgICAgICAgICAgIHRoaXMuX29uRG9uZUZucyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fb25TdGFydEZucyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnRQbGF5ZXIgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fcGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHsgcGxheWVyLnBhcmVudFBsYXllciA9IF90aGlzOyB9KTtcbiAgICAgICAgICAgIHRoaXMuX29uTmV4dChmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gc3RhcnRcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEFuaW1hdGlvblNlcXVlbmNlUGxheWVyLnByb3RvdHlwZS5fb25OZXh0ID0gZnVuY3Rpb24gKHN0YXJ0KSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2ZpbmlzaGVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wbGF5ZXJzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlUGxheWVyID0gbmV3IE5vT3BBbmltYXRpb25QbGF5ZXIoKTtcbiAgICAgICAgICAgICAgICBzY2hlZHVsZU1pY3JvVGFzayhmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fb25GaW5pc2goKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9jdXJyZW50SW5kZXggPj0gdGhpcy5fcGxheWVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmVQbGF5ZXIgPSBuZXcgTm9PcEFuaW1hdGlvblBsYXllcigpO1xuICAgICAgICAgICAgICAgIHRoaXMuX29uRmluaXNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwbGF5ZXIgPSB0aGlzLl9wbGF5ZXJzW3RoaXMuX2N1cnJlbnRJbmRleCsrXTtcbiAgICAgICAgICAgICAgICBwbGF5ZXIub25Eb25lKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9vbk5leHQodHJ1ZSk7IH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZVBsYXllciA9IHBsYXllcjtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGxheWVyLnBsYXkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQW5pbWF0aW9uU2VxdWVuY2VQbGF5ZXIucHJvdG90eXBlLl9vbkZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fZmluaXNoZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9maW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25Eb25lRm5zLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmbigpOyB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vbkRvbmVGbnMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBbmltYXRpb25TZXF1ZW5jZVBsYXllci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fcGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHsgcmV0dXJuIHBsYXllci5pbml0KCk7IH0pOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBmblxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQW5pbWF0aW9uU2VxdWVuY2VQbGF5ZXIucHJvdG90eXBlLm9uU3RhcnQgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5fb25TdGFydEZucy5wdXNoKGZuKTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEFuaW1hdGlvblNlcXVlbmNlUGxheWVyLnByb3RvdHlwZS5vbkRvbmUgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5fb25Eb25lRm5zLnB1c2goZm4pOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEFuaW1hdGlvblNlcXVlbmNlUGxheWVyLnByb3RvdHlwZS5oYXNTdGFydGVkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc3RhcnRlZDsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBbmltYXRpb25TZXF1ZW5jZVBsYXllci5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghaXNQcmVzZW50KHRoaXMucGFyZW50UGxheWVyKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmhhc1N0YXJ0ZWQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX29uU3RhcnRGbnMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKCk7IH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX29uU3RhcnRGbnMgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2FjdGl2ZVBsYXllci5wbGF5KCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQW5pbWF0aW9uU2VxdWVuY2VQbGF5ZXIucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9hY3RpdmVQbGF5ZXIucGF1c2UoKTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBbmltYXRpb25TZXF1ZW5jZVBsYXllci5wcm90b3R5cGUucmVzdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wbGF5ZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wbGF5ZXJzWzBdLnJlc3RhcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBbmltYXRpb25TZXF1ZW5jZVBsYXllci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9wbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBsYXllcikgeyByZXR1cm4gcGxheWVyLnJlc2V0KCk7IH0pO1xuICAgICAgICAgICAgdGhpcy5fZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEFuaW1hdGlvblNlcXVlbmNlUGxheWVyLnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9vbkZpbmlzaCgpO1xuICAgICAgICAgICAgdGhpcy5fcGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHsgcmV0dXJuIHBsYXllci5maW5pc2goKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQW5pbWF0aW9uU2VxdWVuY2VQbGF5ZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2Rlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX29uRmluaXNoKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHsgcmV0dXJuIHBsYXllci5kZXN0cm95KCk7IH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlUGxheWVyID0gbmV3IE5vT3BBbmltYXRpb25QbGF5ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gcFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQW5pbWF0aW9uU2VxdWVuY2VQbGF5ZXIucHJvdG90eXBlLnNldFBvc2l0aW9uID0gZnVuY3Rpb24gKHApIHsgdGhpcy5fcGxheWVyc1swXS5zZXRQb3NpdGlvbihwKTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBbmltYXRpb25TZXF1ZW5jZVBsYXllci5wcm90b3R5cGUuZ2V0UG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wbGF5ZXJzWzBdLmdldFBvc2l0aW9uKCk7IH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBbmltYXRpb25TZXF1ZW5jZVBsYXllci5wcm90b3R5cGUsIFwicGxheWVyc1wiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcGxheWVyczsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBBbmltYXRpb25TZXF1ZW5jZVBsYXllcjtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkMTMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAgICAgKi9cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBBVVRPX1NUWUxFID0gJyonO1xuICAgIC8qKlxuICAgICAqIE1ldGFkYXRhIHJlcHJlc2VudGluZyB0aGUgZW50cnkgb2YgYW5pbWF0aW9ucy5cbiAgICAgKiBJbnN0YW5jZXMgb2YgdGhpcyBjbGFzcyBhcmUgcHJvdmlkZWQgdmlhIHRoZSBhbmltYXRpb24gRFNMIHdoZW4gdGhlIHtcXEBsaW5rIHRyaWdnZXIgdHJpZ2dlclxuICAgICAqIGFuaW1hdGlvbiBmdW5jdGlvbn0gaXMgY2FsbGVkLlxuICAgICAqXG4gICAgICogXFxAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAgICAgKi9cbiAgICB2YXIgQW5pbWF0aW9uRW50cnlNZXRhZGF0YSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgICAgICogQHBhcmFtIHs/fSBkZWZpbml0aW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gQW5pbWF0aW9uRW50cnlNZXRhZGF0YShuYW1lLCBkZWZpbml0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgIHRoaXMuZGVmaW5pdGlvbnMgPSBkZWZpbml0aW9ucztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQW5pbWF0aW9uRW50cnlNZXRhZGF0YTtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIFxcQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gICAgICogQGFic3RyYWN0XG4gICAgICovXG4gICAgdmFyIEFuaW1hdGlvblN0YXRlTWV0YWRhdGEgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBBbmltYXRpb25TdGF0ZU1ldGFkYXRhKCkge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBbmltYXRpb25TdGF0ZU1ldGFkYXRhO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogTWV0YWRhdGEgcmVwcmVzZW50aW5nIHRoZSBlbnRyeSBvZiBhbmltYXRpb25zLlxuICAgICAqIEluc3RhbmNlcyBvZiB0aGlzIGNsYXNzIGFyZSBwcm92aWRlZCB2aWEgdGhlIGFuaW1hdGlvbiBEU0wgd2hlbiB0aGUge1xcQGxpbmsgc3RhdGUgc3RhdGUgYW5pbWF0aW9uXG4gICAgICogZnVuY3Rpb259IGlzIGNhbGxlZC5cbiAgICAgKlxuICAgICAqIFxcQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gICAgICovXG4gICAgdmFyIEFuaW1hdGlvblN0YXRlRGVjbGFyYXRpb25NZXRhZGF0YSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQxMyhBbmltYXRpb25TdGF0ZURlY2xhcmF0aW9uTWV0YWRhdGEsIF9zdXBlcik7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHN0YXRlTmFtZUV4cHJcbiAgICAgICAgICogQHBhcmFtIHs/fSBzdHlsZXNcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvblN0YXRlRGVjbGFyYXRpb25NZXRhZGF0YShzdGF0ZU5hbWVFeHByLCBzdHlsZXMpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZU5hbWVFeHByID0gc3RhdGVOYW1lRXhwcjtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVzID0gc3R5bGVzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBbmltYXRpb25TdGF0ZURlY2xhcmF0aW9uTWV0YWRhdGE7XG4gICAgfShBbmltYXRpb25TdGF0ZU1ldGFkYXRhKSk7XG4gICAgLyoqXG4gICAgICogTWV0YWRhdGEgcmVwcmVzZW50aW5nIHRoZSBlbnRyeSBvZiBhbmltYXRpb25zLlxuICAgICAqIEluc3RhbmNlcyBvZiB0aGlzIGNsYXNzIGFyZSBwcm92aWRlZCB2aWEgdGhlIGFuaW1hdGlvbiBEU0wgd2hlbiB0aGVcbiAgICAgKiB7XFxAbGluayB0cmFuc2l0aW9uIHRyYW5zaXRpb24gYW5pbWF0aW9uIGZ1bmN0aW9ufSBpcyBjYWxsZWQuXG4gICAgICpcbiAgICAgKiBcXEBleHBlcmltZW50YWwgQW5pbWF0aW9uIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLlxuICAgICAqL1xuICAgIHZhciBBbmltYXRpb25TdGF0ZVRyYW5zaXRpb25NZXRhZGF0YSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQxMyhBbmltYXRpb25TdGF0ZVRyYW5zaXRpb25NZXRhZGF0YSwgX3N1cGVyKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gc3RhdGVDaGFuZ2VFeHByXG4gICAgICAgICAqIEBwYXJhbSB7P30gc3RlcHNcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvblN0YXRlVHJhbnNpdGlvbk1ldGFkYXRhKHN0YXRlQ2hhbmdlRXhwciwgc3RlcHMpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZUV4cHIgPSBzdGF0ZUNoYW5nZUV4cHI7XG4gICAgICAgICAgICB0aGlzLnN0ZXBzID0gc3RlcHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFuaW1hdGlvblN0YXRlVHJhbnNpdGlvbk1ldGFkYXRhO1xuICAgIH0oQW5pbWF0aW9uU3RhdGVNZXRhZGF0YSkpO1xuICAgIC8qKlxuICAgICAqIFxcQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gICAgICogQGFic3RyYWN0XG4gICAgICovXG4gICAgdmFyIEFuaW1hdGlvbk1ldGFkYXRhID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQW5pbWF0aW9uTWV0YWRhdGEoKSB7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFuaW1hdGlvbk1ldGFkYXRhO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogTWV0YWRhdGEgcmVwcmVzZW50aW5nIHRoZSBlbnRyeSBvZiBhbmltYXRpb25zLlxuICAgICAqIEluc3RhbmNlcyBvZiB0aGlzIGNsYXNzIGFyZSBwcm92aWRlZCB2aWEgdGhlIGFuaW1hdGlvbiBEU0wgd2hlbiB0aGUge1xcQGxpbmsga2V5ZnJhbWVzIGtleWZyYW1lc1xuICAgICAqIGFuaW1hdGlvbiBmdW5jdGlvbn0gaXMgY2FsbGVkLlxuICAgICAqXG4gICAgICogXFxAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAgICAgKi9cbiAgICB2YXIgQW5pbWF0aW9uS2V5ZnJhbWVzU2VxdWVuY2VNZXRhZGF0YSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQxMyhBbmltYXRpb25LZXlmcmFtZXNTZXF1ZW5jZU1ldGFkYXRhLCBfc3VwZXIpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBzdGVwc1xuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gQW5pbWF0aW9uS2V5ZnJhbWVzU2VxdWVuY2VNZXRhZGF0YShzdGVwcykge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnN0ZXBzID0gc3RlcHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFuaW1hdGlvbktleWZyYW1lc1NlcXVlbmNlTWV0YWRhdGE7XG4gICAgfShBbmltYXRpb25NZXRhZGF0YSkpO1xuICAgIC8qKlxuICAgICAqIE1ldGFkYXRhIHJlcHJlc2VudGluZyB0aGUgZW50cnkgb2YgYW5pbWF0aW9ucy5cbiAgICAgKiBJbnN0YW5jZXMgb2YgdGhpcyBjbGFzcyBhcmUgcHJvdmlkZWQgdmlhIHRoZSBhbmltYXRpb24gRFNMIHdoZW4gdGhlIHtcXEBsaW5rIHN0eWxlIHN0eWxlIGFuaW1hdGlvblxuICAgICAqIGZ1bmN0aW9ufSBpcyBjYWxsZWQuXG4gICAgICpcbiAgICAgKiBcXEBleHBlcmltZW50YWwgQW5pbWF0aW9uIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLlxuICAgICAqL1xuICAgIHZhciBBbmltYXRpb25TdHlsZU1ldGFkYXRhID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDEzKEFuaW1hdGlvblN0eWxlTWV0YWRhdGEsIF9zdXBlcik7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHN0eWxlc1xuICAgICAgICAgKiBAcGFyYW0gez89fSBvZmZzZXRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvblN0eWxlTWV0YWRhdGEoc3R5bGVzLCBvZmZzZXQpIHtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPT09IHZvaWQgMCkgeyBvZmZzZXQgPSBudWxsOyB9XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVzID0gc3R5bGVzO1xuICAgICAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFuaW1hdGlvblN0eWxlTWV0YWRhdGE7XG4gICAgfShBbmltYXRpb25NZXRhZGF0YSkpO1xuICAgIC8qKlxuICAgICAqIE1ldGFkYXRhIHJlcHJlc2VudGluZyB0aGUgZW50cnkgb2YgYW5pbWF0aW9ucy5cbiAgICAgKiBJbnN0YW5jZXMgb2YgdGhpcyBjbGFzcyBhcmUgcHJvdmlkZWQgdmlhIHRoZSBhbmltYXRpb24gRFNMIHdoZW4gdGhlIHtcXEBsaW5rIGFuaW1hdGUgYW5pbWF0ZVxuICAgICAqIGFuaW1hdGlvbiBmdW5jdGlvbn0gaXMgY2FsbGVkLlxuICAgICAqXG4gICAgICogXFxAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAgICAgKi9cbiAgICB2YXIgQW5pbWF0aW9uQW5pbWF0ZU1ldGFkYXRhID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDEzKEFuaW1hdGlvbkFuaW1hdGVNZXRhZGF0YSwgX3N1cGVyKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdGltaW5nc1xuICAgICAgICAgKiBAcGFyYW0gez99IHN0eWxlc1xuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gQW5pbWF0aW9uQW5pbWF0ZU1ldGFkYXRhKHRpbWluZ3MsIHN0eWxlcykge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnRpbWluZ3MgPSB0aW1pbmdzO1xuICAgICAgICAgICAgdGhpcy5zdHlsZXMgPSBzdHlsZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFuaW1hdGlvbkFuaW1hdGVNZXRhZGF0YTtcbiAgICB9KEFuaW1hdGlvbk1ldGFkYXRhKSk7XG4gICAgLyoqXG4gICAgICogXFxAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICB2YXIgQW5pbWF0aW9uV2l0aFN0ZXBzTWV0YWRhdGEgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMTMoQW5pbWF0aW9uV2l0aFN0ZXBzTWV0YWRhdGEsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvbldpdGhTdGVwc01ldGFkYXRhKCkge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFuaW1hdGlvbldpdGhTdGVwc01ldGFkYXRhLnByb3RvdHlwZSwgXCJzdGVwc1wiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyB0aHJvdyBuZXcgRXJyb3IoJ05PVCBJTVBMRU1FTlRFRDogQmFzZSBDbGFzcycpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIEFuaW1hdGlvbldpdGhTdGVwc01ldGFkYXRhO1xuICAgIH0oQW5pbWF0aW9uTWV0YWRhdGEpKTtcbiAgICAvKipcbiAgICAgKiBNZXRhZGF0YSByZXByZXNlbnRpbmcgdGhlIGVudHJ5IG9mIGFuaW1hdGlvbnMuXG4gICAgICogSW5zdGFuY2VzIG9mIHRoaXMgY2xhc3MgYXJlIHByb3ZpZGVkIHZpYSB0aGUgYW5pbWF0aW9uIERTTCB3aGVuIHRoZSB7XFxAbGluayBzZXF1ZW5jZSBzZXF1ZW5jZVxuICAgICAqIGFuaW1hdGlvbiBmdW5jdGlvbn0gaXMgY2FsbGVkLlxuICAgICAqXG4gICAgICogXFxAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAgICAgKi9cbiAgICB2YXIgQW5pbWF0aW9uU2VxdWVuY2VNZXRhZGF0YSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQxMyhBbmltYXRpb25TZXF1ZW5jZU1ldGFkYXRhLCBfc3VwZXIpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBfc3RlcHNcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvblNlcXVlbmNlTWV0YWRhdGEoX3N0ZXBzKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX3N0ZXBzID0gX3N0ZXBzO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBbmltYXRpb25TZXF1ZW5jZU1ldGFkYXRhLnByb3RvdHlwZSwgXCJzdGVwc1wiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc3RlcHM7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gQW5pbWF0aW9uU2VxdWVuY2VNZXRhZGF0YTtcbiAgICB9KEFuaW1hdGlvbldpdGhTdGVwc01ldGFkYXRhKSk7XG4gICAgLyoqXG4gICAgICogTWV0YWRhdGEgcmVwcmVzZW50aW5nIHRoZSBlbnRyeSBvZiBhbmltYXRpb25zLlxuICAgICAqIEluc3RhbmNlcyBvZiB0aGlzIGNsYXNzIGFyZSBwcm92aWRlZCB2aWEgdGhlIGFuaW1hdGlvbiBEU0wgd2hlbiB0aGUge1xcQGxpbmsgZ3JvdXAgZ3JvdXAgYW5pbWF0aW9uXG4gICAgICogZnVuY3Rpb259IGlzIGNhbGxlZC5cbiAgICAgKlxuICAgICAqIFxcQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gICAgICovXG4gICAgdmFyIEFuaW1hdGlvbkdyb3VwTWV0YWRhdGEgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMTMoQW5pbWF0aW9uR3JvdXBNZXRhZGF0YSwgX3N1cGVyKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gX3N0ZXBzXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBBbmltYXRpb25Hcm91cE1ldGFkYXRhKF9zdGVwcykge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9zdGVwcyA9IF9zdGVwcztcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQW5pbWF0aW9uR3JvdXBNZXRhZGF0YS5wcm90b3R5cGUsIFwic3RlcHNcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3N0ZXBzOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIEFuaW1hdGlvbkdyb3VwTWV0YWRhdGE7XG4gICAgfShBbmltYXRpb25XaXRoU3RlcHNNZXRhZGF0YSkpO1xuICAgIC8qKlxuICAgICAqIGBhbmltYXRlYCBpcyBhbiBhbmltYXRpb24tc3BlY2lmaWMgZnVuY3Rpb24gdGhhdCBpcyBkZXNpZ25lZCB0byBiZSB1c2VkIGluc2lkZSBvZiBBbmd1bGFyMidzXG4gICAgICogYW5pbWF0aW9uXG4gICAgICogRFNMIGxhbmd1YWdlLiBJZiB0aGlzIGluZm9ybWF0aW9uIGlzIG5ldywgcGxlYXNlIG5hdmlnYXRlIHRvIHRoZVxuICAgICAqIHtcXEBsaW5rIENvbXBvbmVudCNhbmltYXRpb25zLWFuY2hvciBjb21wb25lbnQgYW5pbWF0aW9ucyBtZXRhZGF0YVxuICAgICAqIHBhZ2V9IHRvIGdhaW4gYSBiZXR0ZXIgdW5kZXJzdGFuZGluZyBvZiBob3cgYW5pbWF0aW9ucyBpbiBBbmd1bGFyMiBhcmUgdXNlZC5cbiAgICAgKlxuICAgICAqIGBhbmltYXRlYCBzcGVjaWZpZXMgYW4gYW5pbWF0aW9uIHN0ZXAgdGhhdCB3aWxsIGFwcGx5IHRoZSBwcm92aWRlZCBgc3R5bGVzYCBkYXRhIGZvciBhIGdpdmVuXG4gICAgICogYW1vdW50IG9mXG4gICAgICogdGltZSBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgYHRpbWluZ2AgZXhwcmVzc2lvbiB2YWx1ZS4gQ2FsbHMgdG8gYGFuaW1hdGVgIGFyZSBleHBlY3RlZCB0byBiZVxuICAgICAqIHVzZWQgd2l0aGluIHtcXEBsaW5rIHNlcXVlbmNlIGFuIGFuaW1hdGlvbiBzZXF1ZW5jZX0sIHtcXEBsaW5rIGdyb3VwIGdyb3VwfSwgb3Ige1xcQGxpbmsgdHJhbnNpdGlvblxuICAgICAqIHRyYW5zaXRpb259LlxuICAgICAqXG4gICAgICogIyMjIFVzYWdlXG4gICAgICpcbiAgICAgKiBUaGUgYGFuaW1hdGVgIGZ1bmN0aW9uIGFjY2VwdHMgdHdvIGlucHV0IHBhcmFtZXRlcnM6IGB0aW1pbmdgIGFuZCBgc3R5bGVzYDpcbiAgICAgKlxuICAgICAqIC0gYHRpbWluZ2AgaXMgYSBzdHJpbmcgYmFzZWQgdmFsdWUgdGhhdCBjYW4gYmUgYSBjb21iaW5hdGlvbiBvZiBhIGR1cmF0aW9uIHdpdGggb3B0aW9uYWxcbiAgICAgKiBkZWxheSBhbmQgZWFzaW5nIHZhbHVlcy4gVGhlIGZvcm1hdCBmb3IgdGhlIGV4cHJlc3Npb24gYnJlYWtzIGRvd24gdG8gYGR1cmF0aW9uIGRlbGF5IGVhc2luZ2BcbiAgICAgKiAodGhlcmVmb3JlIGEgdmFsdWUgc3VjaCBhcyBgMXMgMTAwbXMgZWFzZS1vdXRgIHdpbGwgYmUgcGFyc2UgaXRzZWxmIGludG8gYGR1cmF0aW9uPTEwMDAsXG4gICAgICogZGVsYXk9MTAwLCBlYXNpbmc9ZWFzZS1vdXRgLlxuICAgICAqIElmIGEgbnVtZXJpYyB2YWx1ZSBpcyBwcm92aWRlZCB0aGVuIHRoYXQgd2lsbCBiZSB1c2VkIGFzIHRoZSBgZHVyYXRpb25gIHZhbHVlIGluIG1pbGxpc2Vjb25kXG4gICAgICogZm9ybS5cbiAgICAgKiAtIGBzdHlsZXNgIGlzIHRoZSBzdHlsZSBpbnB1dCBkYXRhIHdoaWNoIGNhbiBlaXRoZXIgYmUgYSBjYWxsIHRvIHtcXEBsaW5rIHN0eWxlIHN0eWxlfSBvciB7XFxAbGlua1xuICAgICAqIGtleWZyYW1lcyBrZXlmcmFtZXN9LlxuICAgICAqIElmIGxlZnQgZW1wdHkgdGhlbiB0aGUgc3R5bGVzIGZyb20gdGhlIGRlc3RpbmF0aW9uIHN0YXRlIHdpbGwgYmUgY29sbGVjdGVkIGFuZCB1c2VkICh0aGlzIGlzXG4gICAgICogdXNlZnVsIHdoZW5cbiAgICAgKiBkZXNjcmliaW5nIGFuIGFuaW1hdGlvbiBzdGVwIHRoYXQgd2lsbCBjb21wbGV0ZSBhbiBhbmltYXRpb24gYnkge1xcQGxpbmtcbiAgICAgKiB0cmFuc2l0aW9uI3RoZS1maW5hbC1hbmltYXRlLWNhbGwgYW5pbWF0aW5nIHRvIHRoZSBmaW5hbCBzdGF0ZX0pLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIHZhcmlvdXMgZnVuY3Rpb25zIGZvciBzcGVjaWZ5aW5nIHRpbWluZyBkYXRhXG4gICAgICogYW5pbWF0ZSg1MDAsIHN0eWxlKC4uLikpXG4gICAgICogYW5pbWF0ZShcIjFzXCIsIHN0eWxlKC4uLikpXG4gICAgICogYW5pbWF0ZShcIjEwMG1zIDAuNXNcIiwgc3R5bGUoLi4uKSlcbiAgICAgKiBhbmltYXRlKFwiNXMgZWFzZVwiLCBzdHlsZSguLi4pKVxuICAgICAqIGFuaW1hdGUoXCI1cyAxMG1zIGN1YmljLWJlemllciguMTcsLjY3LC44OCwuMSlcIiwgc3R5bGUoLi4uKSlcbiAgICAgKlxuICAgICAqIC8vIGVpdGhlciBzdHlsZSgpIG9mIGtleWZyYW1lcygpIGNhbiBiZSB1c2VkXG4gICAgICogYW5pbWF0ZSg1MDAsIHN0eWxlKHsgYmFja2dyb3VuZDogXCJyZWRcIiB9KSlcbiAgICAgKiBhbmltYXRlKDUwMCwga2V5ZnJhbWVzKFtcbiAgICAgKiAgIHN0eWxlKHsgYmFja2dyb3VuZDogXCJibHVlXCIgfSkpLFxuICAgICAqICAgc3R5bGUoeyBiYWNrZ3JvdW5kOiBcInJlZFwiIH0pKVxuICAgICAqIF0pXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvS2V6OFhHV0J4V3VlN3FQN25OdkY/cD1wcmV2aWV3KSlcbiAgICAgKlxuICAgICAqIHtcXEBleGFtcGxlIGNvcmUvYW5pbWF0aW9uL3RzL2RzbC9hbmltYXRpb25fZXhhbXBsZS50cyByZWdpb249J0NvbXBvbmVudCd9XG4gICAgICpcbiAgICAgKiBcXEBleHBlcmltZW50YWwgQW5pbWF0aW9uIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLlxuICAgICAqIEBwYXJhbSB7P30gdGltaW5nXG4gICAgICogQHBhcmFtIHs/PX0gc3R5bGVzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhbmltYXRlKHRpbWluZywgc3R5bGVzKSB7XG4gICAgICAgIGlmIChzdHlsZXMgPT09IHZvaWQgMCkgeyBzdHlsZXMgPSBudWxsOyB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0eWxlc0VudHJ5ID0gc3R5bGVzO1xuICAgICAgICBpZiAoIWlzUHJlc2VudChzdHlsZXNFbnRyeSkpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIEVNUFRZX1NUWUxFID0ge307XG4gICAgICAgICAgICBzdHlsZXNFbnRyeSA9IG5ldyBBbmltYXRpb25TdHlsZU1ldGFkYXRhKFtFTVBUWV9TVFlMRV0sIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQW5pbWF0aW9uQW5pbWF0ZU1ldGFkYXRhKHRpbWluZywgc3R5bGVzRW50cnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgZ3JvdXBgIGlzIGFuIGFuaW1hdGlvbi1zcGVjaWZpYyBmdW5jdGlvbiB0aGF0IGlzIGRlc2lnbmVkIHRvIGJlIHVzZWQgaW5zaWRlIG9mIEFuZ3VsYXIyJ3NcbiAgICAgKiBhbmltYXRpb25cbiAgICAgKiBEU0wgbGFuZ3VhZ2UuIElmIHRoaXMgaW5mb3JtYXRpb24gaXMgbmV3LCBwbGVhc2UgbmF2aWdhdGUgdG8gdGhlXG4gICAgICoge1xcQGxpbmsgQ29tcG9uZW50I2FuaW1hdGlvbnMtYW5jaG9yIGNvbXBvbmVudCBhbmltYXRpb25zIG1ldGFkYXRhXG4gICAgICogcGFnZX0gdG8gZ2FpbiBhIGJldHRlciB1bmRlcnN0YW5kaW5nIG9mIGhvdyBhbmltYXRpb25zIGluIEFuZ3VsYXIyIGFyZSB1c2VkLlxuICAgICAqXG4gICAgICogYGdyb3VwYCBzcGVjaWZpZXMgYSBsaXN0IG9mIGFuaW1hdGlvbiBzdGVwcyB0aGF0IGFyZSBhbGwgcnVuIGluIHBhcmFsbGVsLiBHcm91cGVkIGFuaW1hdGlvbnNcbiAgICAgKiBhcmUgdXNlZnVsIHdoZW4gYSBzZXJpZXMgb2Ygc3R5bGVzIG11c3QgYmUgYW5pbWF0ZWQvY2xvc2VkIG9mZlxuICAgICAqIGF0IGRpZmZlcmVudCBzdGF0cnRpbmcvZW5kaW5nIHRpbWVzLlxuICAgICAqXG4gICAgICogVGhlIGBncm91cGAgZnVuY3Rpb24gY2FuIGVpdGhlciBiZSB1c2VkIHdpdGhpbiBhIHtcXEBsaW5rIHNlcXVlbmNlIHNlcXVlbmNlfSBvciBhIHtcXEBsaW5rIHRyYW5zaXRpb25cbiAgICAgKiB0cmFuc2l0aW9ufVxuICAgICAqIGFuZCBpdCB3aWxsIG9ubHkgY29udGludWUgdG8gdGhlIG5leHQgaW5zdHJ1Y3Rpb24gb25jZSBhbGwgb2YgdGhlIGlubmVyIGFuaW1hdGlvbiBzdGVwc1xuICAgICAqIGhhdmUgY29tcGxldGVkLlxuICAgICAqXG4gICAgICogIyMjIFVzYWdlXG4gICAgICpcbiAgICAgKiBUaGUgYHN0ZXBzYCBkYXRhIHRoYXQgaXMgcGFzc2VkIGludG8gdGhlIGBncm91cGAgYW5pbWF0aW9uIGZ1bmN0aW9uIGNhbiBlaXRoZXIgY29uc2lzdFxuICAgICAqIG9mIHtcXEBsaW5rIHN0eWxlIHN0eWxlfSBvciB7XFxAbGluayBhbmltYXRlIGFuaW1hdGV9IGZ1bmN0aW9uIGNhbGxzLiBFYWNoIGNhbGwgdG8gYHN0eWxlKClgIG9yXG4gICAgICogYGFuaW1hdGUoKWBcbiAgICAgKiB3aXRoaW4gYSBncm91cCB3aWxsIGJlIGV4ZWN1dGVkIGluc3RhbnRseSAodXNlIHtcXEBsaW5rIGtleWZyYW1lcyBrZXlmcmFtZXN9IG9yIGFcbiAgICAgKiB7XFxAbGluayBhbmltYXRlI3VzYWdlIGFuaW1hdGUoKSB3aXRoIGEgZGVsYXkgdmFsdWV9IHRvIG9mZnNldCBzdHlsZXMgdG8gYmUgYXBwbGllZCBhdCBhIGxhdGVyXG4gICAgICogdGltZSkuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogZ3JvdXAoW1xuICAgICAqICAgYW5pbWF0ZShcIjFzXCIsIHsgYmFja2dyb3VuZDogXCJibGFja1wiIH0pKVxuICAgICAqICAgYW5pbWF0ZShcIjJzXCIsIHsgY29sb3I6IFwid2hpdGVcIiB9KSlcbiAgICAgKiBdKVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L0tlejhYR1dCeFd1ZTdxUDduTnZGP3A9cHJldmlldykpXG4gICAgICpcbiAgICAgKiB7XFxAZXhhbXBsZSBjb3JlL2FuaW1hdGlvbi90cy9kc2wvYW5pbWF0aW9uX2V4YW1wbGUudHMgcmVnaW9uPSdDb21wb25lbnQnfVxuICAgICAqXG4gICAgICogXFxAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAgICAgKiBAcGFyYW0gez99IHN0ZXBzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBncm91cChzdGVwcykge1xuICAgICAgICByZXR1cm4gbmV3IEFuaW1hdGlvbkdyb3VwTWV0YWRhdGEoc3RlcHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgc2VxdWVuY2VgIGlzIGFuIGFuaW1hdGlvbi1zcGVjaWZpYyBmdW5jdGlvbiB0aGF0IGlzIGRlc2lnbmVkIHRvIGJlIHVzZWQgaW5zaWRlIG9mIEFuZ3VsYXIyJ3NcbiAgICAgKiBhbmltYXRpb25cbiAgICAgKiBEU0wgbGFuZ3VhZ2UuIElmIHRoaXMgaW5mb3JtYXRpb24gaXMgbmV3LCBwbGVhc2UgbmF2aWdhdGUgdG8gdGhlXG4gICAgICoge1xcQGxpbmsgQ29tcG9uZW50I2FuaW1hdGlvbnMtYW5jaG9yIGNvbXBvbmVudCBhbmltYXRpb25zIG1ldGFkYXRhXG4gICAgICogcGFnZX0gdG8gZ2FpbiBhIGJldHRlciB1bmRlcnN0YW5kaW5nIG9mIGhvdyBhbmltYXRpb25zIGluIEFuZ3VsYXIyIGFyZSB1c2VkLlxuICAgICAqXG4gICAgICogYHNlcXVlbmNlYCBTcGVjaWZpZXMgYSBsaXN0IG9mIGFuaW1hdGlvbiBzdGVwcyB0aGF0IGFyZSBydW4gb25lIGJ5IG9uZS4gKGBzZXF1ZW5jZWAgaXMgdXNlZFxuICAgICAqIGJ5IGRlZmF1bHQgd2hlbiBhbiBhcnJheSBpcyBwYXNzZWQgYXMgYW5pbWF0aW9uIGRhdGEgaW50byB7XFxAbGluayB0cmFuc2l0aW9uIHRyYW5zaXRpb259LilcbiAgICAgKlxuICAgICAqIFRoZSBgc2VxdWVuY2VgIGZ1bmN0aW9uIGNhbiBlaXRoZXIgYmUgdXNlZCB3aXRoaW4gYSB7XFxAbGluayBncm91cCBncm91cH0gb3IgYSB7XFxAbGluayB0cmFuc2l0aW9uXG4gICAgICogdHJhbnNpdGlvbn1cbiAgICAgKiBhbmQgaXQgd2lsbCBvbmx5IGNvbnRpbnVlIHRvIHRoZSBuZXh0IGluc3RydWN0aW9uIG9uY2UgZWFjaCBvZiB0aGUgaW5uZXIgYW5pbWF0aW9uIHN0ZXBzXG4gICAgICogaGF2ZSBjb21wbGV0ZWQuXG4gICAgICpcbiAgICAgKiBUbyBwZXJmb3JtIGFuaW1hdGlvbiBzdHlsaW5nIGluIHBhcmFsbGVsIHdpdGggb3RoZXIgYW5pbWF0aW9uIHN0ZXBzIHRoZW5cbiAgICAgKiBoYXZlIGEgbG9vayBhdCB0aGUge1xcQGxpbmsgZ3JvdXAgZ3JvdXB9IGFuaW1hdGlvbiBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqICMjIyBVc2FnZVxuICAgICAqXG4gICAgICogVGhlIGBzdGVwc2AgZGF0YSB0aGF0IGlzIHBhc3NlZCBpbnRvIHRoZSBgc2VxdWVuY2VgIGFuaW1hdGlvbiBmdW5jdGlvbiBjYW4gZWl0aGVyIGNvbnNpc3RcbiAgICAgKiBvZiB7XFxAbGluayBzdHlsZSBzdHlsZX0gb3Ige1xcQGxpbmsgYW5pbWF0ZSBhbmltYXRlfSBmdW5jdGlvbiBjYWxscy4gQSBjYWxsIHRvIGBzdHlsZSgpYCB3aWxsIGFwcGx5XG4gICAgICogdGhlXG4gICAgICogcHJvdmlkZWQgc3R5bGluZyBkYXRhIGltbWVkaWF0ZWx5IHdoaWxlIGEgY2FsbCB0byBgYW5pbWF0ZSgpYCB3aWxsIGFwcGx5IGl0cyBzdHlsaW5nXG4gICAgICogZGF0YSBvdmVyIGEgZ2l2ZW4gdGltZSBkZXBlbmRpbmcgb24gaXRzIHRpbWluZyBkYXRhLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHNlcXVlbmNlKFtcbiAgICAgKiAgIHN0eWxlKHsgb3BhY2l0eTogMCB9KSksXG4gICAgICogICBhbmltYXRlKFwiMXNcIiwgeyBvcGFjaXR5OiAxIH0pKVxuICAgICAqIF0pXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvS2V6OFhHV0J4V3VlN3FQN25OdkY/cD1wcmV2aWV3KSlcbiAgICAgKlxuICAgICAqIHtcXEBleGFtcGxlIGNvcmUvYW5pbWF0aW9uL3RzL2RzbC9hbmltYXRpb25fZXhhbXBsZS50cyByZWdpb249J0NvbXBvbmVudCd9XG4gICAgICpcbiAgICAgKiBcXEBleHBlcmltZW50YWwgQW5pbWF0aW9uIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLlxuICAgICAqIEBwYXJhbSB7P30gc3RlcHNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNlcXVlbmNlKHN0ZXBzKSB7XG4gICAgICAgIHJldHVybiBuZXcgQW5pbWF0aW9uU2VxdWVuY2VNZXRhZGF0YShzdGVwcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBzdHlsZWAgaXMgYW4gYW5pbWF0aW9uLXNwZWNpZmljIGZ1bmN0aW9uIHRoYXQgaXMgZGVzaWduZWQgdG8gYmUgdXNlZCBpbnNpZGUgb2YgQW5ndWxhcjInc1xuICAgICAqIGFuaW1hdGlvblxuICAgICAqIERTTCBsYW5ndWFnZS4gSWYgdGhpcyBpbmZvcm1hdGlvbiBpcyBuZXcsIHBsZWFzZSBuYXZpZ2F0ZSB0byB0aGVcbiAgICAgKiB7XFxAbGluayBDb21wb25lbnQjYW5pbWF0aW9ucy1hbmNob3IgY29tcG9uZW50IGFuaW1hdGlvbnMgbWV0YWRhdGFcbiAgICAgKiBwYWdlfSB0byBnYWluIGEgYmV0dGVyIHVuZGVyc3RhbmRpbmcgb2YgaG93IGFuaW1hdGlvbnMgaW4gQW5ndWxhcjIgYXJlIHVzZWQuXG4gICAgICpcbiAgICAgKiBgc3R5bGVgIGRlY2xhcmVzIGEga2V5L3ZhbHVlIG9iamVjdCBjb250YWluaW5nIENTUyBwcm9wZXJ0aWVzL3N0eWxlcyB0aGF0IGNhbiB0aGVuXG4gICAgICogYmUgdXNlZCBmb3Ige1xcQGxpbmsgc3RhdGUgYW5pbWF0aW9uIHN0YXRlc30sIHdpdGhpbiBhbiB7XFxAbGluayBzZXF1ZW5jZSBhbmltYXRpb24gc2VxdWVuY2V9LCBvciBhc1xuICAgICAqIHN0eWxpbmcgZGF0YSBmb3IgYm90aCB7XFxAbGluayBhbmltYXRlIGFuaW1hdGV9IGFuZCB7XFxAbGluayBrZXlmcmFtZXMga2V5ZnJhbWVzfS5cbiAgICAgKlxuICAgICAqICMjIyBVc2FnZVxuICAgICAqXG4gICAgICogYHN0eWxlYCB0YWtlcyBpbiBhIGtleS92YWx1ZSBzdHJpbmcgbWFwIGFzIGRhdGEgYW5kIGV4cGVjdHMgb25lIG9yIG1vcmUgQ1NTIHByb3BlcnR5L3ZhbHVlXG4gICAgICogcGFpcnMgdG8gYmUgZGVmaW5lZC5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiAvLyBzdHJpbmcgdmFsdWVzIGFyZSB1c2VkIGZvciBjc3MgcHJvcGVydGllc1xuICAgICAqIHN0eWxlKHsgYmFja2dyb3VuZDogXCJyZWRcIiwgY29sb3I6IFwiYmx1ZVwiIH0pXG4gICAgICpcbiAgICAgKiAvLyBudW1lcmljYWwgKHBpeGVsKSB2YWx1ZXMgYXJlIGFsc28gc3VwcG9ydGVkXG4gICAgICogc3R5bGUoeyB3aWR0aDogMTAwLCBoZWlnaHQ6IDAgfSlcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqICMjIyMgQXV0by1zdHlsZXMgKHVzaW5nIGAqYClcbiAgICAgKlxuICAgICAqIFdoZW4gYW4gYXN0ZXJpeCAoYCpgKSBjaGFyYWN0ZXIgaXMgdXNlZCBhcyBhIHZhbHVlIHRoZW4gaXQgd2lsbCBiZSBkZXRlY3RlZCBmcm9tIHRoZSBlbGVtZW50XG4gICAgICogYmVpbmcgYW5pbWF0ZWRcbiAgICAgKiBhbmQgYXBwbGllZCBhcyBhbmltYXRpb24gZGF0YSB3aGVuIHRoZSBhbmltYXRpb24gc3RhcnRzLlxuICAgICAqXG4gICAgICogVGhpcyBmZWF0dXJlIHByb3ZlcyB1c2VmdWwgZm9yIGEgc3RhdGUgZGVwZW5kaW5nIG9uIGxheW91dCBhbmQvb3IgZW52aXJvbm1lbnQgZmFjdG9yczsgaW4gc3VjaFxuICAgICAqIGNhc2VzXG4gICAgICogdGhlIHN0eWxlcyBhcmUgY2FsY3VsYXRlZCBqdXN0IGJlZm9yZSB0aGUgYW5pbWF0aW9uIHN0YXJ0cy5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiAvLyB0aGUgc3RlcHMgYmVsb3cgd2lsbCBhbmltYXRlIGZyb20gMCB0byB0aGVcbiAgICAgKiAvLyBhY3R1YWwgaGVpZ2h0IG9mIHRoZSBlbGVtZW50XG4gICAgICogc3R5bGUoeyBoZWlnaHQ6IDAgfSksXG4gICAgICogYW5pbWF0ZShcIjFzXCIsIHN0eWxlKHsgaGVpZ2h0OiBcIipcIiB9KSlcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9LZXo4WEdXQnhXdWU3cVA3bk52Rj9wPXByZXZpZXcpKVxuICAgICAqXG4gICAgICoge1xcQGV4YW1wbGUgY29yZS9hbmltYXRpb24vdHMvZHNsL2FuaW1hdGlvbl9leGFtcGxlLnRzIHJlZ2lvbj0nQ29tcG9uZW50J31cbiAgICAgKlxuICAgICAqIFxcQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gICAgICogQHBhcmFtIHs/fSB0b2tlbnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0eWxlKHRva2Vucykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbnB1dDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb2Zmc2V0ID0gbnVsbDtcbiAgICAgICAgaWYgKHR5cGVvZiB0b2tlbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpbnB1dCA9IFsodG9rZW5zKV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0b2tlbnMpKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSAodG9rZW5zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gWyh0b2tlbnMpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlucHV0LmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZW50cnlPZmZzZXQgPSAoKGVudHJ5KSAvKiogVE9ETyAjOTEwMCAqLylbJ29mZnNldCddO1xuICAgICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoZW50cnlPZmZzZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IG9mZnNldCA9PSBudWxsID8gcGFyc2VGbG9hdChlbnRyeU9mZnNldCkgOiBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBBbmltYXRpb25TdHlsZU1ldGFkYXRhKGlucHV0LCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgc3RhdGVgIGlzIGFuIGFuaW1hdGlvbi1zcGVjaWZpYyBmdW5jdGlvbiB0aGF0IGlzIGRlc2lnbmVkIHRvIGJlIHVzZWQgaW5zaWRlIG9mIEFuZ3VsYXIyJ3NcbiAgICAgKiBhbmltYXRpb25cbiAgICAgKiBEU0wgbGFuZ3VhZ2UuIElmIHRoaXMgaW5mb3JtYXRpb24gaXMgbmV3LCBwbGVhc2UgbmF2aWdhdGUgdG8gdGhlXG4gICAgICoge1xcQGxpbmsgQ29tcG9uZW50I2FuaW1hdGlvbnMtYW5jaG9yIGNvbXBvbmVudCBhbmltYXRpb25zIG1ldGFkYXRhXG4gICAgICogcGFnZX0gdG8gZ2FpbiBhIGJldHRlciB1bmRlcnN0YW5kaW5nIG9mIGhvdyBhbmltYXRpb25zIGluIEFuZ3VsYXIyIGFyZSB1c2VkLlxuICAgICAqXG4gICAgICogYHN0YXRlYCBkZWNsYXJlcyBhbiBhbmltYXRpb24gc3RhdGUgd2l0aGluIHRoZSBnaXZlbiB0cmlnZ2VyLiBXaGVuIGEgc3RhdGUgaXNcbiAgICAgKiBhY3RpdmUgd2l0aGluIGEgY29tcG9uZW50IHRoZW4gaXRzIGFzc29jaWF0ZWQgc3R5bGVzIHdpbGwgcGVyc2lzdCBvblxuICAgICAqIHRoZSBlbGVtZW50IHRoYXQgdGhlIHRyaWdnZXIgaXMgYXR0YWNoZWQgdG8gKGV2ZW4gd2hlbiB0aGUgYW5pbWF0aW9uIGVuZHMpLlxuICAgICAqXG4gICAgICogVG8gYW5pbWF0ZSBiZXR3ZWVuIHN0YXRlcywgaGF2ZSBhIGxvb2sgYXQgdGhlIGFuaW1hdGlvbiB7XFxAbGluayB0cmFuc2l0aW9uIHRyYW5zaXRpb259XG4gICAgICogRFNMIGZ1bmN0aW9uLiBUbyByZWdpc3RlciBzdGF0ZXMgdG8gYW4gYW5pbWF0aW9uIHRyaWdnZXIgcGxlYXNlIGhhdmUgYSBsb29rXG4gICAgICogYXQgdGhlIHtcXEBsaW5rIHRyaWdnZXIgdHJpZ2dlcn0gZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiAjIyMjIFRoZSBgdm9pZGAgc3RhdGVcbiAgICAgKlxuICAgICAqIFRoZSBgdm9pZGAgc3RhdGUgdmFsdWUgaXMgYSByZXNlcnZlZCB3b3JkIHRoYXQgYW5ndWxhciB1c2VzIHRvIGRldGVybWluZSB3aGVuIHRoZSBlbGVtZW50IGlzIG5vdFxuICAgICAqIGFwYXJ0XG4gICAgICogb2YgdGhlIGFwcGxpY2F0aW9uIGFueW1vcmUgKGUuZy4gd2hlbiBhbiBgbmdJZmAgZXZhbHVhdGVzIHRvIGZhbHNlIHRoZW4gdGhlIHN0YXRlIG9mIHRoZVxuICAgICAqIGFzc29jaWF0ZWQgZWxlbWVudFxuICAgICAqIGlzIHZvaWQpLlxuICAgICAqXG4gICAgICogIyMjIyBUaGUgYCpgIChkZWZhdWx0KSBzdGF0ZVxuICAgICAqXG4gICAgICogVGhlIGAqYCBzdGF0ZSAod2hlbiBzdHlsZWQpIGlzIGEgZmFsbGJhY2sgc3RhdGUgdGhhdCB3aWxsIGJlIHVzZWQgaWZcbiAgICAgKiB0aGUgc3RhdGUgdGhhdCBpcyBiZWluZyBhbmltYXRlZCBpcyBub3QgZGVjbGFyZWQgd2l0aGluIHRoZSB0cmlnZ2VyLlxuICAgICAqXG4gICAgICogIyMjIFVzYWdlXG4gICAgICpcbiAgICAgKiBgc3RhdGVgIHdpbGwgZGVjbGFyZSBhbiBhbmltYXRpb24gc3RhdGUgd2l0aCBpdHMgYXNzb2NpYXRlZCBzdHlsZXNcbiAgICAgKiB3aXRoaW4gdGhlIGdpdmVuIHRyaWdnZXIuXG4gICAgICpcbiAgICAgKiAtIGBzdGF0ZU5hbWVFeHByYCBjYW4gYmUgb25lIG9yIG1vcmUgc3RhdGUgbmFtZXMgc2VwYXJhdGVkIGJ5IGNvbW1hcy5cbiAgICAgKiAtIGBzdHlsZXNgIHJlZmVycyB0byB0aGUge1xcQGxpbmsgc3R5bGUgc3R5bGluZyBkYXRhfSB0aGF0IHdpbGwgYmUgcGVyc2lzdGVkIG9uIHRoZSBlbGVtZW50IG9uY2VcbiAgICAgKiB0aGUgc3RhdGVcbiAgICAgKiBoYXMgYmVlbiByZWFjaGVkLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIFwidm9pZFwiIGlzIGEgcmVzZXJ2ZWQgbmFtZSBmb3IgYSBzdGF0ZSBhbmQgaXMgdXNlZCB0byByZXByZXNlbnRcbiAgICAgKiAvLyB0aGUgc3RhdGUgaW4gd2hpY2ggYW4gZWxlbWVudCBpcyBkZXRhY2hlZCBmcm9tIGZyb20gdGhlIGFwcGxpY2F0aW9uLlxuICAgICAqIHN0YXRlKFwidm9pZFwiLCBzdHlsZSh7IGhlaWdodDogMCB9KSlcbiAgICAgKlxuICAgICAqIC8vIHVzZXItZGVmaW5lZCBzdGF0ZXNcbiAgICAgKiBzdGF0ZShcImNsb3NlZFwiLCBzdHlsZSh7IGhlaWdodDogMCB9KSlcbiAgICAgKiBzdGF0ZShcIm9wZW4sIHZpc2libGVcIiwgc3R5bGUoeyBoZWlnaHQ6IFwiKlwiIH0pKVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L0tlejhYR1dCeFd1ZTdxUDduTnZGP3A9cHJldmlldykpXG4gICAgICpcbiAgICAgKiB7XFxAZXhhbXBsZSBjb3JlL2FuaW1hdGlvbi90cy9kc2wvYW5pbWF0aW9uX2V4YW1wbGUudHMgcmVnaW9uPSdDb21wb25lbnQnfVxuICAgICAqXG4gICAgICogXFxAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAgICAgKiBAcGFyYW0gez99IHN0YXRlTmFtZUV4cHJcbiAgICAgKiBAcGFyYW0gez99IHN0eWxlc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhdGUoc3RhdGVOYW1lRXhwciwgc3R5bGVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgQW5pbWF0aW9uU3RhdGVEZWNsYXJhdGlvbk1ldGFkYXRhKHN0YXRlTmFtZUV4cHIsIHN0eWxlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBrZXlmcmFtZXNgIGlzIGFuIGFuaW1hdGlvbi1zcGVjaWZpYyBmdW5jdGlvbiB0aGF0IGlzIGRlc2lnbmVkIHRvIGJlIHVzZWQgaW5zaWRlIG9mIEFuZ3VsYXIyJ3NcbiAgICAgKiBhbmltYXRpb25cbiAgICAgKiBEU0wgbGFuZ3VhZ2UuIElmIHRoaXMgaW5mb3JtYXRpb24gaXMgbmV3LCBwbGVhc2UgbmF2aWdhdGUgdG8gdGhlXG4gICAgICoge1xcQGxpbmsgQ29tcG9uZW50I2FuaW1hdGlvbnMtYW5jaG9yIGNvbXBvbmVudCBhbmltYXRpb25zIG1ldGFkYXRhXG4gICAgICogcGFnZX0gdG8gZ2FpbiBhIGJldHRlciB1bmRlcnN0YW5kaW5nIG9mIGhvdyBhbmltYXRpb25zIGluIEFuZ3VsYXIyIGFyZSB1c2VkLlxuICAgICAqXG4gICAgICogYGtleWZyYW1lc2Agc3BlY2lmaWVzIGEgY29sbGVjdGlvbiBvZiB7XFxAbGluayBzdHlsZSBzdHlsZX0gZW50cmllcyBlYWNoIG9wdGlvbmFsbHkgY2hhcmFjdGVyaXplZFxuICAgICAqIGJ5IGFuIGBvZmZzZXRgIHZhbHVlLlxuICAgICAqXG4gICAgICogIyMjIFVzYWdlXG4gICAgICpcbiAgICAgKiBUaGUgYGtleWZyYW1lc2AgYW5pbWF0aW9uIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIHVzZWQgYWxvbmdzaWRlIHRoZSB7XFxAbGluayBhbmltYXRlIGFuaW1hdGV9XG4gICAgICogYW5pbWF0aW9uIGZ1bmN0aW9uLiBJbnN0ZWFkIG9mIGFwcGx5aW5nIGFuaW1hdGlvbnMgZnJvbSB3aGVyZSB0aGV5IGFyZVxuICAgICAqIGN1cnJlbnRseSB0byB0aGVpciBkZXN0aW5hdGlvbiwga2V5ZnJhbWVzIGNhbiBkZXNjcmliZSBob3cgZWFjaCBzdHlsZSBlbnRyeSBpcyBhcHBsaWVkXG4gICAgICogYW5kIGF0IHdoYXQgcG9pbnQgd2l0aGluIHRoZSBhbmltYXRpb24gYXJjIChtdWNoIGxpa2UgQ1NTIEtleWZyYW1lIEFuaW1hdGlvbnMgZG8pLlxuICAgICAqXG4gICAgICogRm9yIGVhY2ggYHN0eWxlKClgIGVudHJ5IGFuIGBvZmZzZXRgIHZhbHVlIGNhbiBiZSBzZXQuIERvaW5nIHNvIGFsbG93cyB0byBzcGVjaWZpeSBhdFxuICAgICAqIHdoYXQgcGVyY2VudGFnZSBvZiB0aGUgYW5pbWF0ZSB0aW1lIHRoZSBzdHlsZXMgd2lsbCBiZSBhcHBsaWVkLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIHRoZSBwcm92aWRlZCBvZmZzZXQgdmFsdWVzIGRlc2NyaWJlIHdoZW4gZWFjaCBiYWNrZ3JvdW5kQ29sb3IgdmFsdWUgaXMgYXBwbGllZC5cbiAgICAgKiBhbmltYXRlKFwiNXNcIiwga2V5ZnJhbWVzKFtcbiAgICAgKiAgIHN0eWxlKHsgYmFja2dyb3VuZENvbG9yOiBcInJlZFwiLCBvZmZzZXQ6IDAgfSksXG4gICAgICogICBzdHlsZSh7IGJhY2tncm91bmRDb2xvcjogXCJibHVlXCIsIG9mZnNldDogMC4yIH0pLFxuICAgICAqICAgc3R5bGUoeyBiYWNrZ3JvdW5kQ29sb3I6IFwib3JhbmdlXCIsIG9mZnNldDogMC4zIH0pLFxuICAgICAqICAgc3R5bGUoeyBiYWNrZ3JvdW5kQ29sb3I6IFwiYmxhY2tcIiwgb2Zmc2V0OiAxIH0pXG4gICAgICogXSkpXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBBbHRlcm5hdGl2ZWx5LCBpZiB0aGVyZSBhcmUgbm8gYG9mZnNldGAgdmFsdWVzIHVzZWQgd2l0aGluIHRoZSBzdHlsZSBlbnRyaWVzIHRoZW4gdGhlIG9mZnNldHNcbiAgICAgKiB3aWxsXG4gICAgICogYmUgY2FsY3VsYXRlZCBhdXRvbWF0aWNhbGx5LlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGFuaW1hdGUoXCI1c1wiLCBrZXlmcmFtZXMoW1xuICAgICAqICAgc3R5bGUoeyBiYWNrZ3JvdW5kQ29sb3I6IFwicmVkXCIgfSkgLy8gb2Zmc2V0ID0gMFxuICAgICAqICAgc3R5bGUoeyBiYWNrZ3JvdW5kQ29sb3I6IFwiYmx1ZVwiIH0pIC8vIG9mZnNldCA9IDAuMzNcbiAgICAgKiAgIHN0eWxlKHsgYmFja2dyb3VuZENvbG9yOiBcIm9yYW5nZVwiIH0pIC8vIG9mZnNldCA9IDAuNjZcbiAgICAgKiAgIHN0eWxlKHsgYmFja2dyb3VuZENvbG9yOiBcImJsYWNrXCIgfSkgLy8gb2Zmc2V0ID0gMVxuICAgICAqIF0pKVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L0tlejhYR1dCeFd1ZTdxUDduTnZGP3A9cHJldmlldykpXG4gICAgICpcbiAgICAgKiB7XFxAZXhhbXBsZSBjb3JlL2FuaW1hdGlvbi90cy9kc2wvYW5pbWF0aW9uX2V4YW1wbGUudHMgcmVnaW9uPSdDb21wb25lbnQnfVxuICAgICAqXG4gICAgICogXFxAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAgICAgKiBAcGFyYW0gez99IHN0ZXBzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBrZXlmcmFtZXMoc3RlcHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBbmltYXRpb25LZXlmcmFtZXNTZXF1ZW5jZU1ldGFkYXRhKHN0ZXBzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYHRyYW5zaXRpb25gIGlzIGFuIGFuaW1hdGlvbi1zcGVjaWZpYyBmdW5jdGlvbiB0aGF0IGlzIGRlc2lnbmVkIHRvIGJlIHVzZWQgaW5zaWRlIG9mIEFuZ3VsYXIyJ3NcbiAgICAgKiBhbmltYXRpb25cbiAgICAgKiBEU0wgbGFuZ3VhZ2UuIElmIHRoaXMgaW5mb3JtYXRpb24gaXMgbmV3LCBwbGVhc2UgbmF2aWdhdGUgdG8gdGhlXG4gICAgICoge1xcQGxpbmsgQ29tcG9uZW50I2FuaW1hdGlvbnMtYW5jaG9yIGNvbXBvbmVudCBhbmltYXRpb25zIG1ldGFkYXRhXG4gICAgICogcGFnZX0gdG8gZ2FpbiBhIGJldHRlciB1bmRlcnN0YW5kaW5nIG9mIGhvdyBhbmltYXRpb25zIGluIEFuZ3VsYXIyIGFyZSB1c2VkLlxuICAgICAqXG4gICAgICogYHRyYW5zaXRpb25gIGRlY2xhcmVzIHRoZSB7XFxAbGluayBzZXF1ZW5jZSBzZXF1ZW5jZSBvZiBhbmltYXRpb24gc3RlcHN9IHRoYXQgd2lsbCBiZSBydW4gd2hlbiB0aGVcbiAgICAgKiBwcm92aWRlZFxuICAgICAqIGBzdGF0ZUNoYW5nZUV4cHJgIHZhbHVlIGlzIHNhdGlzZmllZC4gVGhlIGBzdGF0ZUNoYW5nZUV4cHJgIGNvbnNpc3RzIG9mIGEgYHN0YXRlMSA9PiBzdGF0ZTJgXG4gICAgICogd2hpY2ggY29uc2lzdHNcbiAgICAgKiBvZiB0d28ga25vd24gc3RhdGVzICh1c2UgYW4gYXN0ZXJpeCAoYCpgKSB0byByZWZlciB0byBhIGR5bmFtaWMgc3RhcnRpbmcgYW5kL29yIGVuZGluZyBzdGF0ZSkuXG4gICAgICpcbiAgICAgKiBBbmltYXRpb24gdHJhbnNpdGlvbnMgYXJlIHBsYWNlZCB3aXRoaW4gYW4ge1xcQGxpbmsgdHJpZ2dlciBhbmltYXRpb24gdHJpZ2dlcn0uIEZvciBhbiB0cmFuc2l0aW9uXG4gICAgICogdG8gYW5pbWF0ZSB0b1xuICAgICAqIGEgc3RhdGUgdmFsdWUgYW5kIHBlcnNpc3QgaXRzIHN0eWxlcyB0aGVuIG9uZSBvciBtb3JlIHtcXEBsaW5rIHN0YXRlIGFuaW1hdGlvbiBzdGF0ZXN9IGlzIGV4cGVjdGVkXG4gICAgICogdG8gYmUgZGVmaW5lZC5cbiAgICAgKlxuICAgICAqICMjIyBVc2FnZVxuICAgICAqXG4gICAgICogQW4gYW5pbWF0aW9uIHRyYW5zaXRpb24gaXMga2lja2VkIG9mZiB0aGUgYHN0YXRlQ2hhbmdlRXhwcmAgcHJlZGljYXRlIGV2YWx1YXRlcyB0byB0cnVlIGJhc2VkIG9uXG4gICAgICogd2hhdCB0aGVcbiAgICAgKiBwcmV2aW91cyBzdGF0ZSBpcyBhbmQgd2hhdCB0aGUgY3VycmVudCBzdGF0ZSBoYXMgYmVjb21lLiBJbiBvdGhlciB3b3JkcywgaWYgYSB0cmFuc2l0aW9uIGlzXG4gICAgICogZGVmaW5lZCB0aGF0XG4gICAgICogbWF0Y2hlcyB0aGUgb2xkL2N1cnJlbnQgc3RhdGUgY3JpdGVyaWEgdGhlbiB0aGUgYXNzb2NpYXRlZCBhbmltYXRpb24gd2lsbCBiZSB0cmlnZ2VyZWQuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogLy8gYWxsIHRyYW5zaXRpb24vc3RhdGUgY2hhbmdlcyBhcmUgZGVmaW5lZCB3aXRoaW4gYW4gYW5pbWF0aW9uIHRyaWdnZXJcbiAgICAgKiB0cmlnZ2VyKFwibXlBbmltYXRpb25UcmlnZ2VyXCIsIFtcbiAgICAgKiAgIC8vIGlmIGEgc3RhdGUgaXMgZGVmaW5lZCB0aGVuIGl0cyBzdHlsZXMgd2lsbCBiZSBwZXJzaXN0ZWQgd2hlbiB0aGVcbiAgICAgKiAgIC8vIGFuaW1hdGlvbiBoYXMgZnVsbHkgY29tcGxldGVkIGl0c2VsZlxuICAgICAqICAgc3RhdGUoXCJvblwiLCBzdHlsZSh7IGJhY2tncm91bmQ6IFwiZ3JlZW5cIiB9KSksXG4gICAgICogICBzdGF0ZShcIm9mZlwiLCBzdHlsZSh7IGJhY2tncm91bmQ6IFwiZ3JleVwiIH0pKSxcbiAgICAgKlxuICAgICAqICAgLy8gYSB0cmFuc2l0aW9uIGFuaW1hdGlvbiB0aGF0IHdpbGwgYmUga2lja2VkIG9mZiB3aGVuIHRoZSBzdGF0ZSB2YWx1ZVxuICAgICAqICAgLy8gYm91bmQgdG8gXCJteUFuaW1hdGlvblRyaWdnZXJcIiBjaGFuZ2VzIGZyb20gXCJvblwiIHRvIFwib2ZmXCJcbiAgICAgKiAgIHRyYW5zaXRpb24oXCJvbiA9PiBvZmZcIiwgYW5pbWF0ZSg1MDApKSxcbiAgICAgKlxuICAgICAqICAgLy8gaXQgaXMgYWxzbyBwb3NzaWJsZSB0byBkbyBydW4gdGhlIHNhbWUgYW5pbWF0aW9uIGZvciBib3RoIGRpcmVjdGlvbnNcbiAgICAgKiAgIHRyYW5zaXRpb24oXCJvbiA8PT4gb2ZmXCIsIGFuaW1hdGUoNTAwKSksXG4gICAgICpcbiAgICAgKiAgIC8vIG9yIHRvIGRlZmluZSBtdWx0aXBsZSBzdGF0ZXMgcGFpcnMgc2VwYXJhdGVkIGJ5IGNvbW1hc1xuICAgICAqICAgdHJhbnNpdGlvbihcIm9uID0+IG9mZiwgb2ZmID0+IHZvaWRcIiwgYW5pbWF0ZSg1MDApKSxcbiAgICAgKlxuICAgICAqICAgLy8gdGhpcyBpcyBhIGNhdGNoLWFsbCBzdGF0ZSBjaGFuZ2UgZm9yIHdoZW4gYW4gZWxlbWVudCBpcyBpbnNlcnRlZCBpbnRvXG4gICAgICogICAvLyB0aGUgcGFnZSBhbmQgdGhlIGRlc3RpbmF0aW9uIHN0YXRlIGlzIHVua25vd25cbiAgICAgKiAgIHRyYW5zaXRpb24oXCJ2b2lkID0+ICpcIiwgW1xuICAgICAqICAgICBzdHlsZSh7IG9wYWNpdHk6IDAgfSksXG4gICAgICogICAgIGFuaW1hdGUoNTAwKVxuICAgICAqICAgXSksXG4gICAgICpcbiAgICAgKiAgIC8vIHRoaXMgd2lsbCBjYXB0dXJlIGEgc3RhdGUgY2hhbmdlIGJldHdlZW4gYW55IHN0YXRlc1xuICAgICAqICAgdHJhbnNpdGlvbihcIiogPT4gKlwiLCBhbmltYXRlKFwiMXMgMHNcIikpLFxuICAgICAqIF0pXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBUaGUgdGVtcGxhdGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgY29tcG9uZW50IHdpbGwgbWFrZSB1c2Ugb2YgdGhlIGBteUFuaW1hdGlvblRyaWdnZXJgXG4gICAgICogYW5pbWF0aW9uIHRyaWdnZXIgYnkgYmluZGluZyB0byBhbiBlbGVtZW50IHdpdGhpbiBpdHMgdGVtcGxhdGUgY29kZS5cbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8IS0tIHNvbWV3aGVyZSBpbnNpZGUgb2YgbXktY29tcG9uZW50LXRwbC5odG1sIC0tPlxuICAgICAqIDxkaXYgW1xcQG15QW5pbWF0aW9uVHJpZ2dlcl09XCJteVN0YXR1c0V4cFwiPi4uLjwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogIyMjIyBUaGUgZmluYWwgYGFuaW1hdGVgIGNhbGxcbiAgICAgKlxuICAgICAqIElmIHRoZSBmaW5hbCBzdGVwIHdpdGhpbiB0aGUgdHJhbnNpdGlvbiBzdGVwcyBpcyBhIGNhbGwgdG8gYGFuaW1hdGUoKWAgdGhhdCAqKm9ubHkqKlxuICAgICAqIHVzZXMgYSB0aW1pbmcgdmFsdWUgd2l0aCAqKm5vIHN0eWxlIGRhdGEqKiB0aGVuIGl0IHdpbGwgYmUgYXV0b21hdGljYWxseSB1c2VkIGFzIHRoZSBmaW5hbFxuICAgICAqIGFuaW1hdGlvblxuICAgICAqIGFyYyBmb3IgdGhlIGVsZW1lbnQgdG8gYW5pbWF0ZSBpdHNlbGYgdG8gdGhlIGZpbmFsIHN0YXRlLiBUaGlzIGludm9sdmVzIGFuIGF1dG9tYXRpYyBtaXggb2ZcbiAgICAgKiBhZGRpbmcvcmVtb3ZpbmcgQ1NTIHN0eWxlcyBzbyB0aGF0IHRoZSBlbGVtZW50IHdpbGwgYmUgaW4gdGhlIGV4YWN0IHN0YXRlIGl0IHNob3VsZCBiZSBmb3IgdGhlXG4gICAgICogYXBwbGllZCBzdGF0ZSB0byBiZSBwcmVzZW50ZWQgY29ycmVjdGx5LlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogLy8gc3RhcnQgb2ZmIGJ5IGhpZGluZyB0aGUgZWxlbWVudCwgYnV0IG1ha2Ugc3VyZSB0aGF0IGl0IGFuaW1hdGVzIHByb3Blcmx5IHRvIHdoYXRldmVyIHN0YXRlXG4gICAgICogLy8gaXMgY3VycmVudGx5IGFjdGl2ZSBmb3IgXCJteUFuaW1hdGlvblRyaWdnZXJcIlxuICAgICAqIHRyYW5zaXRpb24oXCJ2b2lkID0+ICpcIiwgW1xuICAgICAqICAgc3R5bGUoeyBvcGFjaXR5OiAwIH0pLFxuICAgICAqICAgYW5pbWF0ZSg1MDApXG4gICAgICogXSlcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqICMjIyBUcmFuc2l0aW9uIEFsaWFzZXMgKGA6ZW50ZXJgIGFuZCBgOmxlYXZlYClcbiAgICAgKlxuICAgICAqIEdpdmVuIHRoYXQgZW50ZXIgKGluc2VydGlvbikgYW5kIGxlYXZlIChyZW1vdmFsKSBhbmltYXRpb25zIGFyZSBzbyBjb21tb24sXG4gICAgICogdGhlIGB0cmFuc2l0aW9uYCBmdW5jdGlvbiBhY2NlcHRzIGJvdGggYDplbnRlcmAgYW5kIGA6bGVhdmVgIHZhbHVlcyB3aGljaFxuICAgICAqIGFyZSBhbGlhc2VzIGZvciB0aGUgYHZvaWQgPT4gKmAgYW5kIGAqID0+IHZvaWRgIHN0YXRlIGNoYW5nZXMuXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiB0cmFuc2l0aW9uKFwiOmVudGVyXCIsIFtcbiAgICAgKiAgIHN0eWxlKHsgb3BhY2l0eTogMCB9KSxcbiAgICAgKiAgIGFuaW1hdGUoNTAwLCBzdHlsZSh7IG9wYWNpdHk6IDEgfSkpXG4gICAgICogXSlcbiAgICAgKiB0cmFuc2l0aW9uKFwiOmxlYXZlXCIsIFtcbiAgICAgKiAgIGFuaW1hdGUoNTAwLCBzdHlsZSh7IG9wYWNpdHk6IDAgfSkpXG4gICAgICogXSlcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9LZXo4WEdXQnhXdWU3cVA3bk52Rj9wPXByZXZpZXcpKVxuICAgICAqXG4gICAgICoge1xcQGV4YW1wbGUgY29yZS9hbmltYXRpb24vdHMvZHNsL2FuaW1hdGlvbl9leGFtcGxlLnRzIHJlZ2lvbj0nQ29tcG9uZW50J31cbiAgICAgKlxuICAgICAqIFxcQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gICAgICogQHBhcmFtIHs/fSBzdGF0ZUNoYW5nZUV4cHJcbiAgICAgKiBAcGFyYW0gez99IHN0ZXBzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmFuc2l0aW9uKHN0YXRlQ2hhbmdlRXhwciwgc3RlcHMpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYW5pbWF0aW9uRGF0YSA9IEFycmF5LmlzQXJyYXkoc3RlcHMpID8gbmV3IEFuaW1hdGlvblNlcXVlbmNlTWV0YWRhdGEoc3RlcHMpIDogc3RlcHM7XG4gICAgICAgIHJldHVybiBuZXcgQW5pbWF0aW9uU3RhdGVUcmFuc2l0aW9uTWV0YWRhdGEoc3RhdGVDaGFuZ2VFeHByLCBhbmltYXRpb25EYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYHRyaWdnZXJgIGlzIGFuIGFuaW1hdGlvbi1zcGVjaWZpYyBmdW5jdGlvbiB0aGF0IGlzIGRlc2lnbmVkIHRvIGJlIHVzZWQgaW5zaWRlIG9mIEFuZ3VsYXIyJ3NcbiAgICAgKiBhbmltYXRpb25cbiAgICAgKiBEU0wgbGFuZ3VhZ2UuIElmIHRoaXMgaW5mb3JtYXRpb24gaXMgbmV3LCBwbGVhc2UgbmF2aWdhdGUgdG8gdGhlXG4gICAgICoge1xcQGxpbmsgQ29tcG9uZW50I2FuaW1hdGlvbnMtYW5jaG9yIGNvbXBvbmVudCBhbmltYXRpb25zIG1ldGFkYXRhXG4gICAgICogcGFnZX0gdG8gZ2FpbiBhIGJldHRlciB1bmRlcnN0YW5kaW5nIG9mIGhvdyBhbmltYXRpb25zIGluIEFuZ3VsYXIyIGFyZSB1c2VkLlxuICAgICAqXG4gICAgICogYHRyaWdnZXJgIENyZWF0ZXMgYW4gYW5pbWF0aW9uIHRyaWdnZXIgd2hpY2ggd2lsbCBhIGxpc3Qgb2Yge1xcQGxpbmsgc3RhdGUgc3RhdGV9IGFuZCB7XFxAbGlua1xuICAgICAqIHRyYW5zaXRpb24gdHJhbnNpdGlvbn1cbiAgICAgKiBlbnRyaWVzIHRoYXQgd2lsbCBiZSBldmFsdWF0ZWQgd2hlbiB0aGUgZXhwcmVzc2lvbiBib3VuZCB0byB0aGUgdHJpZ2dlciBjaGFuZ2VzLlxuICAgICAqXG4gICAgICogVHJpZ2dlcnMgYXJlIHJlZ2lzdGVyZWQgd2l0aGluIHRoZSBjb21wb25lbnQgYW5ub3RhdGlvbiBkYXRhIHVuZGVyIHRoZVxuICAgICAqIHtcXEBsaW5rIENvbXBvbmVudCNhbmltYXRpb25zLWFuY2hvciBhbmltYXRpb25zIHNlY3Rpb259LiBBbiBhbmltYXRpb24gdHJpZ2dlciBjYW5cbiAgICAgKiBiZSBwbGFjZWQgb24gYW4gZWxlbWVudCB3aXRoaW4gYSB0ZW1wbGF0ZSBieSByZWZlcmVuY2luZyB0aGUgbmFtZSBvZiB0aGVcbiAgICAgKiB0cmlnZ2VyIGZvbGxvd2VkIGJ5IHRoZSBleHByZXNzaW9uIHZhbHVlIHRoYXQgdGhlIHRyaWdnZXIgaXMgYm91bmQgdG9cbiAgICAgKiAoaW4gdGhlIGZvcm0gb2YgYFtcXEB0cmlnZ2VyTmFtZV09XCJleHByZXNzaW9uXCJgLlxuICAgICAqXG4gICAgICogIyMjIFVzYWdlXG4gICAgICpcbiAgICAgKiBgdHJpZ2dlcmAgd2lsbCBjcmVhdGUgYW4gYW5pbWF0aW9uIHRyaWdnZXIgcmVmZXJlbmNlIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBgbmFtZWAgdmFsdWUuXG4gICAgICogVGhlIHByb3ZpZGVkIGBhbmltYXRpb25gIHZhbHVlIGlzIGV4cGVjdGVkIHRvIGJlIGFuIGFycmF5IGNvbnNpc3Rpbmcgb2Yge1xcQGxpbmsgc3RhdGUgc3RhdGV9IGFuZFxuICAgICAqIHtcXEBsaW5rIHRyYW5zaXRpb24gdHJhbnNpdGlvbn1cbiAgICAgKiBkZWNsYXJhdGlvbnMuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogXFxAQ29tcG9uZW50KHtcbiAgICAgKiAgIHNlbGVjdG9yOiAnbXktY29tcG9uZW50JyxcbiAgICAgKiAgIHRlbXBsYXRlVXJsOiAnbXktY29tcG9uZW50LXRwbC5odG1sJyxcbiAgICAgKiAgIGFuaW1hdGlvbnM6IFtcbiAgICAgKiAgICAgdHJpZ2dlcihcIm15QW5pbWF0aW9uVHJpZ2dlclwiLCBbXG4gICAgICogICAgICAgc3RhdGUoLi4uKSxcbiAgICAgKiAgICAgICBzdGF0ZSguLi4pLFxuICAgICAqICAgICAgIHRyYW5zaXRpb24oLi4uKSxcbiAgICAgKiAgICAgICB0cmFuc2l0aW9uKC4uLilcbiAgICAgKiAgICAgXSlcbiAgICAgKiAgIF1cbiAgICAgKiB9KVxuICAgICAqIGNsYXNzIE15Q29tcG9uZW50IHtcbiAgICAgKiAgIG15U3RhdHVzRXhwID0gXCJzb21ldGhpbmdcIjtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBUaGUgdGVtcGxhdGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgY29tcG9uZW50IHdpbGwgbWFrZSB1c2Ugb2YgdGhlIGBteUFuaW1hdGlvblRyaWdnZXJgXG4gICAgICogYW5pbWF0aW9uIHRyaWdnZXIgYnkgYmluZGluZyB0byBhbiBlbGVtZW50IHdpdGhpbiBpdHMgdGVtcGxhdGUgY29kZS5cbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8IS0tIHNvbWV3aGVyZSBpbnNpZGUgb2YgbXktY29tcG9uZW50LXRwbC5odG1sIC0tPlxuICAgICAqIDxkaXYgW1xcQG15QW5pbWF0aW9uVHJpZ2dlcl09XCJteVN0YXR1c0V4cFwiPi4uLjwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L0tlejhYR1dCeFd1ZTdxUDduTnZGP3A9cHJldmlldykpXG4gICAgICpcbiAgICAgKiB7XFxAZXhhbXBsZSBjb3JlL2FuaW1hdGlvbi90cy9kc2wvYW5pbWF0aW9uX2V4YW1wbGUudHMgcmVnaW9uPSdDb21wb25lbnQnfVxuICAgICAqXG4gICAgICogXFxAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IGFuaW1hdGlvblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJpZ2dlcihuYW1lLCBhbmltYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBbmltYXRpb25FbnRyeU1ldGFkYXRhKG5hbWUsIGFuaW1hdGlvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwcmV2aW91c1N0eWxlc1xuICAgICAqIEBwYXJhbSB7P30gbmV3U3R5bGVzXG4gICAgICogQHBhcmFtIHs/PX0gbnVsbFZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcmVwYXJlRmluYWxBbmltYXRpb25TdHlsZXMocHJldmlvdXNTdHlsZXMsIG5ld1N0eWxlcywgbnVsbFZhbHVlKSB7XG4gICAgICAgIGlmIChudWxsVmFsdWUgPT09IHZvaWQgMCkgeyBudWxsVmFsdWUgPSBudWxsOyB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZpbmFsU3R5bGVzID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKG5ld1N0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWUgPSBuZXdTdHlsZXNbcHJvcF07XG4gICAgICAgICAgICBmaW5hbFN0eWxlc1twcm9wXSA9IHZhbHVlID09IEFVVE9fU1RZTEUgPyBudWxsVmFsdWUgOiB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmtleXMocHJldmlvdXNTdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgIGlmICghaXNQcmVzZW50KGZpbmFsU3R5bGVzW3Byb3BdKSkge1xuICAgICAgICAgICAgICAgIGZpbmFsU3R5bGVzW3Byb3BdID0gbnVsbFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZpbmFsU3R5bGVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbGxlY3RlZFN0eWxlc1xuICAgICAqIEBwYXJhbSB7P30gZmluYWxTdGF0ZVN0eWxlc1xuICAgICAqIEBwYXJhbSB7P30ga2V5ZnJhbWVzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYWxhbmNlQW5pbWF0aW9uS2V5ZnJhbWVzKGNvbGxlY3RlZFN0eWxlcywgZmluYWxTdGF0ZVN0eWxlcywga2V5ZnJhbWVzKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxpbWl0ID0ga2V5ZnJhbWVzLmxlbmd0aCAtIDE7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZpcnN0S2V5ZnJhbWUgPSBrZXlmcmFtZXNbMF07XG4gICAgICAgIC8vIHBoYXNlIDE6IGNvcHkgYWxsIHRoZSBzdHlsZXMgZnJvbSB0aGUgZmlyc3Qga2V5ZnJhbWUgaW50byB0aGUgbG9va3VwIG1hcFxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmbGF0ZW5lZEZpcnN0S2V5ZnJhbWVTdHlsZXMgPSBmbGF0dGVuU3R5bGVzKGZpcnN0S2V5ZnJhbWUuc3R5bGVzLnN0eWxlcyk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4dHJhRmlyc3RLZXlmcmFtZVN0eWxlcyA9IHt9O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBoYXNFeHRyYUZpcnN0U3R5bGVzID0gZmFsc2U7XG4gICAgICAgIE9iamVjdC5rZXlzKGNvbGxlY3RlZFN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWUgPSAoY29sbGVjdGVkU3R5bGVzW3Byb3BdKTtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBzdHlsZSBpcyBhbHJlYWR5IGRlZmluZWQgaW4gdGhlIGZpcnN0IGtleWZyYW1lIHRoZW5cbiAgICAgICAgICAgIC8vIHdlIGRvIG5vdCByZXBsYWNlIGl0LlxuICAgICAgICAgICAgaWYgKCFmbGF0ZW5lZEZpcnN0S2V5ZnJhbWVTdHlsZXNbcHJvcF0pIHtcbiAgICAgICAgICAgICAgICBmbGF0ZW5lZEZpcnN0S2V5ZnJhbWVTdHlsZXNbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBleHRyYUZpcnN0S2V5ZnJhbWVTdHlsZXNbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBoYXNFeHRyYUZpcnN0U3R5bGVzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGtleWZyYW1lQ29sbGVjdGVkU3R5bGVzID0gU3RyaW5nTWFwV3JhcHBlci5tZXJnZSh7fSwgZmxhdGVuZWRGaXJzdEtleWZyYW1lU3R5bGVzKTtcbiAgICAgICAgLy8gcGhhc2UgMjogbm9ybWFsaXplIHRoZSBmaW5hbCBrZXlmcmFtZVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmaW5hbEtleWZyYW1lID0ga2V5ZnJhbWVzW2xpbWl0XTtcbiAgICAgICAgZmluYWxLZXlmcmFtZS5zdHlsZXMuc3R5bGVzLnVuc2hpZnQoZmluYWxTdGF0ZVN0eWxlcyk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZsYXRlbmVkRmluYWxLZXlmcmFtZVN0eWxlcyA9IGZsYXR0ZW5TdHlsZXMoZmluYWxLZXlmcmFtZS5zdHlsZXMuc3R5bGVzKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXh0cmFGaW5hbEtleWZyYW1lU3R5bGVzID0ge307XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGhhc0V4dHJhRmluYWxTdHlsZXMgPSBmYWxzZTtcbiAgICAgICAgT2JqZWN0LmtleXMoa2V5ZnJhbWVDb2xsZWN0ZWRTdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgIGlmICghaXNQcmVzZW50KGZsYXRlbmVkRmluYWxLZXlmcmFtZVN0eWxlc1twcm9wXSkpIHtcbiAgICAgICAgICAgICAgICBleHRyYUZpbmFsS2V5ZnJhbWVTdHlsZXNbcHJvcF0gPSBBVVRPX1NUWUxFO1xuICAgICAgICAgICAgICAgIGhhc0V4dHJhRmluYWxTdHlsZXMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGhhc0V4dHJhRmluYWxTdHlsZXMpIHtcbiAgICAgICAgICAgIGZpbmFsS2V5ZnJhbWUuc3R5bGVzLnN0eWxlcy5wdXNoKGV4dHJhRmluYWxLZXlmcmFtZVN0eWxlcyk7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmtleXMoZmxhdGVuZWRGaW5hbEtleWZyYW1lU3R5bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICBpZiAoIWlzUHJlc2VudChmbGF0ZW5lZEZpcnN0S2V5ZnJhbWVTdHlsZXNbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgZXh0cmFGaXJzdEtleWZyYW1lU3R5bGVzW3Byb3BdID0gQVVUT19TVFlMRTtcbiAgICAgICAgICAgICAgICBoYXNFeHRyYUZpcnN0U3R5bGVzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChoYXNFeHRyYUZpcnN0U3R5bGVzKSB7XG4gICAgICAgICAgICBmaXJzdEtleWZyYW1lLnN0eWxlcy5zdHlsZXMucHVzaChleHRyYUZpcnN0S2V5ZnJhbWVTdHlsZXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbGxlY3RBbmRSZXNvbHZlU3R5bGVzKGNvbGxlY3RlZFN0eWxlcywgW2ZpbmFsU3RhdGVTdHlsZXNdKTtcbiAgICAgICAgcmV0dXJuIGtleWZyYW1lcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdHlsZXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsZWFyU3R5bGVzKHN0eWxlcykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmaW5hbFN0eWxlcyA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyhzdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBmaW5hbFN0eWxlc1trZXldID0gbnVsbDsgfSk7XG4gICAgICAgIHJldHVybiBmaW5hbFN0eWxlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHs/fSBzdHlsZXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbGxlY3RBbmRSZXNvbHZlU3R5bGVzKGNvbGxlY3Rpb24sIHN0eWxlcykge1xuICAgICAgICByZXR1cm4gc3R5bGVzLm1hcChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0eWxlc09iaiA9IHt9O1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoZW50cnkpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZSA9IGVudHJ5W3Byb3BdO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBGSUxMX1NUWUxFX0ZMQUcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjb2xsZWN0aW9uW3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUHJlc2VudCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gQVVUT19TVFlMRTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uW3Byb3BdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgc3R5bGVzT2JqW3Byb3BdID0gdmFsdWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBzdHlsZXNPYmo7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IHJlbmRlcmVyXG4gICAgICogQHBhcmFtIHs/fSBzdHlsZXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlbmRlclN0eWxlcyhlbGVtZW50LCByZW5kZXJlciwgc3R5bGVzKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkgeyByZW5kZXJlci5zZXRFbGVtZW50U3R5bGUoZWxlbWVudCwgcHJvcCwgc3R5bGVzW3Byb3BdKTsgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3R5bGVzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0dGVuU3R5bGVzKHN0eWxlcykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmaW5hbFN0eWxlcyA9IHt9O1xuICAgICAgICBzdHlsZXMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGVudHJ5KS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7IGZpbmFsU3R5bGVzW3Byb3BdID0gKGVudHJ5W3Byb3BdKTsgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmluYWxTdHlsZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIGBBbmltYXRpb25TdHlsZXNgIGNvbnNpc3RzIG9mIGEgY29sbGVjdGlvbiBvZiBrZXkvdmFsdWUgbWFwcyBjb250YWluaW5nIENTUy1iYXNlZCBzdHlsZSBkYXRhXG4gICAgICogdGhhdCBjYW4gZWl0aGVyIGJlIHVzZWQgYXMgaW5pdGlhbCBzdHlsaW5nIGRhdGEgb3IgYXBhcnQgb2YgYSBzZXJpZXMgb2Yga2V5ZnJhbWVzIHdpdGhpbiBhblxuICAgICAqIGFuaW1hdGlvbi5cbiAgICAgKiBUaGlzIGNsYXNzIGlzIG1vc3RseSBpbnRlcm5hbCwgYW5kIGl0IGlzIGRlc2lnbmVkIHRvIGJlIHVzZWQgYWxvbmdzaWRlXG4gICAgICoge1xcQGxpbmsgQW5pbWF0aW9uS2V5ZnJhbWUgYEFuaW1hdGlvbktleWZyYW1lYH0gYW5kIHtcXEBsaW5rIFJlbmRlcmVyI2FuaW1hdGUtYW5jaG9yXG4gICAgICogYFJlbmRlcmVyLmFuaW1hdGVgfS5cbiAgICAgKlxuICAgICAqIFxcQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgQW5pbWF0aW9uU3R5bGVzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gc3R5bGVzXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBBbmltYXRpb25TdHlsZXMoc3R5bGVzKSB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlcyA9IHN0eWxlcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQW5pbWF0aW9uU3R5bGVzO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBBbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzIGlzIHJldHVybmVkIGFzIGFuIGV2ZW50IHBhcmFtZXRlciB3aGVuIGFuIGFuaW1hdGlvblxuICAgICAqIGNhbGxiYWNrIGlzIGNhcHR1cmVkIGZvciBhbiBhbmltYXRpb24gZWl0aGVyIGR1cmluZyB0aGUgc3RhcnQgb3IgZG9uZSBwaGFzZS5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBcXEBDb21wb25lbnQoe1xuICAgICAqICAgaG9zdDoge1xuICAgICAqICAgICAnW1xcQG15QW5pbWF0aW9uVHJpZ2dlcl0nOiAnc29tZUV4cHJlc3Npb24nLFxuICAgICAqICAgICAnKFxcQG15QW5pbWF0aW9uVHJpZ2dlci5zdGFydCknOiAnY2FwdHVyZVN0YXJ0RXZlbnQoJGV2ZW50KScsXG4gICAgICogICAgICcoXFxAbXlBbmltYXRpb25UcmlnZ2VyLmRvbmUpJzogJ2NhcHR1cmVEb25lRXZlbnQoJGV2ZW50KScsXG4gICAgICogICB9LFxuICAgICAqICAgYW5pbWF0aW9uczogW1xuICAgICAqICAgICB0cmlnZ2VyKFwibXlBbmltYXRpb25UcmlnZ2VyXCIsIFtcbiAgICAgKiAgICAgICAgLy8gLi4uXG4gICAgICogICAgIF0pXG4gICAgICogICBdXG4gICAgICogfSlcbiAgICAgKiBjbGFzcyBNeUNvbXBvbmVudCB7XG4gICAgICogICBzb21lRXhwcmVzc2lvbjogYW55ID0gZmFsc2U7XG4gICAgICogICBjYXB0dXJlU3RhcnRFdmVudChldmVudDogQW5pbWF0aW9uVHJhbnNpdGlvbkV2ZW50KSB7XG4gICAgICogICAgIC8vIHRoZSB0b1N0YXRlLCBmcm9tU3RhdGUgYW5kIHRvdGFsVGltZSBkYXRhIGlzIGFjY2Vzc2libGUgZnJvbSB0aGUgZXZlbnQgdmFyaWFibGVcbiAgICAgKiAgIH1cbiAgICAgKlxuICAgICAqICAgY2FwdHVyZURvbmVFdmVudChldmVudDogQW5pbWF0aW9uVHJhbnNpdGlvbkV2ZW50KSB7XG4gICAgICogICAgIC8vIHRoZSB0b1N0YXRlLCBmcm9tU3RhdGUgYW5kIHRvdGFsVGltZSBkYXRhIGlzIGFjY2Vzc2libGUgZnJvbSB0aGUgZXZlbnQgdmFyaWFibGVcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBcXEBleHBlcmltZW50YWwgQW5pbWF0aW9uIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLlxuICAgICAqL1xuICAgIHZhciBBbmltYXRpb25UcmFuc2l0aW9uRXZlbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBfXzBcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvblRyYW5zaXRpb25FdmVudChfYSkge1xuICAgICAgICAgICAgdmFyIGZyb21TdGF0ZSA9IF9hLmZyb21TdGF0ZSwgdG9TdGF0ZSA9IF9hLnRvU3RhdGUsIHRvdGFsVGltZSA9IF9hLnRvdGFsVGltZSwgcGhhc2VOYW1lID0gX2EucGhhc2VOYW1lO1xuICAgICAgICAgICAgdGhpcy5mcm9tU3RhdGUgPSBmcm9tU3RhdGU7XG4gICAgICAgICAgICB0aGlzLnRvU3RhdGUgPSB0b1N0YXRlO1xuICAgICAgICAgICAgdGhpcy50b3RhbFRpbWUgPSB0b3RhbFRpbWU7XG4gICAgICAgICAgICB0aGlzLnBoYXNlTmFtZSA9IHBoYXNlTmFtZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQW5pbWF0aW9uVHJhbnNpdGlvbkV2ZW50O1xuICAgIH0oKSk7XG5cbiAgICB2YXIgQW5pbWF0aW9uVHJhbnNpdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IF9wbGF5ZXJcbiAgICAgICAgICogQHBhcmFtIHs/fSBfZnJvbVN0YXRlXG4gICAgICAgICAqIEBwYXJhbSB7P30gX3RvU3RhdGVcbiAgICAgICAgICogQHBhcmFtIHs/fSBfdG90YWxUaW1lXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBBbmltYXRpb25UcmFuc2l0aW9uKF9wbGF5ZXIsIF9mcm9tU3RhdGUsIF90b1N0YXRlLCBfdG90YWxUaW1lKSB7XG4gICAgICAgICAgICB0aGlzLl9wbGF5ZXIgPSBfcGxheWVyO1xuICAgICAgICAgICAgdGhpcy5fZnJvbVN0YXRlID0gX2Zyb21TdGF0ZTtcbiAgICAgICAgICAgIHRoaXMuX3RvU3RhdGUgPSBfdG9TdGF0ZTtcbiAgICAgICAgICAgIHRoaXMuX3RvdGFsVGltZSA9IF90b3RhbFRpbWU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gcGhhc2VOYW1lXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBbmltYXRpb25UcmFuc2l0aW9uLnByb3RvdHlwZS5fY3JlYXRlRXZlbnQgPSBmdW5jdGlvbiAocGhhc2VOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFuaW1hdGlvblRyYW5zaXRpb25FdmVudCh7XG4gICAgICAgICAgICAgICAgZnJvbVN0YXRlOiB0aGlzLl9mcm9tU3RhdGUsXG4gICAgICAgICAgICAgICAgdG9TdGF0ZTogdGhpcy5fdG9TdGF0ZSxcbiAgICAgICAgICAgICAgICB0b3RhbFRpbWU6IHRoaXMuX3RvdGFsVGltZSxcbiAgICAgICAgICAgICAgICBwaGFzZU5hbWU6IHBoYXNlTmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGNhbGxiYWNrXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBbmltYXRpb25UcmFuc2l0aW9uLnByb3RvdHlwZS5vblN0YXJ0ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZm4gPSAoWm9uZS5jdXJyZW50LndyYXAoZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FsbGJhY2soX3RoaXMuX2NyZWF0ZUV2ZW50KCdzdGFydCcpKTsgfSwgJ3BsYXllci5vblN0YXJ0JykpO1xuICAgICAgICAgICAgdGhpcy5fcGxheWVyLm9uU3RhcnQoZm4pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBjYWxsYmFja1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQW5pbWF0aW9uVHJhbnNpdGlvbi5wcm90b3R5cGUub25Eb25lID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZm4gPSAoWm9uZS5jdXJyZW50LndyYXAoZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FsbGJhY2soX3RoaXMuX2NyZWF0ZUV2ZW50KCdkb25lJykpOyB9LCAncGxheWVyLm9uRG9uZScpKTtcbiAgICAgICAgICAgIHRoaXMuX3BsYXllci5vbkRvbmUoZm4pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQW5pbWF0aW9uVHJhbnNpdGlvbjtcbiAgICB9KCkpO1xuXG4gICAgdmFyIERlYnVnRG9tUm9vdFJlbmRlcmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gX2RlbGVnYXRlXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBEZWJ1Z0RvbVJvb3RSZW5kZXJlcihfZGVsZWdhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2RlbGVnYXRlID0gX2RlbGVnYXRlO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGNvbXBvbmVudFByb3RvXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBEZWJ1Z0RvbVJvb3RSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyQ29tcG9uZW50ID0gZnVuY3Rpb24gKGNvbXBvbmVudFByb3RvKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERlYnVnRG9tUmVuZGVyZXIodGhpcy5fZGVsZWdhdGUucmVuZGVyQ29tcG9uZW50KGNvbXBvbmVudFByb3RvKSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBEZWJ1Z0RvbVJvb3RSZW5kZXJlcjtcbiAgICB9KCkpO1xuICAgIHZhciBEZWJ1Z0RvbVJlbmRlcmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gX2RlbGVnYXRlXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBEZWJ1Z0RvbVJlbmRlcmVyKF9kZWxlZ2F0ZSkge1xuICAgICAgICAgICAgdGhpcy5fZGVsZWdhdGUgPSBfZGVsZWdhdGU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gc2VsZWN0b3JPck5vZGVcbiAgICAgICAgICogQHBhcmFtIHs/PX0gZGVidWdJbmZvXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBEZWJ1Z0RvbVJlbmRlcmVyLnByb3RvdHlwZS5zZWxlY3RSb290RWxlbWVudCA9IGZ1bmN0aW9uIChzZWxlY3Rvck9yTm9kZSwgZGVidWdJbmZvKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuYXRpdmVFbCA9IHRoaXMuX2RlbGVnYXRlLnNlbGVjdFJvb3RFbGVtZW50KHNlbGVjdG9yT3JOb2RlLCBkZWJ1Z0luZm8pO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVidWdFbCA9IG5ldyBEZWJ1Z0VsZW1lbnQobmF0aXZlRWwsIG51bGwsIGRlYnVnSW5mbyk7XG4gICAgICAgICAgICBpbmRleERlYnVnTm9kZShkZWJ1Z0VsKTtcbiAgICAgICAgICAgIHJldHVybiBuYXRpdmVFbDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gcGFyZW50RWxlbWVudFxuICAgICAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgICAgICogQHBhcmFtIHs/PX0gZGVidWdJbmZvXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBEZWJ1Z0RvbVJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKHBhcmVudEVsZW1lbnQsIG5hbWUsIGRlYnVnSW5mbykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmF0aXZlRWwgPSB0aGlzLl9kZWxlZ2F0ZS5jcmVhdGVFbGVtZW50KHBhcmVudEVsZW1lbnQsIG5hbWUsIGRlYnVnSW5mbyk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZWJ1Z0VsID0gbmV3IERlYnVnRWxlbWVudChuYXRpdmVFbCwgZ2V0RGVidWdOb2RlKHBhcmVudEVsZW1lbnQpLCBkZWJ1Z0luZm8pO1xuICAgICAgICAgICAgZGVidWdFbC5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgIGluZGV4RGVidWdOb2RlKGRlYnVnRWwpO1xuICAgICAgICAgICAgcmV0dXJuIG5hdGl2ZUVsO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBob3N0RWxlbWVudFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRGVidWdEb21SZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlVmlld1Jvb3QgPSBmdW5jdGlvbiAoaG9zdEVsZW1lbnQpIHsgcmV0dXJuIHRoaXMuX2RlbGVnYXRlLmNyZWF0ZVZpZXdSb290KGhvc3RFbGVtZW50KTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gcGFyZW50RWxlbWVudFxuICAgICAgICAgKiBAcGFyYW0gez89fSBkZWJ1Z0luZm9cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIERlYnVnRG9tUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZVRlbXBsYXRlQW5jaG9yID0gZnVuY3Rpb24gKHBhcmVudEVsZW1lbnQsIGRlYnVnSW5mbykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29tbWVudCA9IHRoaXMuX2RlbGVnYXRlLmNyZWF0ZVRlbXBsYXRlQW5jaG9yKHBhcmVudEVsZW1lbnQsIGRlYnVnSW5mbyk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZWJ1Z0VsID0gbmV3IERlYnVnTm9kZShjb21tZW50LCBnZXREZWJ1Z05vZGUocGFyZW50RWxlbWVudCksIGRlYnVnSW5mbyk7XG4gICAgICAgICAgICBpbmRleERlYnVnTm9kZShkZWJ1Z0VsKTtcbiAgICAgICAgICAgIHJldHVybiBjb21tZW50O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBwYXJlbnRFbGVtZW50XG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHBhcmFtIHs/PX0gZGVidWdJbmZvXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBEZWJ1Z0RvbVJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVUZXh0ID0gZnVuY3Rpb24gKHBhcmVudEVsZW1lbnQsIHZhbHVlLCBkZWJ1Z0luZm8pIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRleHQgPSB0aGlzLl9kZWxlZ2F0ZS5jcmVhdGVUZXh0KHBhcmVudEVsZW1lbnQsIHZhbHVlLCBkZWJ1Z0luZm8pO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVidWdFbCA9IG5ldyBEZWJ1Z05vZGUodGV4dCwgZ2V0RGVidWdOb2RlKHBhcmVudEVsZW1lbnQpLCBkZWJ1Z0luZm8pO1xuICAgICAgICAgICAgaW5kZXhEZWJ1Z05vZGUoZGVidWdFbCk7XG4gICAgICAgICAgICByZXR1cm4gdGV4dDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gcGFyZW50RWxlbWVudFxuICAgICAgICAgKiBAcGFyYW0gez99IG5vZGVzXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBEZWJ1Z0RvbVJlbmRlcmVyLnByb3RvdHlwZS5wcm9qZWN0Tm9kZXMgPSBmdW5jdGlvbiAocGFyZW50RWxlbWVudCwgbm9kZXMpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlYnVnUGFyZW50ID0gZ2V0RGVidWdOb2RlKHBhcmVudEVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChkZWJ1Z1BhcmVudCkgJiYgZGVidWdQYXJlbnQgaW5zdGFuY2VvZiBEZWJ1Z0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZWJ1Z0VsZW1lbnRfMSA9IGRlYnVnUGFyZW50O1xuICAgICAgICAgICAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHsgZGVidWdFbGVtZW50XzEuYWRkQ2hpbGQoZ2V0RGVidWdOb2RlKG5vZGUpKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9kZWxlZ2F0ZS5wcm9qZWN0Tm9kZXMocGFyZW50RWxlbWVudCwgbm9kZXMpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBub2RlXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmlld1Jvb3ROb2Rlc1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRGVidWdEb21SZW5kZXJlci5wcm90b3R5cGUuYXR0YWNoVmlld0FmdGVyID0gZnVuY3Rpb24gKG5vZGUsIHZpZXdSb290Tm9kZXMpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlYnVnTm9kZSA9IGdldERlYnVnTm9kZShub2RlKTtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoZGVidWdOb2RlKSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlYnVnUGFyZW50ID0gZGVidWdOb2RlLnBhcmVudDtcbiAgICAgICAgICAgICAgICBpZiAodmlld1Jvb3ROb2Rlcy5sZW5ndGggPiAwICYmIGlzUHJlc2VudChkZWJ1Z1BhcmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVidWdWaWV3Um9vdE5vZGVzXzEgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdmlld1Jvb3ROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChyb290Tm9kZSkgeyByZXR1cm4gZGVidWdWaWV3Um9vdE5vZGVzXzEucHVzaChnZXREZWJ1Z05vZGUocm9vdE5vZGUpKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnUGFyZW50Lmluc2VydENoaWxkcmVuQWZ0ZXIoZGVidWdOb2RlLCBkZWJ1Z1ZpZXdSb290Tm9kZXNfMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZGVsZWdhdGUuYXR0YWNoVmlld0FmdGVyKG5vZGUsIHZpZXdSb290Tm9kZXMpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2aWV3Um9vdE5vZGVzXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBEZWJ1Z0RvbVJlbmRlcmVyLnByb3RvdHlwZS5kZXRhY2hWaWV3ID0gZnVuY3Rpb24gKHZpZXdSb290Tm9kZXMpIHtcbiAgICAgICAgICAgIHZpZXdSb290Tm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlYnVnTm9kZSA9IGdldERlYnVnTm9kZShub2RlKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KGRlYnVnTm9kZSkgJiYgaXNQcmVzZW50KGRlYnVnTm9kZS5wYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnTm9kZS5wYXJlbnQucmVtb3ZlQ2hpbGQoZGVidWdOb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX2RlbGVnYXRlLmRldGFjaFZpZXcodmlld1Jvb3ROb2Rlcyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGhvc3RFbGVtZW50XG4gICAgICAgICAqIEBwYXJhbSB7P30gdmlld0FsbE5vZGVzXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBEZWJ1Z0RvbVJlbmRlcmVyLnByb3RvdHlwZS5kZXN0cm95VmlldyA9IGZ1bmN0aW9uIChob3N0RWxlbWVudCwgdmlld0FsbE5vZGVzKSB7XG4gICAgICAgICAgICB2aWV3QWxsTm9kZXMgPSB2aWV3QWxsTm9kZXMgfHwgW107XG4gICAgICAgICAgICB2aWV3QWxsTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkgeyByZW1vdmVEZWJ1Z05vZGVGcm9tSW5kZXgoZ2V0RGVidWdOb2RlKG5vZGUpKTsgfSk7XG4gICAgICAgICAgICB0aGlzLl9kZWxlZ2F0ZS5kZXN0cm95Vmlldyhob3N0RWxlbWVudCwgdmlld0FsbE5vZGVzKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gcmVuZGVyRWxlbWVudFxuICAgICAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgICAgICogQHBhcmFtIHs/fSBjYWxsYmFja1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRGVidWdEb21SZW5kZXJlci5wcm90b3R5cGUubGlzdGVuID0gZnVuY3Rpb24gKHJlbmRlckVsZW1lbnQsIG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZWJ1Z0VsID0gZ2V0RGVidWdOb2RlKHJlbmRlckVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChkZWJ1Z0VsKSkge1xuICAgICAgICAgICAgICAgIGRlYnVnRWwubGlzdGVuZXJzLnB1c2gobmV3IEV2ZW50TGlzdGVuZXIobmFtZSwgY2FsbGJhY2spKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWxlZ2F0ZS5saXN0ZW4ocmVuZGVyRWxlbWVudCwgbmFtZSwgY2FsbGJhY2spO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB0YXJnZXRcbiAgICAgICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICAgICAqIEBwYXJhbSB7P30gY2FsbGJhY2tcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIERlYnVnRG9tUmVuZGVyZXIucHJvdG90eXBlLmxpc3Rlbkdsb2JhbCA9IGZ1bmN0aW9uICh0YXJnZXQsIG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVsZWdhdGUubGlzdGVuR2xvYmFsKHRhcmdldCwgbmFtZSwgY2FsbGJhY2spO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSByZW5kZXJFbGVtZW50XG4gICAgICAgICAqIEBwYXJhbSB7P30gcHJvcGVydHlOYW1lXG4gICAgICAgICAqIEBwYXJhbSB7P30gcHJvcGVydHlWYWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRGVidWdEb21SZW5kZXJlci5wcm90b3R5cGUuc2V0RWxlbWVudFByb3BlcnR5ID0gZnVuY3Rpb24gKHJlbmRlckVsZW1lbnQsIHByb3BlcnR5TmFtZSwgcHJvcGVydHlWYWx1ZSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVidWdFbCA9IGdldERlYnVnTm9kZShyZW5kZXJFbGVtZW50KTtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoZGVidWdFbCkgJiYgZGVidWdFbCBpbnN0YW5jZW9mIERlYnVnRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGRlYnVnRWwucHJvcGVydGllc1twcm9wZXJ0eU5hbWVdID0gcHJvcGVydHlWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2RlbGVnYXRlLnNldEVsZW1lbnRQcm9wZXJ0eShyZW5kZXJFbGVtZW50LCBwcm9wZXJ0eU5hbWUsIHByb3BlcnR5VmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSByZW5kZXJFbGVtZW50XG4gICAgICAgICAqIEBwYXJhbSB7P30gYXR0cmlidXRlTmFtZVxuICAgICAgICAgKiBAcGFyYW0gez99IGF0dHJpYnV0ZVZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBEZWJ1Z0RvbVJlbmRlcmVyLnByb3RvdHlwZS5zZXRFbGVtZW50QXR0cmlidXRlID0gZnVuY3Rpb24gKHJlbmRlckVsZW1lbnQsIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZWJ1Z0VsID0gZ2V0RGVidWdOb2RlKHJlbmRlckVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChkZWJ1Z0VsKSAmJiBkZWJ1Z0VsIGluc3RhbmNlb2YgRGVidWdFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgZGVidWdFbC5hdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdID0gYXR0cmlidXRlVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9kZWxlZ2F0ZS5zZXRFbGVtZW50QXR0cmlidXRlKHJlbmRlckVsZW1lbnQsIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gcmVuZGVyRWxlbWVudFxuICAgICAgICAgKiBAcGFyYW0gez99IHByb3BlcnR5TmFtZVxuICAgICAgICAgKiBAcGFyYW0gez99IHByb3BlcnR5VmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIERlYnVnRG9tUmVuZGVyZXIucHJvdG90eXBlLnNldEJpbmRpbmdEZWJ1Z0luZm8gPSBmdW5jdGlvbiAocmVuZGVyRWxlbWVudCwgcHJvcGVydHlOYW1lLCBwcm9wZXJ0eVZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9kZWxlZ2F0ZS5zZXRCaW5kaW5nRGVidWdJbmZvKHJlbmRlckVsZW1lbnQsIHByb3BlcnR5TmFtZSwgcHJvcGVydHlWYWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHJlbmRlckVsZW1lbnRcbiAgICAgICAgICogQHBhcmFtIHs/fSBjbGFzc05hbWVcbiAgICAgICAgICogQHBhcmFtIHs/fSBpc0FkZFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRGVidWdEb21SZW5kZXJlci5wcm90b3R5cGUuc2V0RWxlbWVudENsYXNzID0gZnVuY3Rpb24gKHJlbmRlckVsZW1lbnQsIGNsYXNzTmFtZSwgaXNBZGQpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlYnVnRWwgPSBnZXREZWJ1Z05vZGUocmVuZGVyRWxlbWVudCk7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KGRlYnVnRWwpICYmIGRlYnVnRWwgaW5zdGFuY2VvZiBEZWJ1Z0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBkZWJ1Z0VsLmNsYXNzZXNbY2xhc3NOYW1lXSA9IGlzQWRkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZGVsZWdhdGUuc2V0RWxlbWVudENsYXNzKHJlbmRlckVsZW1lbnQsIGNsYXNzTmFtZSwgaXNBZGQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSByZW5kZXJFbGVtZW50XG4gICAgICAgICAqIEBwYXJhbSB7P30gc3R5bGVOYW1lXG4gICAgICAgICAqIEBwYXJhbSB7P30gc3R5bGVWYWx1ZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRGVidWdEb21SZW5kZXJlci5wcm90b3R5cGUuc2V0RWxlbWVudFN0eWxlID0gZnVuY3Rpb24gKHJlbmRlckVsZW1lbnQsIHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVidWdFbCA9IGdldERlYnVnTm9kZShyZW5kZXJFbGVtZW50KTtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoZGVidWdFbCkgJiYgZGVidWdFbCBpbnN0YW5jZW9mIERlYnVnRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGRlYnVnRWwuc3R5bGVzW3N0eWxlTmFtZV0gPSBzdHlsZVZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZGVsZWdhdGUuc2V0RWxlbWVudFN0eWxlKHJlbmRlckVsZW1lbnQsIHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHJlbmRlckVsZW1lbnRcbiAgICAgICAgICogQHBhcmFtIHs/fSBtZXRob2ROYW1lXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IGFyZ3NcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIERlYnVnRG9tUmVuZGVyZXIucHJvdG90eXBlLmludm9rZUVsZW1lbnRNZXRob2QgPSBmdW5jdGlvbiAocmVuZGVyRWxlbWVudCwgbWV0aG9kTmFtZSwgYXJncykge1xuICAgICAgICAgICAgdGhpcy5fZGVsZWdhdGUuaW52b2tlRWxlbWVudE1ldGhvZChyZW5kZXJFbGVtZW50LCBtZXRob2ROYW1lLCBhcmdzKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gcmVuZGVyTm9kZVxuICAgICAgICAgKiBAcGFyYW0gez99IHRleHRcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIERlYnVnRG9tUmVuZGVyZXIucHJvdG90eXBlLnNldFRleHQgPSBmdW5jdGlvbiAocmVuZGVyTm9kZSwgdGV4dCkgeyB0aGlzLl9kZWxlZ2F0ZS5zZXRUZXh0KHJlbmRlck5vZGUsIHRleHQpOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICAgICAqIEBwYXJhbSB7P30gc3RhcnRpbmdTdHlsZXNcbiAgICAgICAgICogQHBhcmFtIHs/fSBrZXlmcmFtZXNcbiAgICAgICAgICogQHBhcmFtIHs/fSBkdXJhdGlvblxuICAgICAgICAgKiBAcGFyYW0gez99IGRlbGF5XG4gICAgICAgICAqIEBwYXJhbSB7P30gZWFzaW5nXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IHByZXZpb3VzUGxheWVyc1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRGVidWdEb21SZW5kZXJlci5wcm90b3R5cGUuYW5pbWF0ZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBzdGFydGluZ1N0eWxlcywga2V5ZnJhbWVzLCBkdXJhdGlvbiwgZGVsYXksIGVhc2luZywgcHJldmlvdXNQbGF5ZXJzKSB7XG4gICAgICAgICAgICBpZiAocHJldmlvdXNQbGF5ZXJzID09PSB2b2lkIDApIHsgcHJldmlvdXNQbGF5ZXJzID0gW107IH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWxlZ2F0ZS5hbmltYXRlKGVsZW1lbnQsIHN0YXJ0aW5nU3R5bGVzLCBrZXlmcmFtZXMsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nLCBwcmV2aW91c1BsYXllcnMpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRGVidWdEb21SZW5kZXJlcjtcbiAgICB9KCkpO1xuXG4gICAgdmFyIFZpZXdUeXBlID0ge307XG4gICAgVmlld1R5cGUuSE9TVCA9IDA7XG4gICAgVmlld1R5cGUuQ09NUE9ORU5UID0gMTtcbiAgICBWaWV3VHlwZS5FTUJFRERFRCA9IDI7XG4gICAgVmlld1R5cGVbVmlld1R5cGUuSE9TVF0gPSBcIkhPU1RcIjtcbiAgICBWaWV3VHlwZVtWaWV3VHlwZS5DT01QT05FTlRdID0gXCJDT01QT05FTlRcIjtcbiAgICBWaWV3VHlwZVtWaWV3VHlwZS5FTUJFRERFRF0gPSBcIkVNQkVEREVEXCI7XG5cbiAgICB2YXIgU3RhdGljTm9kZURlYnVnSW5mbyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHByb3ZpZGVyVG9rZW5zXG4gICAgICAgICAqIEBwYXJhbSB7P30gY29tcG9uZW50VG9rZW5cbiAgICAgICAgICogQHBhcmFtIHs/fSByZWZUb2tlbnNcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIFN0YXRpY05vZGVEZWJ1Z0luZm8ocHJvdmlkZXJUb2tlbnMsIGNvbXBvbmVudFRva2VuLCByZWZUb2tlbnMpIHtcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXJUb2tlbnMgPSBwcm92aWRlclRva2VucztcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50VG9rZW4gPSBjb21wb25lbnRUb2tlbjtcbiAgICAgICAgICAgIHRoaXMucmVmVG9rZW5zID0gcmVmVG9rZW5zO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTdGF0aWNOb2RlRGVidWdJbmZvO1xuICAgIH0oKSk7XG4gICAgdmFyIERlYnVnQ29udGV4dCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IF92aWV3XG4gICAgICAgICAqIEBwYXJhbSB7P30gX25vZGVJbmRleFxuICAgICAgICAgKiBAcGFyYW0gez99IF90cGxSb3dcbiAgICAgICAgICogQHBhcmFtIHs/fSBfdHBsQ29sXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBEZWJ1Z0NvbnRleHQoX3ZpZXcsIF9ub2RlSW5kZXgsIF90cGxSb3csIF90cGxDb2wpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZpZXcgPSBfdmlldztcbiAgICAgICAgICAgIHRoaXMuX25vZGVJbmRleCA9IF9ub2RlSW5kZXg7XG4gICAgICAgICAgICB0aGlzLl90cGxSb3cgPSBfdHBsUm93O1xuICAgICAgICAgICAgdGhpcy5fdHBsQ29sID0gX3RwbENvbDtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVidWdDb250ZXh0LnByb3RvdHlwZSwgXCJfc3RhdGljTm9kZUluZm9cIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMuX25vZGVJbmRleCkgPyB0aGlzLl92aWV3LnN0YXRpY05vZGVEZWJ1Z0luZm9zW3RoaXMuX25vZGVJbmRleF0gOiBudWxsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWJ1Z0NvbnRleHQucHJvdG90eXBlLCBcImNvbnRleHRcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3ZpZXcuY29udGV4dDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWJ1Z0NvbnRleHQucHJvdG90eXBlLCBcImNvbXBvbmVudFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXRpY05vZGVJbmZvID0gdGhpcy5fc3RhdGljTm9kZUluZm87XG4gICAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudChzdGF0aWNOb2RlSW5mbykgJiYgaXNQcmVzZW50KHN0YXRpY05vZGVJbmZvLmNvbXBvbmVudFRva2VuKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbmplY3Rvci5nZXQoc3RhdGljTm9kZUluZm8uY29tcG9uZW50VG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVidWdDb250ZXh0LnByb3RvdHlwZSwgXCJjb21wb25lbnRSZW5kZXJFbGVtZW50XCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29tcG9uZW50VmlldyA9IHRoaXMuX3ZpZXc7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGlzUHJlc2VudChjb21wb25lbnRWaWV3LnBhcmVudFZpZXcpICYmIGNvbXBvbmVudFZpZXcudHlwZSAhPT0gVmlld1R5cGUuQ09NUE9ORU5UKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudFZpZXcgPSAoY29tcG9uZW50Vmlldy5wYXJlbnRWaWV3KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBvbmVudFZpZXcucGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVidWdDb250ZXh0LnByb3RvdHlwZSwgXCJpbmplY3RvclwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fdmlldy5pbmplY3Rvcih0aGlzLl9ub2RlSW5kZXgpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlYnVnQ29udGV4dC5wcm90b3R5cGUsIFwicmVuZGVyTm9kZVwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5fbm9kZUluZGV4KSAmJiB0aGlzLl92aWV3LmFsbE5vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92aWV3LmFsbE5vZGVzW3RoaXMuX25vZGVJbmRleF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlYnVnQ29udGV4dC5wcm90b3R5cGUsIFwicHJvdmlkZXJUb2tlbnNcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGF0aWNOb2RlSW5mbyA9IHRoaXMuX3N0YXRpY05vZGVJbmZvO1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1ByZXNlbnQoc3RhdGljTm9kZUluZm8pID8gc3RhdGljTm9kZUluZm8ucHJvdmlkZXJUb2tlbnMgOiBudWxsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWJ1Z0NvbnRleHQucHJvdG90eXBlLCBcInNvdXJjZVwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl92aWV3LmNvbXBvbmVudFR5cGUudGVtcGxhdGVVcmwgKyBcIjpcIiArIHRoaXMuX3RwbFJvdyArIFwiOlwiICsgdGhpcy5fdHBsQ29sO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWJ1Z0NvbnRleHQucHJvdG90eXBlLCBcInJlZmVyZW5jZXNcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhclZhbHVlcyA9IHt9O1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXRpY05vZGVJbmZvID0gdGhpcy5fc3RhdGljTm9kZUluZm87XG4gICAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudChzdGF0aWNOb2RlSW5mbykpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVmc18xID0gc3RhdGljTm9kZUluZm8ucmVmVG9rZW5zO1xuICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhyZWZzXzEpLmZvckVhY2goZnVuY3Rpb24gKHJlZk5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlZlRva2VuID0gcmVmc18xW3JlZk5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFyVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNCbGFuayhyZWZUb2tlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJWYWx1ZSA9IF90aGlzLl92aWV3LmFsbE5vZGVzID8gX3RoaXMuX3ZpZXcuYWxsTm9kZXNbX3RoaXMuX25vZGVJbmRleF0gOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyVmFsdWUgPSBfdGhpcy5fdmlldy5pbmplY3RvckdldChyZWZUb2tlbiwgX3RoaXMuX25vZGVJbmRleCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXJWYWx1ZXNbcmVmTmFtZV0gPSB2YXJWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB2YXJWYWx1ZXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIERlYnVnQ29udGV4dDtcbiAgICB9KCkpO1xuXG4gICAgdmFyIFZpZXdBbmltYXRpb25NYXAgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBWaWV3QW5pbWF0aW9uTWFwKCkge1xuICAgICAgICAgICAgdGhpcy5fbWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgdGhpcy5fYWxsUGxheWVycyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgICAgICogQHBhcmFtIHs/fSBhbmltYXRpb25OYW1lXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBWaWV3QW5pbWF0aW9uTWFwLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKGVsZW1lbnQsIGFuaW1hdGlvbk5hbWUpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBsYXllcnNCeUFuaW1hdGlvbiA9IHRoaXMuX21hcC5nZXQoZWxlbWVudCk7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHBsYXllcnNCeUFuaW1hdGlvbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGxheWVyc0J5QW5pbWF0aW9uW2FuaW1hdGlvbk5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBWaWV3QW5pbWF0aW9uTWFwLnByb3RvdHlwZS5maW5kQWxsUGxheWVyc0J5RWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbCA9IHRoaXMuX21hcC5nZXQoZWxlbWVudCk7XG4gICAgICAgICAgICByZXR1cm4gZWwgPyBPYmplY3Qua2V5cyhlbCkubWFwKGZ1bmN0aW9uIChrKSB7IHJldHVybiBlbFtrXTsgfSkgOiBbXTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAgICAgKiBAcGFyYW0gez99IGFuaW1hdGlvbk5hbWVcbiAgICAgICAgICogQHBhcmFtIHs/fSBwbGF5ZXJcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFZpZXdBbmltYXRpb25NYXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChlbGVtZW50LCBhbmltYXRpb25OYW1lLCBwbGF5ZXIpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBsYXllcnNCeUFuaW1hdGlvbiA9IHRoaXMuX21hcC5nZXQoZWxlbWVudCk7XG4gICAgICAgICAgICBpZiAoIWlzUHJlc2VudChwbGF5ZXJzQnlBbmltYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgcGxheWVyc0J5QW5pbWF0aW9uID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleGlzdGluZ0VudHJ5ID0gcGxheWVyc0J5QW5pbWF0aW9uW2FuaW1hdGlvbk5hbWVdO1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChleGlzdGluZ0VudHJ5KSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlKGVsZW1lbnQsIGFuaW1hdGlvbk5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGxheWVyc0J5QW5pbWF0aW9uW2FuaW1hdGlvbk5hbWVdID0gcGxheWVyO1xuICAgICAgICAgICAgdGhpcy5fYWxsUGxheWVycy5wdXNoKHBsYXllcik7XG4gICAgICAgICAgICB0aGlzLl9tYXAuc2V0KGVsZW1lbnQsIHBsYXllcnNCeUFuaW1hdGlvbik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgVmlld0FuaW1hdGlvbk1hcC5wcm90b3R5cGUuZ2V0QWxsUGxheWVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2FsbFBsYXllcnM7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgICAgICogQHBhcmFtIHs/fSBhbmltYXRpb25OYW1lXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IHRhcmdldFBsYXllclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgVmlld0FuaW1hdGlvbk1hcC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGVsZW1lbnQsIGFuaW1hdGlvbk5hbWUsIHRhcmdldFBsYXllcikge1xuICAgICAgICAgICAgaWYgKHRhcmdldFBsYXllciA9PT0gdm9pZCAwKSB7IHRhcmdldFBsYXllciA9IG51bGw7IH1cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBsYXllcnNCeUFuaW1hdGlvbiA9IHRoaXMuX21hcC5nZXQoZWxlbWVudCk7XG4gICAgICAgICAgICBpZiAocGxheWVyc0J5QW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGxheWVyID0gcGxheWVyc0J5QW5pbWF0aW9uW2FuaW1hdGlvbk5hbWVdO1xuICAgICAgICAgICAgICAgIGlmICghdGFyZ2V0UGxheWVyIHx8IHBsYXllciA9PT0gdGFyZ2V0UGxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwbGF5ZXJzQnlBbmltYXRpb25bYW5pbWF0aW9uTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGluZGV4ID0gdGhpcy5fYWxsUGxheWVycy5pbmRleE9mKHBsYXllcik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FsbFBsYXllcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHBsYXllcnNCeUFuaW1hdGlvbikubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXAuZGVsZXRlKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gVmlld0FuaW1hdGlvbk1hcDtcbiAgICB9KCkpO1xuXG4gICAgdmFyIEFuaW1hdGlvblZpZXdDb250ZXh0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gX2FuaW1hdGlvblF1ZXVlXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBBbmltYXRpb25WaWV3Q29udGV4dChfYW5pbWF0aW9uUXVldWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2FuaW1hdGlvblF1ZXVlID0gX2FuaW1hdGlvblF1ZXVlO1xuICAgICAgICAgICAgdGhpcy5fcGxheWVycyA9IG5ldyBWaWV3QW5pbWF0aW9uTWFwKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gY2FsbGJhY2tcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEFuaW1hdGlvblZpZXdDb250ZXh0LnByb3RvdHlwZS5vbkFsbEFjdGl2ZUFuaW1hdGlvbnNEb25lID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhY3RpdmVBbmltYXRpb25QbGF5ZXJzID0gdGhpcy5fcGxheWVycy5nZXRBbGxQbGF5ZXJzKCk7XG4gICAgICAgICAgICAvLyB3ZSBjaGVjayBmb3IgdGhlIGxlbmd0aCB0byBhdm9pZCBoYXZpbmcgR3JvdXBBbmltYXRpb25QbGF5ZXJcbiAgICAgICAgICAgIC8vIGlzc3VlIGFuIHVubmVjZXNzYXJ5IG1pY3JvdGFzayB3aGVuIHplcm8gcGxheWVycyBhcmUgcGFzc2VkIGluXG4gICAgICAgICAgICBpZiAoYWN0aXZlQW5pbWF0aW9uUGxheWVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBuZXcgQW5pbWF0aW9uR3JvdXBQbGF5ZXIoYWN0aXZlQW5pbWF0aW9uUGxheWVycykub25Eb25lKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhbGxiYWNrKCk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFxuICAgICAgICAgKiBAcGFyYW0gez99IGFuaW1hdGlvbk5hbWVcbiAgICAgICAgICogQHBhcmFtIHs/fSBwbGF5ZXJcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEFuaW1hdGlvblZpZXdDb250ZXh0LnByb3RvdHlwZS5xdWV1ZUFuaW1hdGlvbiA9IGZ1bmN0aW9uIChlbGVtZW50LCBhbmltYXRpb25OYW1lLCBwbGF5ZXIpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLl9hbmltYXRpb25RdWV1ZS5lbnF1ZXVlKHBsYXllcik7XG4gICAgICAgICAgICB0aGlzLl9wbGF5ZXJzLnNldChlbGVtZW50LCBhbmltYXRpb25OYW1lLCBwbGF5ZXIpO1xuICAgICAgICAgICAgcGxheWVyLm9uRG9uZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fcGxheWVycy5yZW1vdmUoZWxlbWVudCwgYW5pbWF0aW9uTmFtZSwgcGxheWVyKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgICAgICogQHBhcmFtIHs/PX0gYW5pbWF0aW9uTmFtZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQW5pbWF0aW9uVmlld0NvbnRleHQucHJvdG90eXBlLmdldEFuaW1hdGlvblBsYXllcnMgPSBmdW5jdGlvbiAoZWxlbWVudCwgYW5pbWF0aW9uTmFtZSkge1xuICAgICAgICAgICAgaWYgKGFuaW1hdGlvbk5hbWUgPT09IHZvaWQgMCkgeyBhbmltYXRpb25OYW1lID0gbnVsbDsgfVxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGxheWVycyA9IFtdO1xuICAgICAgICAgICAgaWYgKGFuaW1hdGlvbk5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjdXJyZW50UGxheWVyID0gdGhpcy5fcGxheWVycy5maW5kKGVsZW1lbnQsIGFuaW1hdGlvbk5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UGxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIF9yZWN1cnNlUGxheWVycyhjdXJyZW50UGxheWVyLCBwbGF5ZXJzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wbGF5ZXJzLmZpbmRBbGxQbGF5ZXJzQnlFbGVtZW50KGVsZW1lbnQpLmZvckVhY2goZnVuY3Rpb24gKHBsYXllcikgeyByZXR1cm4gX3JlY3Vyc2VQbGF5ZXJzKHBsYXllciwgcGxheWVycyk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBsYXllcnM7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBBbmltYXRpb25WaWV3Q29udGV4dDtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGxheWVyXG4gICAgICogQHBhcmFtIHs/fSBjb2xsZWN0ZWRQbGF5ZXJzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfcmVjdXJzZVBsYXllcnMocGxheWVyLCBjb2xsZWN0ZWRQbGF5ZXJzKSB7XG4gICAgICAgIGlmICgocGxheWVyIGluc3RhbmNlb2YgQW5pbWF0aW9uR3JvdXBQbGF5ZXIpIHx8IChwbGF5ZXIgaW5zdGFuY2VvZiBBbmltYXRpb25TZXF1ZW5jZVBsYXllcikpIHtcbiAgICAgICAgICAgIHBsYXllci5wbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBsYXllcikgeyByZXR1cm4gX3JlY3Vyc2VQbGF5ZXJzKHBsYXllciwgY29sbGVjdGVkUGxheWVycyk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29sbGVjdGVkUGxheWVycy5wdXNoKHBsYXllcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQxNSA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIHZhciBFbGVtZW50SW5qZWN0b3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMTUoRWxlbWVudEluamVjdG9yLCBfc3VwZXIpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBfdmlld1xuICAgICAgICAgKiBAcGFyYW0gez99IF9ub2RlSW5kZXhcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIEVsZW1lbnRJbmplY3RvcihfdmlldywgX25vZGVJbmRleCkge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl92aWV3ID0gX3ZpZXc7XG4gICAgICAgICAgICB0aGlzLl9ub2RlSW5kZXggPSBfbm9kZUluZGV4O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHRva2VuXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IG5vdEZvdW5kVmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEVsZW1lbnRJbmplY3Rvci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHRva2VuLCBub3RGb3VuZFZhbHVlKSB7XG4gICAgICAgICAgICBpZiAobm90Rm91bmRWYWx1ZSA9PT0gdm9pZCAwKSB7IG5vdEZvdW5kVmFsdWUgPSBUSFJPV19JRl9OT1RfRk9VTkQ7IH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92aWV3LmluamVjdG9yR2V0KHRva2VuLCB0aGlzLl9ub2RlSW5kZXgsIG5vdEZvdW5kVmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRWxlbWVudEluamVjdG9yO1xuICAgIH0oSW5qZWN0b3IpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDE0ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gX3Njb3BlX2NoZWNrID0gd3RmQ3JlYXRlU2NvcGUoXCJBcHBWaWV3I2NoZWNrKGFzY2lpIGlkKVwiKTtcbiAgICAvKipcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gRU1QVFlfQ09OVEVYVCA9IG5ldyBPYmplY3QoKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBVTkRFRklORUQkMSA9IG5ldyBPYmplY3QoKTtcbiAgICAvKipcbiAgICAgKiBDb3N0IG9mIG1ha2luZyBvYmplY3RzOiBodHRwOi8vanNwZXJmLmNvbS9pbnN0YW50aWF0ZS1zaXplLW9mLW9iamVjdFxuICAgICAqXG4gICAgICogQGFic3RyYWN0XG4gICAgICovXG4gICAgdmFyIEFwcFZpZXcgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBjbGF6elxuICAgICAgICAgKiBAcGFyYW0gez99IGNvbXBvbmVudFR5cGVcbiAgICAgICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmlld1V0aWxzXG4gICAgICAgICAqIEBwYXJhbSB7P30gcGFyZW50Vmlld1xuICAgICAgICAgKiBAcGFyYW0gez99IHBhcmVudEluZGV4XG4gICAgICAgICAqIEBwYXJhbSB7P30gcGFyZW50RWxlbWVudFxuICAgICAgICAgKiBAcGFyYW0gez99IGNkTW9kZVxuICAgICAgICAgKiBAcGFyYW0gez89fSBkZWNsYXJlZFZpZXdDb250YWluZXJcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIEFwcFZpZXcoY2xhenosIGNvbXBvbmVudFR5cGUsIHR5cGUsIHZpZXdVdGlscywgcGFyZW50VmlldywgcGFyZW50SW5kZXgsIHBhcmVudEVsZW1lbnQsIGNkTW9kZSwgZGVjbGFyZWRWaWV3Q29udGFpbmVyKSB7XG4gICAgICAgICAgICBpZiAoZGVjbGFyZWRWaWV3Q29udGFpbmVyID09PSB2b2lkIDApIHsgZGVjbGFyZWRWaWV3Q29udGFpbmVyID0gbnVsbDsgfVxuICAgICAgICAgICAgdGhpcy5jbGF6eiA9IGNsYXp6O1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRUeXBlID0gY29tcG9uZW50VHlwZTtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgICAgICB0aGlzLnZpZXdVdGlscyA9IHZpZXdVdGlscztcbiAgICAgICAgICAgIHRoaXMucGFyZW50VmlldyA9IHBhcmVudFZpZXc7XG4gICAgICAgICAgICB0aGlzLnBhcmVudEluZGV4ID0gcGFyZW50SW5kZXg7XG4gICAgICAgICAgICB0aGlzLnBhcmVudEVsZW1lbnQgPSBwYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgdGhpcy5jZE1vZGUgPSBjZE1vZGU7XG4gICAgICAgICAgICB0aGlzLmRlY2xhcmVkVmlld0NvbnRhaW5lciA9IGRlY2xhcmVkVmlld0NvbnRhaW5lcjtcbiAgICAgICAgICAgIHRoaXMubnVtYmVyT2ZDaGVja3MgPSAwO1xuICAgICAgICAgICAgdGhpcy5yZWYgPSBuZXcgVmlld1JlZl8odGhpcywgdmlld1V0aWxzLmFuaW1hdGlvblF1ZXVlKTtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBWaWV3VHlwZS5DT01QT05FTlQgfHwgdHlwZSA9PT0gVmlld1R5cGUuSE9TVCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIgPSB2aWV3VXRpbHMucmVuZGVyQ29tcG9uZW50KGNvbXBvbmVudFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlciA9IHBhcmVudFZpZXcucmVuZGVyZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9kaXJlY3RSZW5kZXJlciA9IHRoaXMucmVuZGVyZXIuZGlyZWN0UmVuZGVyZXI7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFwcFZpZXcucHJvdG90eXBlLCBcImFuaW1hdGlvbkNvbnRleHRcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2FuaW1hdGlvbkNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYW5pbWF0aW9uQ29udGV4dCA9IG5ldyBBbmltYXRpb25WaWV3Q29udGV4dCh0aGlzLnZpZXdVdGlscy5hbmltYXRpb25RdWV1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9hbmltYXRpb25Db250ZXh0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcHBWaWV3LnByb3RvdHlwZSwgXCJkZXN0cm95ZWRcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuY2RNb2RlID09PSBDaGFuZ2VEZXRlY3RvclN0YXR1cy5EZXN0cm95ZWQ7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBcHBWaWV3LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUludGVybmFsKG51bGwpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSByb290U2VsZWN0b3JPck5vZGVcbiAgICAgICAgICogQHBhcmFtIHs/fSBob3N0SW5qZWN0b3JcbiAgICAgICAgICogQHBhcmFtIHs/fSBwcm9qZWN0YWJsZU5vZGVzXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBcHBWaWV3LnByb3RvdHlwZS5jcmVhdGVIb3N0VmlldyA9IGZ1bmN0aW9uIChyb290U2VsZWN0b3JPck5vZGUsIGhvc3RJbmplY3RvciwgcHJvamVjdGFibGVOb2Rlcykge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0ID0gKEVNUFRZX0NPTlRFWFQpO1xuICAgICAgICAgICAgdGhpcy5faGFzRXh0ZXJuYWxIb3N0RWxlbWVudCA9IGlzUHJlc2VudChyb290U2VsZWN0b3JPck5vZGUpO1xuICAgICAgICAgICAgdGhpcy5faG9zdEluamVjdG9yID0gaG9zdEluamVjdG9yO1xuICAgICAgICAgICAgdGhpcy5faG9zdFByb2plY3RhYmxlTm9kZXMgPSBwcm9qZWN0YWJsZU5vZGVzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlSW50ZXJuYWwocm9vdFNlbGVjdG9yT3JOb2RlKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE92ZXJ3cml0dGVuIGJ5IGltcGxlbWVudGF0aW9ucy5cbiAgICAgICAgICogUmV0dXJucyB0aGUgQ29tcG9uZW50UmVmIGZvciB0aGUgaG9zdCBlbGVtZW50IGZvciBWaWV3VHlwZS5IT1NULlxuICAgICAgICAgKiBAcGFyYW0gez99IHJvb3RTZWxlY3Rvck9yTm9kZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQXBwVmlldy5wcm90b3R5cGUuY3JlYXRlSW50ZXJuYWwgPSBmdW5jdGlvbiAocm9vdFNlbGVjdG9yT3JOb2RlKSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogT3ZlcndyaXR0ZW4gYnkgaW1wbGVtZW50YXRpb25zLlxuICAgICAgICAgKiBAcGFyYW0gez99IHRlbXBsYXRlTm9kZUluZGV4XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBcHBWaWV3LnByb3RvdHlwZS5jcmVhdGVFbWJlZGRlZFZpZXdJbnRlcm5hbCA9IGZ1bmN0aW9uICh0ZW1wbGF0ZU5vZGVJbmRleCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gbGFzdFJvb3ROb2RlXG4gICAgICAgICAqIEBwYXJhbSB7P30gYWxsTm9kZXNcbiAgICAgICAgICogQHBhcmFtIHs/fSBkaXNwb3NhYmxlc1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQXBwVmlldy5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChsYXN0Um9vdE5vZGUsIGFsbE5vZGVzLCBkaXNwb3NhYmxlcykge1xuICAgICAgICAgICAgdGhpcy5sYXN0Um9vdE5vZGUgPSBsYXN0Um9vdE5vZGU7XG4gICAgICAgICAgICB0aGlzLmFsbE5vZGVzID0gYWxsTm9kZXM7XG4gICAgICAgICAgICB0aGlzLmRpc3Bvc2FibGVzID0gZGlzcG9zYWJsZXM7XG4gICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSBWaWV3VHlwZS5DT01QT05FTlQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpcnR5UGFyZW50UXVlcmllc0ludGVybmFsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHRva2VuXG4gICAgICAgICAqIEBwYXJhbSB7P30gbm9kZUluZGV4XG4gICAgICAgICAqIEBwYXJhbSB7Pz19IG5vdEZvdW5kVmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEFwcFZpZXcucHJvdG90eXBlLmluamVjdG9yR2V0ID0gZnVuY3Rpb24gKHRva2VuLCBub2RlSW5kZXgsIG5vdEZvdW5kVmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChub3RGb3VuZFZhbHVlID09PSB2b2lkIDApIHsgbm90Rm91bmRWYWx1ZSA9IFRIUk9XX0lGX05PVF9GT1VORDsgfVxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0gVU5ERUZJTkVEJDE7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2aWV3ID0gdGhpcztcbiAgICAgICAgICAgIHdoaWxlIChyZXN1bHQgPT09IFVOREVGSU5FRCQxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudChub2RlSW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZpZXcuaW5qZWN0b3JHZXRJbnRlcm5hbCh0b2tlbiwgbm9kZUluZGV4LCBVTkRFRklORUQkMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IFVOREVGSU5FRCQxICYmIHZpZXcudHlwZSA9PT0gVmlld1R5cGUuSE9TVCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB2aWV3Ll9ob3N0SW5qZWN0b3IuZ2V0KHRva2VuLCBub3RGb3VuZFZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9kZUluZGV4ID0gdmlldy5wYXJlbnRJbmRleDtcbiAgICAgICAgICAgICAgICB2aWV3ID0gdmlldy5wYXJlbnRWaWV3O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE92ZXJ3cml0dGVuIGJ5IGltcGxlbWVudGF0aW9uc1xuICAgICAgICAgKiBAcGFyYW0gez99IHRva2VuXG4gICAgICAgICAqIEBwYXJhbSB7P30gbm9kZUluZGV4XG4gICAgICAgICAqIEBwYXJhbSB7P30gbm90Rm91bmRSZXN1bHRcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEFwcFZpZXcucHJvdG90eXBlLmluamVjdG9yR2V0SW50ZXJuYWwgPSBmdW5jdGlvbiAodG9rZW4sIG5vZGVJbmRleCwgbm90Rm91bmRSZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiBub3RGb3VuZFJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gbm9kZUluZGV4XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBcHBWaWV3LnByb3RvdHlwZS5pbmplY3RvciA9IGZ1bmN0aW9uIChub2RlSW5kZXgpIHsgcmV0dXJuIG5ldyBFbGVtZW50SW5qZWN0b3IodGhpcywgbm9kZUluZGV4KTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBcHBWaWV3LnByb3RvdHlwZS5kZXRhY2hBbmREZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudmlld0NvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIHRoaXMudmlld0NvbnRhaW5lci5kZXRhY2hWaWV3KHRoaXMudmlld0NvbnRhaW5lci5uZXN0ZWRWaWV3cy5pbmRleE9mKHRoaXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuYXBwUmVmKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBSZWYuZGV0YWNoVmlldyh0aGlzLnJlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9oYXNFeHRlcm5hbEhvc3RFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXRhY2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEFwcFZpZXcucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHRoaXMuY2RNb2RlID09PSBDaGFuZ2VEZXRlY3RvclN0YXR1cy5EZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBob3N0RWxlbWVudCA9IHRoaXMudHlwZSA9PT0gVmlld1R5cGUuQ09NUE9ORU5UID8gdGhpcy5wYXJlbnRFbGVtZW50IDogbnVsbDtcbiAgICAgICAgICAgIGlmICh0aGlzLmRpc3Bvc2FibGVzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IHRoaXMuZGlzcG9zYWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwb3NhYmxlc1tpXSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGVzdHJveUludGVybmFsKCk7XG4gICAgICAgICAgICB0aGlzLmRpcnR5UGFyZW50UXVlcmllc0ludGVybmFsKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fYW5pbWF0aW9uQ29udGV4dCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FuaW1hdGlvbkNvbnRleHQub25BbGxBY3RpdmVBbmltYXRpb25zRG9uZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5yZW5kZXJlci5kZXN0cm95Vmlldyhob3N0RWxlbWVudCwgX3RoaXMuYWxsTm9kZXMpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuZGVzdHJveVZpZXcoaG9zdEVsZW1lbnQsIHRoaXMuYWxsTm9kZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jZE1vZGUgPSBDaGFuZ2VEZXRlY3RvclN0YXR1cy5EZXN0cm95ZWQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPdmVyd3JpdHRlbiBieSBpbXBsZW1lbnRhdGlvbnNcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEFwcFZpZXcucHJvdG90eXBlLmRlc3Ryb3lJbnRlcm5hbCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE92ZXJ3cml0dGVuIGJ5IGltcGxlbWVudGF0aW9uc1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQXBwVmlldy5wcm90b3R5cGUuZGV0YWNoSW50ZXJuYWwgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQXBwVmlldy5wcm90b3R5cGUuZGV0YWNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuZGV0YWNoSW50ZXJuYWwoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9hbmltYXRpb25Db250ZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYW5pbWF0aW9uQ29udGV4dC5vbkFsbEFjdGl2ZUFuaW1hdGlvbnNEb25lKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9yZW5kZXJEZXRhY2goKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJEZXRhY2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmRlY2xhcmVkVmlld0NvbnRhaW5lciAmJiB0aGlzLmRlY2xhcmVkVmlld0NvbnRhaW5lciAhPT0gdGhpcy52aWV3Q29udGFpbmVyICYmXG4gICAgICAgICAgICAgICAgdGhpcy5kZWNsYXJlZFZpZXdDb250YWluZXIucHJvamVjdGVkVmlld3MpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm9qZWN0ZWRWaWV3cyA9IHRoaXMuZGVjbGFyZWRWaWV3Q29udGFpbmVyLnByb2plY3RlZFZpZXdzO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGluZGV4ID0gcHJvamVjdGVkVmlld3MuaW5kZXhPZih0aGlzKTtcbiAgICAgICAgICAgICAgICAvLyBwZXJmOiBwb3AgaXMgZmFzdGVyIHRoYW4gc3BsaWNlIVxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSBwcm9qZWN0ZWRWaWV3cy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2plY3RlZFZpZXdzLnBvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvamVjdGVkVmlld3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFwcFJlZiA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnZpZXdDb250YWluZXIgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eVBhcmVudFF1ZXJpZXNJbnRlcm5hbCgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEFwcFZpZXcucHJvdG90eXBlLl9yZW5kZXJEZXRhY2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZGlyZWN0UmVuZGVyZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpc2l0Um9vdE5vZGVzSW50ZXJuYWwodGhpcy5fZGlyZWN0UmVuZGVyZXIucmVtb3ZlLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuZGV0YWNoVmlldyh0aGlzLmZsYXRSb290Tm9kZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBhcHBSZWZcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEFwcFZpZXcucHJvdG90eXBlLmF0dGFjaFRvQXBwUmVmID0gZnVuY3Rpb24gKGFwcFJlZikge1xuICAgICAgICAgICAgaWYgKHRoaXMudmlld0NvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyB2aWV3IGlzIGFscmVhZHkgYXR0YWNoZWQgdG8gYSBWaWV3Q29udGFpbmVyIScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hcHBSZWYgPSBhcHBSZWY7XG4gICAgICAgICAgICB0aGlzLmRpcnR5UGFyZW50UXVlcmllc0ludGVybmFsKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZpZXdDb250YWluZXJcbiAgICAgICAgICogQHBhcmFtIHs/fSBwcmV2Vmlld1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQXBwVmlldy5wcm90b3R5cGUuYXR0YWNoQWZ0ZXIgPSBmdW5jdGlvbiAodmlld0NvbnRhaW5lciwgcHJldlZpZXcpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFwcFJlZikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyB2aWV3IGlzIGFscmVhZHkgYXR0YWNoZWQgZGlyZWN0bHkgdG8gdGhlIEFwcGxpY2F0aW9uUmVmIScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyQXR0YWNoKHZpZXdDb250YWluZXIsIHByZXZWaWV3KTtcbiAgICAgICAgICAgIHRoaXMudmlld0NvbnRhaW5lciA9IHZpZXdDb250YWluZXI7XG4gICAgICAgICAgICBpZiAodGhpcy5kZWNsYXJlZFZpZXdDb250YWluZXIgJiYgdGhpcy5kZWNsYXJlZFZpZXdDb250YWluZXIgIT09IHZpZXdDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZGVjbGFyZWRWaWV3Q29udGFpbmVyLnByb2plY3RlZFZpZXdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVjbGFyZWRWaWV3Q29udGFpbmVyLnByb2plY3RlZFZpZXdzID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZGVjbGFyZWRWaWV3Q29udGFpbmVyLnByb2plY3RlZFZpZXdzLnB1c2godGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRpcnR5UGFyZW50UXVlcmllc0ludGVybmFsKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZpZXdDb250YWluZXJcbiAgICAgICAgICogQHBhcmFtIHs/fSBwcmV2Vmlld1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQXBwVmlldy5wcm90b3R5cGUubW92ZUFmdGVyID0gZnVuY3Rpb24gKHZpZXdDb250YWluZXIsIHByZXZWaWV3KSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJBdHRhY2godmlld0NvbnRhaW5lciwgcHJldlZpZXcpO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eVBhcmVudFF1ZXJpZXNJbnRlcm5hbCgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2aWV3Q29udGFpbmVyXG4gICAgICAgICAqIEBwYXJhbSB7P30gcHJldlZpZXdcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEFwcFZpZXcucHJvdG90eXBlLl9yZW5kZXJBdHRhY2ggPSBmdW5jdGlvbiAodmlld0NvbnRhaW5lciwgcHJldlZpZXcpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZXZOb2RlID0gcHJldlZpZXcgPyBwcmV2Vmlldy5sYXN0Um9vdE5vZGUgOiB2aWV3Q29udGFpbmVyLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAodGhpcy5fZGlyZWN0UmVuZGVyZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZXh0U2libGluZyA9IHRoaXMuX2RpcmVjdFJlbmRlcmVyLm5leHRTaWJsaW5nKHByZXZOb2RlKTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aXNpdFJvb3ROb2Rlc0ludGVybmFsKHRoaXMuX2RpcmVjdFJlbmRlcmVyLmluc2VydEJlZm9yZSwgbmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyZW50RWxlbWVudCA9IHRoaXMuX2RpcmVjdFJlbmRlcmVyLnBhcmVudEVsZW1lbnQocHJldk5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50RWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52aXNpdFJvb3ROb2Rlc0ludGVybmFsKHRoaXMuX2RpcmVjdFJlbmRlcmVyLmFwcGVuZENoaWxkLCBwYXJlbnRFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYXR0YWNoVmlld0FmdGVyKHByZXZOb2RlLCB0aGlzLmZsYXRSb290Tm9kZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXBwVmlldy5wcm90b3R5cGUsIFwiY2hhbmdlRGV0ZWN0b3JSZWZcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucmVmOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFwcFZpZXcucHJvdG90eXBlLCBcImZsYXRSb290Tm9kZXNcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBub2RlcyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMudmlzaXRSb290Tm9kZXNJbnRlcm5hbChhZGRUb0FycmF5LCBub2Rlcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHBhcmVudEVsZW1lbnRcbiAgICAgICAgICogQHBhcmFtIHs/fSBuZ0NvbnRlbnRJbmRleFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQXBwVmlldy5wcm90b3R5cGUucHJvamVjdE5vZGVzID0gZnVuY3Rpb24gKHBhcmVudEVsZW1lbnQsIG5nQ29udGVudEluZGV4KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZGlyZWN0UmVuZGVyZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpc2l0UHJvamVjdGVkTm9kZXMobmdDb250ZW50SW5kZXgsIHRoaXMuX2RpcmVjdFJlbmRlcmVyLmFwcGVuZENoaWxkLCBwYXJlbnRFbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vZGVzID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy52aXNpdFByb2plY3RlZE5vZGVzKG5nQ29udGVudEluZGV4LCBhZGRUb0FycmF5LCBub2Rlcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5wcm9qZWN0Tm9kZXMocGFyZW50RWxlbWVudCwgbm9kZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBuZ0NvbnRlbnRJbmRleFxuICAgICAgICAgKiBAcGFyYW0gez99IGNiXG4gICAgICAgICAqIEBwYXJhbSB7P30gY1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQXBwVmlldy5wcm90b3R5cGUudmlzaXRQcm9qZWN0ZWROb2RlcyA9IGZ1bmN0aW9uIChuZ0NvbnRlbnRJbmRleCwgY2IsIGMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBWaWV3VHlwZS5FTUJFRERFRDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRWaWV3LnZpc2l0UHJvamVjdGVkTm9kZXMobmdDb250ZW50SW5kZXgsIGNiLCBjKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBWaWV3VHlwZS5DT01QT05FTlQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudFZpZXcudHlwZSA9PT0gVmlld1R5cGUuSE9TVCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9kZXMgPSB0aGlzLnBhcmVudFZpZXcuX2hvc3RQcm9qZWN0YWJsZU5vZGVzW25nQ29udGVudEluZGV4XSB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNiKG5vZGVzW2ldLCBjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50Vmlldy52aXNpdFByb2plY3RhYmxlTm9kZXNJbnRlcm5hbCh0aGlzLnBhcmVudEluZGV4LCBuZ0NvbnRlbnRJbmRleCwgY2IsIGMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogT3ZlcndyaXR0ZW4gYnkgaW1wbGVtZW50YXRpb25zXG4gICAgICAgICAqIEBwYXJhbSB7P30gY2JcbiAgICAgICAgICogQHBhcmFtIHs/fSBjXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBcHBWaWV3LnByb3RvdHlwZS52aXNpdFJvb3ROb2Rlc0ludGVybmFsID0gZnVuY3Rpb24gKGNiLCBjKSB7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPdmVyd3JpdHRlbiBieSBpbXBsZW1lbnRhdGlvbnNcbiAgICAgICAgICogQHBhcmFtIHs/fSBub2RlSW5kZXhcbiAgICAgICAgICogQHBhcmFtIHs/fSBuZ0NvbnRlbnRJbmRleFxuICAgICAgICAgKiBAcGFyYW0gez99IGNiXG4gICAgICAgICAqIEBwYXJhbSB7P30gY1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQXBwVmlldy5wcm90b3R5cGUudmlzaXRQcm9qZWN0YWJsZU5vZGVzSW50ZXJuYWwgPSBmdW5jdGlvbiAobm9kZUluZGV4LCBuZ0NvbnRlbnRJbmRleCwgY2IsIGMpIHsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE92ZXJ3cml0dGVuIGJ5IGltcGxlbWVudGF0aW9uc1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQXBwVmlldy5wcm90b3R5cGUuZGlydHlQYXJlbnRRdWVyaWVzSW50ZXJuYWwgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHRocm93T25DaGFuZ2VcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEFwcFZpZXcucHJvdG90eXBlLmludGVybmFsRGV0ZWN0Q2hhbmdlcyA9IGZ1bmN0aW9uICh0aHJvd09uQ2hhbmdlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jZE1vZGUgIT09IENoYW5nZURldGVjdG9yU3RhdHVzLkRldGFjaGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXRlY3RDaGFuZ2VzKHRocm93T25DaGFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB0aHJvd09uQ2hhbmdlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBcHBWaWV3LnByb3RvdHlwZS5kZXRlY3RDaGFuZ2VzID0gZnVuY3Rpb24gKHRocm93T25DaGFuZ2UpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHMgPSBfc2NvcGVfY2hlY2sodGhpcy5jbGF6eik7XG4gICAgICAgICAgICBpZiAodGhpcy5jZE1vZGUgPT09IENoYW5nZURldGVjdG9yU3RhdHVzLkNoZWNrZWQgfHxcbiAgICAgICAgICAgICAgICB0aGlzLmNkTW9kZSA9PT0gQ2hhbmdlRGV0ZWN0b3JTdGF0dXMuRXJyb3JlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAodGhpcy5jZE1vZGUgPT09IENoYW5nZURldGVjdG9yU3RhdHVzLkRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgIHRoaXMudGhyb3dEZXN0cm95ZWRFcnJvcignZGV0ZWN0Q2hhbmdlcycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kZXRlY3RDaGFuZ2VzSW50ZXJuYWwodGhyb3dPbkNoYW5nZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5jZE1vZGUgPT09IENoYW5nZURldGVjdG9yU3RhdHVzLkNoZWNrT25jZSlcbiAgICAgICAgICAgICAgICB0aGlzLmNkTW9kZSA9IENoYW5nZURldGVjdG9yU3RhdHVzLkNoZWNrZWQ7XG4gICAgICAgICAgICB0aGlzLm51bWJlck9mQ2hlY2tzKys7XG4gICAgICAgICAgICB3dGZMZWF2ZShzKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE92ZXJ3cml0dGVuIGJ5IGltcGxlbWVudGF0aW9uc1xuICAgICAgICAgKiBAcGFyYW0gez99IHRocm93T25DaGFuZ2VcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEFwcFZpZXcucHJvdG90eXBlLmRldGVjdENoYW5nZXNJbnRlcm5hbCA9IGZ1bmN0aW9uICh0aHJvd09uQ2hhbmdlKSB7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQXBwVmlldy5wcm90b3R5cGUubWFya0FzQ2hlY2tPbmNlID0gZnVuY3Rpb24gKCkgeyB0aGlzLmNkTW9kZSA9IENoYW5nZURldGVjdG9yU3RhdHVzLkNoZWNrT25jZTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBcHBWaWV3LnByb3RvdHlwZS5tYXJrUGF0aFRvUm9vdEFzQ2hlY2tPbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYyA9IHRoaXM7XG4gICAgICAgICAgICB3aGlsZSAoaXNQcmVzZW50KGMpICYmIGMuY2RNb2RlICE9PSBDaGFuZ2VEZXRlY3RvclN0YXR1cy5EZXRhY2hlZCkge1xuICAgICAgICAgICAgICAgIGlmIChjLmNkTW9kZSA9PT0gQ2hhbmdlRGV0ZWN0b3JTdGF0dXMuQ2hlY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICBjLmNkTW9kZSA9IENoYW5nZURldGVjdG9yU3RhdHVzLkNoZWNrT25jZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGMudHlwZSA9PT0gVmlld1R5cGUuQ09NUE9ORU5UKSB7XG4gICAgICAgICAgICAgICAgICAgIGMgPSBjLnBhcmVudFZpZXc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjID0gYy52aWV3Q29udGFpbmVyID8gYy52aWV3Q29udGFpbmVyLnBhcmVudFZpZXcgOiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gY2JcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEFwcFZpZXcucHJvdG90eXBlLmV2ZW50SGFuZGxlciA9IGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgcmV0dXJuIGNiO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBkZXRhaWxzXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBBcHBWaWV3LnByb3RvdHlwZS50aHJvd0Rlc3Ryb3llZEVycm9yID0gZnVuY3Rpb24gKGRldGFpbHMpIHsgdGhyb3cgbmV3IFZpZXdEZXN0cm95ZWRFcnJvcihkZXRhaWxzKTsgfTtcbiAgICAgICAgcmV0dXJuIEFwcFZpZXc7XG4gICAgfSgpKTtcbiAgICB2YXIgRGVidWdBcHBWaWV3ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDE0KERlYnVnQXBwVmlldywgX3N1cGVyKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gY2xhenpcbiAgICAgICAgICogQHBhcmFtIHs/fSBjb21wb25lbnRUeXBlXG4gICAgICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAgICAgKiBAcGFyYW0gez99IHZpZXdVdGlsc1xuICAgICAgICAgKiBAcGFyYW0gez99IHBhcmVudFZpZXdcbiAgICAgICAgICogQHBhcmFtIHs/fSBwYXJlbnRJbmRleFxuICAgICAgICAgKiBAcGFyYW0gez99IHBhcmVudE5vZGVcbiAgICAgICAgICogQHBhcmFtIHs/fSBjZE1vZGVcbiAgICAgICAgICogQHBhcmFtIHs/fSBzdGF0aWNOb2RlRGVidWdJbmZvc1xuICAgICAgICAgKiBAcGFyYW0gez89fSBkZWNsYXJlZFZpZXdDb250YWluZXJcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIERlYnVnQXBwVmlldyhjbGF6eiwgY29tcG9uZW50VHlwZSwgdHlwZSwgdmlld1V0aWxzLCBwYXJlbnRWaWV3LCBwYXJlbnRJbmRleCwgcGFyZW50Tm9kZSwgY2RNb2RlLCBzdGF0aWNOb2RlRGVidWdJbmZvcywgZGVjbGFyZWRWaWV3Q29udGFpbmVyKSB7XG4gICAgICAgICAgICBpZiAoZGVjbGFyZWRWaWV3Q29udGFpbmVyID09PSB2b2lkIDApIHsgZGVjbGFyZWRWaWV3Q29udGFpbmVyID0gbnVsbDsgfVxuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgY2xhenosIGNvbXBvbmVudFR5cGUsIHR5cGUsIHZpZXdVdGlscywgcGFyZW50VmlldywgcGFyZW50SW5kZXgsIHBhcmVudE5vZGUsIGNkTW9kZSwgZGVjbGFyZWRWaWV3Q29udGFpbmVyKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGljTm9kZURlYnVnSW5mb3MgPSBzdGF0aWNOb2RlRGVidWdJbmZvcztcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnREZWJ1Z0NvbnRleHQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIERlYnVnQXBwVmlldy5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0RGVidWcoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuY3JlYXRlLmNhbGwodGhpcywgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JldGhyb3dXaXRoQ29udGV4dChlKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSByb290U2VsZWN0b3JPck5vZGVcbiAgICAgICAgICogQHBhcmFtIHs/fSBpbmplY3RvclxuICAgICAgICAgKiBAcGFyYW0gez89fSBwcm9qZWN0YWJsZU5vZGVzXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBEZWJ1Z0FwcFZpZXcucHJvdG90eXBlLmNyZWF0ZUhvc3RWaWV3ID0gZnVuY3Rpb24gKHJvb3RTZWxlY3Rvck9yTm9kZSwgaW5qZWN0b3IsIHByb2plY3RhYmxlTm9kZXMpIHtcbiAgICAgICAgICAgIGlmIChwcm9qZWN0YWJsZU5vZGVzID09PSB2b2lkIDApIHsgcHJvamVjdGFibGVOb2RlcyA9IG51bGw7IH1cbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0RGVidWcoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuY3JlYXRlSG9zdFZpZXcuY2FsbCh0aGlzLCByb290U2VsZWN0b3JPck5vZGUsIGluamVjdG9yLCBwcm9qZWN0YWJsZU5vZGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmV0aHJvd1dpdGhDb250ZXh0KGUpO1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHRva2VuXG4gICAgICAgICAqIEBwYXJhbSB7P30gbm9kZUluZGV4XG4gICAgICAgICAqIEBwYXJhbSB7Pz19IG5vdEZvdW5kUmVzdWx0XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBEZWJ1Z0FwcFZpZXcucHJvdG90eXBlLmluamVjdG9yR2V0ID0gZnVuY3Rpb24gKHRva2VuLCBub2RlSW5kZXgsIG5vdEZvdW5kUmVzdWx0KSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNldERlYnVnKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmluamVjdG9yR2V0LmNhbGwodGhpcywgdG9rZW4sIG5vZGVJbmRleCwgbm90Rm91bmRSZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXRocm93V2l0aENvbnRleHQoZSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBEZWJ1Z0FwcFZpZXcucHJvdG90eXBlLmRldGFjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0RGVidWcoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kZXRhY2guY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmV0aHJvd1dpdGhDb250ZXh0KGUpO1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRGVidWdBcHBWaWV3LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fcmVzZXREZWJ1ZygpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmV0aHJvd1dpdGhDb250ZXh0KGUpO1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHRocm93T25DaGFuZ2VcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIERlYnVnQXBwVmlldy5wcm90b3R5cGUuZGV0ZWN0Q2hhbmdlcyA9IGZ1bmN0aW9uICh0aHJvd09uQ2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNldERlYnVnKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGV0ZWN0Q2hhbmdlcy5jYWxsKHRoaXMsIHRocm93T25DaGFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXRocm93V2l0aENvbnRleHQoZSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBEZWJ1Z0FwcFZpZXcucHJvdG90eXBlLl9yZXNldERlYnVnID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9jdXJyZW50RGVidWdDb250ZXh0ID0gbnVsbDsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gbm9kZUluZGV4XG4gICAgICAgICAqIEBwYXJhbSB7P30gcm93TnVtXG4gICAgICAgICAqIEBwYXJhbSB7P30gY29sTnVtXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBEZWJ1Z0FwcFZpZXcucHJvdG90eXBlLmRlYnVnID0gZnVuY3Rpb24gKG5vZGVJbmRleCwgcm93TnVtLCBjb2xOdW0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50RGVidWdDb250ZXh0ID0gbmV3IERlYnVnQ29udGV4dCh0aGlzLCBub2RlSW5kZXgsIHJvd051bSwgY29sTnVtKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRGVidWdBcHBWaWV3LnByb3RvdHlwZS5fcmV0aHJvd1dpdGhDb250ZXh0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmICghKGUgaW5zdGFuY2VvZiBWaWV3V3JhcHBlZEVycm9yKSkge1xuICAgICAgICAgICAgICAgIGlmICghKGUgaW5zdGFuY2VvZiBFeHByZXNzaW9uQ2hhbmdlZEFmdGVySXRIYXNCZWVuQ2hlY2tlZEVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNkTW9kZSA9IENoYW5nZURldGVjdG9yU3RhdHVzLkVycm9yZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5fY3VycmVudERlYnVnQ29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFZpZXdXcmFwcGVkRXJyb3IoZSwgdGhpcy5fY3VycmVudERlYnVnQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBjYlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgRGVidWdBcHBWaWV3LnByb3RvdHlwZS5ldmVudEhhbmRsZXIgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdXBlckhhbmRsZXIgPSBfc3VwZXIucHJvdG90eXBlLmV2ZW50SGFuZGxlci5jYWxsKHRoaXMsIGNiKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnROYW1lLCBldmVudCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9yZXNldERlYnVnKCk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1cGVySGFuZGxlci5jYWxsKF90aGlzLCBldmVudE5hbWUsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JldGhyb3dXaXRoQ29udGV4dChlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRGVidWdBcHBWaWV3O1xuICAgIH0oQXBwVmlldykpO1xuXG4gICAgLyoqXG4gICAgICogQSBWaWV3Q29udGFpbmVyIGlzIGNyZWF0ZWQgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIFZpZXdDb250YWluZXJSZWZcbiAgICAgKiB0byBrZWVwIHRyYWNrIG9mIHRoZSBuZXN0ZWQgdmlld3MuXG4gICAgICovXG4gICAgdmFyIFZpZXdDb250YWluZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBpbmRleFxuICAgICAgICAgKiBAcGFyYW0gez99IHBhcmVudEluZGV4XG4gICAgICAgICAqIEBwYXJhbSB7P30gcGFyZW50Vmlld1xuICAgICAgICAgKiBAcGFyYW0gez99IG5hdGl2ZUVsZW1lbnRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIFZpZXdDb250YWluZXIoaW5kZXgsIHBhcmVudEluZGV4LCBwYXJlbnRWaWV3LCBuYXRpdmVFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICB0aGlzLnBhcmVudEluZGV4ID0gcGFyZW50SW5kZXg7XG4gICAgICAgICAgICB0aGlzLnBhcmVudFZpZXcgPSBwYXJlbnRWaWV3O1xuICAgICAgICAgICAgdGhpcy5uYXRpdmVFbGVtZW50ID0gbmF0aXZlRWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVmlld0NvbnRhaW5lci5wcm90b3R5cGUsIFwiZWxlbWVudFJlZlwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEVsZW1lbnRSZWYodGhpcy5uYXRpdmVFbGVtZW50KTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaWV3Q29udGFpbmVyLnByb3RvdHlwZSwgXCJ2Y1JlZlwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IFZpZXdDb250YWluZXJSZWZfKHRoaXMpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdDb250YWluZXIucHJvdG90eXBlLCBcInBhcmVudEluamVjdG9yXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnBhcmVudFZpZXcuaW5qZWN0b3IodGhpcy5wYXJlbnRJbmRleCk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVmlld0NvbnRhaW5lci5wcm90b3R5cGUsIFwiaW5qZWN0b3JcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucGFyZW50Vmlldy5pbmplY3Rvcih0aGlzLmluZGV4KTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHRocm93T25DaGFuZ2VcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFZpZXdDb250YWluZXIucHJvdG90eXBlLmRldGVjdENoYW5nZXNJbk5lc3RlZFZpZXdzID0gZnVuY3Rpb24gKHRocm93T25DaGFuZ2UpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5lc3RlZFZpZXdzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IHRoaXMubmVzdGVkVmlld3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXN0ZWRWaWV3c1tpXS5kZXRlY3RDaGFuZ2VzKHRocm93T25DaGFuZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBWaWV3Q29udGFpbmVyLnByb3RvdHlwZS5kZXN0cm95TmVzdGVkVmlld3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5uZXN0ZWRWaWV3cykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCB0aGlzLm5lc3RlZFZpZXdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmVzdGVkVmlld3NbaV0uZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gY2JcbiAgICAgICAgICogQHBhcmFtIHs/fSBjXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBWaWV3Q29udGFpbmVyLnByb3RvdHlwZS52aXNpdE5lc3RlZFZpZXdSb290Tm9kZXMgPSBmdW5jdGlvbiAoY2IsIGMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5lc3RlZFZpZXdzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IHRoaXMubmVzdGVkVmlld3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXN0ZWRWaWV3c1tpXS52aXNpdFJvb3ROb2Rlc0ludGVybmFsKGNiLCBjKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IG5lc3RlZFZpZXdDbGFzc1xuICAgICAgICAgKiBAcGFyYW0gez99IGNhbGxiYWNrXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBWaWV3Q29udGFpbmVyLnByb3RvdHlwZS5tYXBOZXN0ZWRWaWV3cyA9IGZ1bmN0aW9uIChuZXN0ZWRWaWV3Q2xhc3MsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGlmICh0aGlzLm5lc3RlZFZpZXdzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IHRoaXMubmVzdGVkVmlld3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmVzdGVkVmlldyA9IHRoaXMubmVzdGVkVmlld3NbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXN0ZWRWaWV3LmNsYXp6ID09PSBuZXN0ZWRWaWV3Q2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNhbGxiYWNrKG5lc3RlZFZpZXcpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnByb2plY3RlZFZpZXdzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IHRoaXMucHJvamVjdGVkVmlld3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvamVjdGVkVmlldyA9IHRoaXMucHJvamVjdGVkVmlld3NbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9qZWN0ZWRWaWV3LmNsYXp6ID09PSBuZXN0ZWRWaWV3Q2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNhbGxiYWNrKHByb2plY3RlZFZpZXcpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZpZXdcbiAgICAgICAgICogQHBhcmFtIHs/fSBjdXJyZW50SW5kZXhcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFZpZXdDb250YWluZXIucHJvdG90eXBlLm1vdmVWaWV3ID0gZnVuY3Rpb24gKHZpZXcsIGN1cnJlbnRJbmRleCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJldmlvdXNJbmRleCA9IHRoaXMubmVzdGVkVmlld3MuaW5kZXhPZih2aWV3KTtcbiAgICAgICAgICAgIGlmICh2aWV3LnR5cGUgPT09IFZpZXdUeXBlLkNPTVBPTkVOVCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbXBvbmVudCB2aWV3cyBjYW4ndCBiZSBtb3ZlZCFcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZXN0ZWRWaWV3cyA9IHRoaXMubmVzdGVkVmlld3M7XG4gICAgICAgICAgICBpZiAobmVzdGVkVmlld3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG5lc3RlZFZpZXdzID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5uZXN0ZWRWaWV3cyA9IG5lc3RlZFZpZXdzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmVzdGVkVmlld3Muc3BsaWNlKHByZXZpb3VzSW5kZXgsIDEpO1xuICAgICAgICAgICAgbmVzdGVkVmlld3Muc3BsaWNlKGN1cnJlbnRJbmRleCwgMCwgdmlldyk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcmV2VmlldyA9IGN1cnJlbnRJbmRleCA+IDAgPyBuZXN0ZWRWaWV3c1tjdXJyZW50SW5kZXggLSAxXSA6IG51bGw7XG4gICAgICAgICAgICB2aWV3Lm1vdmVBZnRlcih0aGlzLCBwcmV2Vmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZpZXdcbiAgICAgICAgICogQHBhcmFtIHs/fSB2aWV3SW5kZXhcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFZpZXdDb250YWluZXIucHJvdG90eXBlLmF0dGFjaFZpZXcgPSBmdW5jdGlvbiAodmlldywgdmlld0luZGV4KSB7XG4gICAgICAgICAgICBpZiAodmlldy50eXBlID09PSBWaWV3VHlwZS5DT01QT05FTlQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb21wb25lbnQgdmlld3MgY2FuJ3QgYmUgbW92ZWQhXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmVzdGVkVmlld3MgPSB0aGlzLm5lc3RlZFZpZXdzO1xuICAgICAgICAgICAgaWYgKG5lc3RlZFZpZXdzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBuZXN0ZWRWaWV3cyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMubmVzdGVkVmlld3MgPSBuZXN0ZWRWaWV3cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHBlcmY6IGFycmF5LnB1c2ggaXMgZmFzdGVyIHRoYW4gYXJyYXkuc3BsaWNlIVxuICAgICAgICAgICAgaWYgKHZpZXdJbmRleCA+PSBuZXN0ZWRWaWV3cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBuZXN0ZWRWaWV3cy5wdXNoKHZpZXcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmVzdGVkVmlld3Muc3BsaWNlKHZpZXdJbmRleCwgMCwgdmlldyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcmV2VmlldyA9IHZpZXdJbmRleCA+IDAgPyBuZXN0ZWRWaWV3c1t2aWV3SW5kZXggLSAxXSA6IG51bGw7XG4gICAgICAgICAgICB2aWV3LmF0dGFjaEFmdGVyKHRoaXMsIHByZXZWaWV3KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmlld0luZGV4XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBWaWV3Q29udGFpbmVyLnByb3RvdHlwZS5kZXRhY2hWaWV3ID0gZnVuY3Rpb24gKHZpZXdJbmRleCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlldyA9IHRoaXMubmVzdGVkVmlld3Nbdmlld0luZGV4XTtcbiAgICAgICAgICAgIC8vIHBlcmY6IGFycmF5LnBvcCBpcyBmYXN0ZXIgdGhhbiBhcnJheS5zcGxpY2UhXG4gICAgICAgICAgICBpZiAodmlld0luZGV4ID49IHRoaXMubmVzdGVkVmlld3MubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMubmVzdGVkVmlld3MucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5lc3RlZFZpZXdzLnNwbGljZSh2aWV3SW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZpZXcudHlwZSA9PT0gVmlld1R5cGUuQ09NUE9ORU5UKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29tcG9uZW50IHZpZXdzIGNhbid0IGJlIG1vdmVkIVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZpZXcuZGV0YWNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdmlldztcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFZpZXdDb250YWluZXI7XG4gICAgfSgpKTtcblxuICAgIHZhciAvKiogQHR5cGUgez99ICovIF9fY29yZV9wcml2YXRlX18gPSB7XG4gICAgICAgIGlzRGVmYXVsdENoYW5nZURldGVjdGlvblN0cmF0ZWd5OiBpc0RlZmF1bHRDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgICAgICAgQ2hhbmdlRGV0ZWN0b3JTdGF0dXM6IENoYW5nZURldGVjdG9yU3RhdHVzLFxuICAgICAgICBjb25zdHJ1Y3REZXBlbmRlbmNpZXM6IGNvbnN0cnVjdERlcGVuZGVuY2llcyxcbiAgICAgICAgTGlmZWN5Y2xlSG9va3M6IExpZmVjeWNsZUhvb2tzLFxuICAgICAgICBMSUZFQ1lDTEVfSE9PS1NfVkFMVUVTOiBMSUZFQ1lDTEVfSE9PS1NfVkFMVUVTLFxuICAgICAgICBSZWZsZWN0b3JSZWFkZXI6IFJlZmxlY3RvclJlYWRlcixcbiAgICAgICAgQ29kZWdlbkNvbXBvbmVudEZhY3RvcnlSZXNvbHZlcjogQ29kZWdlbkNvbXBvbmVudEZhY3RvcnlSZXNvbHZlcixcbiAgICAgICAgQ29tcG9uZW50UmVmXzogQ29tcG9uZW50UmVmXyxcbiAgICAgICAgVmlld0NvbnRhaW5lcjogVmlld0NvbnRhaW5lcixcbiAgICAgICAgQXBwVmlldzogQXBwVmlldyxcbiAgICAgICAgRGVidWdBcHBWaWV3OiBEZWJ1Z0FwcFZpZXcsXG4gICAgICAgIE5nTW9kdWxlSW5qZWN0b3I6IE5nTW9kdWxlSW5qZWN0b3IsXG4gICAgICAgIHJlZ2lzdGVyTW9kdWxlRmFjdG9yeTogcmVnaXN0ZXJNb2R1bGVGYWN0b3J5LFxuICAgICAgICBWaWV3VHlwZTogVmlld1R5cGUsXG4gICAgICAgIHZpZXdfdXRpbHM6IHZpZXdfdXRpbHMsXG4gICAgICAgIFZpZXdNZXRhZGF0YTogVmlld01ldGFkYXRhLFxuICAgICAgICBEZWJ1Z0NvbnRleHQ6IERlYnVnQ29udGV4dCxcbiAgICAgICAgU3RhdGljTm9kZURlYnVnSW5mbzogU3RhdGljTm9kZURlYnVnSW5mbyxcbiAgICAgICAgZGV2TW9kZUVxdWFsOiBkZXZNb2RlRXF1YWwsXG4gICAgICAgIFVOSU5JVElBTElaRUQ6IFVOSU5JVElBTElaRUQsXG4gICAgICAgIFZhbHVlVW53cmFwcGVyOiBWYWx1ZVVud3JhcHBlcixcbiAgICAgICAgUmVuZGVyRGVidWdJbmZvOiBSZW5kZXJEZWJ1Z0luZm8sXG4gICAgICAgIFRlbXBsYXRlUmVmXzogVGVtcGxhdGVSZWZfLFxuICAgICAgICBSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzOiBSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLFxuICAgICAgICBtYWtlRGVjb3JhdG9yOiBtYWtlRGVjb3JhdG9yLFxuICAgICAgICBEZWJ1Z0RvbVJvb3RSZW5kZXJlcjogRGVidWdEb21Sb290UmVuZGVyZXIsXG4gICAgICAgIENvbnNvbGU6IENvbnNvbGUsXG4gICAgICAgIHJlZmxlY3RvcjogcmVmbGVjdG9yLFxuICAgICAgICBSZWZsZWN0b3I6IFJlZmxlY3RvcixcbiAgICAgICAgTm9PcEFuaW1hdGlvblBsYXllcjogTm9PcEFuaW1hdGlvblBsYXllcixcbiAgICAgICAgQW5pbWF0aW9uUGxheWVyOiBBbmltYXRpb25QbGF5ZXIsXG4gICAgICAgIEFuaW1hdGlvblNlcXVlbmNlUGxheWVyOiBBbmltYXRpb25TZXF1ZW5jZVBsYXllcixcbiAgICAgICAgQW5pbWF0aW9uR3JvdXBQbGF5ZXI6IEFuaW1hdGlvbkdyb3VwUGxheWVyLFxuICAgICAgICBBbmltYXRpb25LZXlmcmFtZTogQW5pbWF0aW9uS2V5ZnJhbWUsXG4gICAgICAgIHByZXBhcmVGaW5hbEFuaW1hdGlvblN0eWxlczogcHJlcGFyZUZpbmFsQW5pbWF0aW9uU3R5bGVzLFxuICAgICAgICBiYWxhbmNlQW5pbWF0aW9uS2V5ZnJhbWVzOiBiYWxhbmNlQW5pbWF0aW9uS2V5ZnJhbWVzLFxuICAgICAgICBmbGF0dGVuU3R5bGVzOiBmbGF0dGVuU3R5bGVzLFxuICAgICAgICBjbGVhclN0eWxlczogY2xlYXJTdHlsZXMsXG4gICAgICAgIHJlbmRlclN0eWxlczogcmVuZGVyU3R5bGVzLFxuICAgICAgICBjb2xsZWN0QW5kUmVzb2x2ZVN0eWxlczogY29sbGVjdEFuZFJlc29sdmVTdHlsZXMsXG4gICAgICAgIEFQUF9JRF9SQU5ET01fUFJPVklERVI6IEFQUF9JRF9SQU5ET01fUFJPVklERVIsXG4gICAgICAgIEFuaW1hdGlvblN0eWxlczogQW5pbWF0aW9uU3R5bGVzLFxuICAgICAgICBBTllfU1RBVEU6IEFOWV9TVEFURSxcbiAgICAgICAgREVGQVVMVF9TVEFURTogREVGQVVMVF9TVEFURSxcbiAgICAgICAgRU1QVFlfU1RBVEU6IEVNUFRZX1NUQVRFLFxuICAgICAgICBGSUxMX1NUWUxFX0ZMQUc6IEZJTExfU1RZTEVfRkxBRyxcbiAgICAgICAgQ29tcG9uZW50U3RpbGxMb2FkaW5nRXJyb3I6IENvbXBvbmVudFN0aWxsTG9hZGluZ0Vycm9yLFxuICAgICAgICBpc1Byb21pc2U6IGlzUHJvbWlzZSxcbiAgICAgICAgQW5pbWF0aW9uVHJhbnNpdGlvbjogQW5pbWF0aW9uVHJhbnNpdGlvblxuICAgIH07XG5cbiAgICBleHBvcnRzLmNyZWF0ZVBsYXRmb3JtID0gY3JlYXRlUGxhdGZvcm07XG4gICAgZXhwb3J0cy5hc3NlcnRQbGF0Zm9ybSA9IGFzc2VydFBsYXRmb3JtO1xuICAgIGV4cG9ydHMuZGVzdHJveVBsYXRmb3JtID0gZGVzdHJveVBsYXRmb3JtO1xuICAgIGV4cG9ydHMuZ2V0UGxhdGZvcm0gPSBnZXRQbGF0Zm9ybTtcbiAgICBleHBvcnRzLlBsYXRmb3JtUmVmID0gUGxhdGZvcm1SZWY7XG4gICAgZXhwb3J0cy5BcHBsaWNhdGlvblJlZiA9IEFwcGxpY2F0aW9uUmVmO1xuICAgIGV4cG9ydHMuZW5hYmxlUHJvZE1vZGUgPSBlbmFibGVQcm9kTW9kZTtcbiAgICBleHBvcnRzLmlzRGV2TW9kZSA9IGlzRGV2TW9kZTtcbiAgICBleHBvcnRzLmNyZWF0ZVBsYXRmb3JtRmFjdG9yeSA9IGNyZWF0ZVBsYXRmb3JtRmFjdG9yeTtcbiAgICBleHBvcnRzLk5nUHJvYmVUb2tlbiA9IE5nUHJvYmVUb2tlbjtcbiAgICBleHBvcnRzLkFQUF9JRCA9IEFQUF9JRDtcbiAgICBleHBvcnRzLlBBQ0tBR0VfUk9PVF9VUkwgPSBQQUNLQUdFX1JPT1RfVVJMO1xuICAgIGV4cG9ydHMuUExBVEZPUk1fSU5JVElBTElaRVIgPSBQTEFURk9STV9JTklUSUFMSVpFUjtcbiAgICBleHBvcnRzLkFQUF9CT09UU1RSQVBfTElTVEVORVIgPSBBUFBfQk9PVFNUUkFQX0xJU1RFTkVSO1xuICAgIGV4cG9ydHMuQVBQX0lOSVRJQUxJWkVSID0gQVBQX0lOSVRJQUxJWkVSO1xuICAgIGV4cG9ydHMuQXBwbGljYXRpb25Jbml0U3RhdHVzID0gQXBwbGljYXRpb25Jbml0U3RhdHVzO1xuICAgIGV4cG9ydHMuRGVidWdFbGVtZW50ID0gRGVidWdFbGVtZW50O1xuICAgIGV4cG9ydHMuRGVidWdOb2RlID0gRGVidWdOb2RlO1xuICAgIGV4cG9ydHMuYXNOYXRpdmVFbGVtZW50cyA9IGFzTmF0aXZlRWxlbWVudHM7XG4gICAgZXhwb3J0cy5nZXREZWJ1Z05vZGUgPSBnZXREZWJ1Z05vZGU7XG4gICAgZXhwb3J0cy5UZXN0YWJpbGl0eSA9IFRlc3RhYmlsaXR5O1xuICAgIGV4cG9ydHMuVGVzdGFiaWxpdHlSZWdpc3RyeSA9IFRlc3RhYmlsaXR5UmVnaXN0cnk7XG4gICAgZXhwb3J0cy5zZXRUZXN0YWJpbGl0eUdldHRlciA9IHNldFRlc3RhYmlsaXR5R2V0dGVyO1xuICAgIGV4cG9ydHMuVFJBTlNMQVRJT05TID0gVFJBTlNMQVRJT05TO1xuICAgIGV4cG9ydHMuVFJBTlNMQVRJT05TX0ZPUk1BVCA9IFRSQU5TTEFUSU9OU19GT1JNQVQ7XG4gICAgZXhwb3J0cy5MT0NBTEVfSUQgPSBMT0NBTEVfSUQ7XG4gICAgZXhwb3J0cy5BcHBsaWNhdGlvbk1vZHVsZSA9IEFwcGxpY2F0aW9uTW9kdWxlO1xuICAgIGV4cG9ydHMud3RmQ3JlYXRlU2NvcGUgPSB3dGZDcmVhdGVTY29wZTtcbiAgICBleHBvcnRzLnd0ZkxlYXZlID0gd3RmTGVhdmU7XG4gICAgZXhwb3J0cy53dGZTdGFydFRpbWVSYW5nZSA9IHd0ZlN0YXJ0VGltZVJhbmdlO1xuICAgIGV4cG9ydHMud3RmRW5kVGltZVJhbmdlID0gd3RmRW5kVGltZVJhbmdlO1xuICAgIGV4cG9ydHMuVHlwZSA9IFR5cGU7XG4gICAgZXhwb3J0cy5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG4gICAgZXhwb3J0cy5FcnJvckhhbmRsZXIgPSBFcnJvckhhbmRsZXI7XG4gICAgZXhwb3J0cy5BbmltYXRpb25UcmFuc2l0aW9uRXZlbnQgPSBBbmltYXRpb25UcmFuc2l0aW9uRXZlbnQ7XG4gICAgZXhwb3J0cy5BbmltYXRpb25QbGF5ZXIgPSBBbmltYXRpb25QbGF5ZXI7XG4gICAgZXhwb3J0cy5BbmltYXRpb25TdHlsZXMgPSBBbmltYXRpb25TdHlsZXM7XG4gICAgZXhwb3J0cy5BbmltYXRpb25LZXlmcmFtZSA9IEFuaW1hdGlvbktleWZyYW1lO1xuICAgIGV4cG9ydHMuU2FuaXRpemVyID0gU2FuaXRpemVyO1xuICAgIGV4cG9ydHMuU2VjdXJpdHlDb250ZXh0ID0gU2VjdXJpdHlDb250ZXh0O1xuICAgIGV4cG9ydHMuQU5BTFlaRV9GT1JfRU5UUllfQ09NUE9ORU5UUyA9IEFOQUxZWkVfRk9SX0VOVFJZX0NPTVBPTkVOVFM7XG4gICAgZXhwb3J0cy5BdHRyaWJ1dGUgPSBBdHRyaWJ1dGU7XG4gICAgZXhwb3J0cy5Db250ZW50Q2hpbGQgPSBDb250ZW50Q2hpbGQ7XG4gICAgZXhwb3J0cy5Db250ZW50Q2hpbGRyZW4gPSBDb250ZW50Q2hpbGRyZW47XG4gICAgZXhwb3J0cy5RdWVyeSA9IFF1ZXJ5O1xuICAgIGV4cG9ydHMuVmlld0NoaWxkID0gVmlld0NoaWxkO1xuICAgIGV4cG9ydHMuVmlld0NoaWxkcmVuID0gVmlld0NoaWxkcmVuO1xuICAgIGV4cG9ydHMuQ29tcG9uZW50ID0gQ29tcG9uZW50O1xuICAgIGV4cG9ydHMuRGlyZWN0aXZlID0gRGlyZWN0aXZlO1xuICAgIGV4cG9ydHMuSG9zdEJpbmRpbmcgPSBIb3N0QmluZGluZztcbiAgICBleHBvcnRzLkhvc3RMaXN0ZW5lciA9IEhvc3RMaXN0ZW5lcjtcbiAgICBleHBvcnRzLklucHV0ID0gSW5wdXQ7XG4gICAgZXhwb3J0cy5PdXRwdXQgPSBPdXRwdXQ7XG4gICAgZXhwb3J0cy5QaXBlID0gUGlwZTtcbiAgICBleHBvcnRzLkFmdGVyQ29udGVudENoZWNrZWQgPSBBZnRlckNvbnRlbnRDaGVja2VkO1xuICAgIGV4cG9ydHMuQWZ0ZXJDb250ZW50SW5pdCA9IEFmdGVyQ29udGVudEluaXQ7XG4gICAgZXhwb3J0cy5BZnRlclZpZXdDaGVja2VkID0gQWZ0ZXJWaWV3Q2hlY2tlZDtcbiAgICBleHBvcnRzLkFmdGVyVmlld0luaXQgPSBBZnRlclZpZXdJbml0O1xuICAgIGV4cG9ydHMuRG9DaGVjayA9IERvQ2hlY2s7XG4gICAgZXhwb3J0cy5PbkNoYW5nZXMgPSBPbkNoYW5nZXM7XG4gICAgZXhwb3J0cy5PbkRlc3Ryb3kgPSBPbkRlc3Ryb3k7XG4gICAgZXhwb3J0cy5PbkluaXQgPSBPbkluaXQ7XG4gICAgZXhwb3J0cy5DVVNUT01fRUxFTUVOVFNfU0NIRU1BID0gQ1VTVE9NX0VMRU1FTlRTX1NDSEVNQTtcbiAgICBleHBvcnRzLk5PX0VSUk9SU19TQ0hFTUEgPSBOT19FUlJPUlNfU0NIRU1BO1xuICAgIGV4cG9ydHMuTmdNb2R1bGUgPSBOZ01vZHVsZTtcbiAgICBleHBvcnRzLlZpZXdFbmNhcHN1bGF0aW9uID0gVmlld0VuY2Fwc3VsYXRpb247XG4gICAgZXhwb3J0cy5WZXJzaW9uID0gVmVyc2lvbjtcbiAgICBleHBvcnRzLlZFUlNJT04gPSBWRVJTSU9OO1xuICAgIGV4cG9ydHMuQ2xhc3MgPSBDbGFzcztcbiAgICBleHBvcnRzLmZvcndhcmRSZWYgPSBmb3J3YXJkUmVmO1xuICAgIGV4cG9ydHMucmVzb2x2ZUZvcndhcmRSZWYgPSByZXNvbHZlRm9yd2FyZFJlZjtcbiAgICBleHBvcnRzLkluamVjdG9yID0gSW5qZWN0b3I7XG4gICAgZXhwb3J0cy5SZWZsZWN0aXZlSW5qZWN0b3IgPSBSZWZsZWN0aXZlSW5qZWN0b3I7XG4gICAgZXhwb3J0cy5SZXNvbHZlZFJlZmxlY3RpdmVGYWN0b3J5ID0gUmVzb2x2ZWRSZWZsZWN0aXZlRmFjdG9yeTtcbiAgICBleHBvcnRzLlJlZmxlY3RpdmVLZXkgPSBSZWZsZWN0aXZlS2V5O1xuICAgIGV4cG9ydHMuT3BhcXVlVG9rZW4gPSBPcGFxdWVUb2tlbjtcbiAgICBleHBvcnRzLkluamVjdCA9IEluamVjdDtcbiAgICBleHBvcnRzLk9wdGlvbmFsID0gT3B0aW9uYWw7XG4gICAgZXhwb3J0cy5JbmplY3RhYmxlID0gSW5qZWN0YWJsZTtcbiAgICBleHBvcnRzLlNlbGYgPSBTZWxmO1xuICAgIGV4cG9ydHMuU2tpcFNlbGYgPSBTa2lwU2VsZjtcbiAgICBleHBvcnRzLkhvc3QgPSBIb3N0O1xuICAgIGV4cG9ydHMuTmdab25lID0gTmdab25lO1xuICAgIGV4cG9ydHMuUmVuZGVyQ29tcG9uZW50VHlwZSA9IFJlbmRlckNvbXBvbmVudFR5cGU7XG4gICAgZXhwb3J0cy5SZW5kZXJlciA9IFJlbmRlcmVyO1xuICAgIGV4cG9ydHMuUm9vdFJlbmRlcmVyID0gUm9vdFJlbmRlcmVyO1xuICAgIGV4cG9ydHMuQ09NUElMRVJfT1BUSU9OUyA9IENPTVBJTEVSX09QVElPTlM7XG4gICAgZXhwb3J0cy5Db21waWxlciA9IENvbXBpbGVyO1xuICAgIGV4cG9ydHMuQ29tcGlsZXJGYWN0b3J5ID0gQ29tcGlsZXJGYWN0b3J5O1xuICAgIGV4cG9ydHMuTW9kdWxlV2l0aENvbXBvbmVudEZhY3RvcmllcyA9IE1vZHVsZVdpdGhDb21wb25lbnRGYWN0b3JpZXM7XG4gICAgZXhwb3J0cy5Db21wb25lbnRGYWN0b3J5ID0gQ29tcG9uZW50RmFjdG9yeTtcbiAgICBleHBvcnRzLkNvbXBvbmVudFJlZiA9IENvbXBvbmVudFJlZjtcbiAgICBleHBvcnRzLkNvbXBvbmVudEZhY3RvcnlSZXNvbHZlciA9IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcjtcbiAgICBleHBvcnRzLkVsZW1lbnRSZWYgPSBFbGVtZW50UmVmO1xuICAgIGV4cG9ydHMuTmdNb2R1bGVGYWN0b3J5ID0gTmdNb2R1bGVGYWN0b3J5O1xuICAgIGV4cG9ydHMuTmdNb2R1bGVSZWYgPSBOZ01vZHVsZVJlZjtcbiAgICBleHBvcnRzLk5nTW9kdWxlRmFjdG9yeUxvYWRlciA9IE5nTW9kdWxlRmFjdG9yeUxvYWRlcjtcbiAgICBleHBvcnRzLmdldE1vZHVsZUZhY3RvcnkgPSBnZXRNb2R1bGVGYWN0b3J5O1xuICAgIGV4cG9ydHMuUXVlcnlMaXN0ID0gUXVlcnlMaXN0O1xuICAgIGV4cG9ydHMuU3lzdGVtSnNOZ01vZHVsZUxvYWRlciA9IFN5c3RlbUpzTmdNb2R1bGVMb2FkZXI7XG4gICAgZXhwb3J0cy5TeXN0ZW1Kc05nTW9kdWxlTG9hZGVyQ29uZmlnID0gU3lzdGVtSnNOZ01vZHVsZUxvYWRlckNvbmZpZztcbiAgICBleHBvcnRzLlRlbXBsYXRlUmVmID0gVGVtcGxhdGVSZWY7XG4gICAgZXhwb3J0cy5WaWV3Q29udGFpbmVyUmVmID0gVmlld0NvbnRhaW5lclJlZjtcbiAgICBleHBvcnRzLkVtYmVkZGVkVmlld1JlZiA9IEVtYmVkZGVkVmlld1JlZjtcbiAgICBleHBvcnRzLlZpZXdSZWYgPSBWaWV3UmVmO1xuICAgIGV4cG9ydHMuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgPSBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneTtcbiAgICBleHBvcnRzLkNoYW5nZURldGVjdG9yUmVmID0gQ2hhbmdlRGV0ZWN0b3JSZWY7XG4gICAgZXhwb3J0cy5Db2xsZWN0aW9uQ2hhbmdlUmVjb3JkID0gQ29sbGVjdGlvbkNoYW5nZVJlY29yZDtcbiAgICBleHBvcnRzLkRlZmF1bHRJdGVyYWJsZURpZmZlciA9IERlZmF1bHRJdGVyYWJsZURpZmZlcjtcbiAgICBleHBvcnRzLkl0ZXJhYmxlRGlmZmVycyA9IEl0ZXJhYmxlRGlmZmVycztcbiAgICBleHBvcnRzLktleVZhbHVlQ2hhbmdlUmVjb3JkID0gS2V5VmFsdWVDaGFuZ2VSZWNvcmQ7XG4gICAgZXhwb3J0cy5LZXlWYWx1ZURpZmZlcnMgPSBLZXlWYWx1ZURpZmZlcnM7XG4gICAgZXhwb3J0cy5TaW1wbGVDaGFuZ2UgPSBTaW1wbGVDaGFuZ2U7XG4gICAgZXhwb3J0cy5XcmFwcGVkVmFsdWUgPSBXcmFwcGVkVmFsdWU7XG4gICAgZXhwb3J0cy5wbGF0Zm9ybUNvcmUgPSBwbGF0Zm9ybUNvcmU7XG4gICAgZXhwb3J0cy5fX2NvcmVfcHJpdmF0ZV9fID0gX19jb3JlX3ByaXZhdGVfXztcbiAgICBleHBvcnRzLkFVVE9fU1RZTEUgPSBBVVRPX1NUWUxFO1xuICAgIGV4cG9ydHMuQW5pbWF0aW9uRW50cnlNZXRhZGF0YSA9IEFuaW1hdGlvbkVudHJ5TWV0YWRhdGE7XG4gICAgZXhwb3J0cy5BbmltYXRpb25TdGF0ZU1ldGFkYXRhID0gQW5pbWF0aW9uU3RhdGVNZXRhZGF0YTtcbiAgICBleHBvcnRzLkFuaW1hdGlvblN0YXRlRGVjbGFyYXRpb25NZXRhZGF0YSA9IEFuaW1hdGlvblN0YXRlRGVjbGFyYXRpb25NZXRhZGF0YTtcbiAgICBleHBvcnRzLkFuaW1hdGlvblN0YXRlVHJhbnNpdGlvbk1ldGFkYXRhID0gQW5pbWF0aW9uU3RhdGVUcmFuc2l0aW9uTWV0YWRhdGE7XG4gICAgZXhwb3J0cy5BbmltYXRpb25NZXRhZGF0YSA9IEFuaW1hdGlvbk1ldGFkYXRhO1xuICAgIGV4cG9ydHMuQW5pbWF0aW9uS2V5ZnJhbWVzU2VxdWVuY2VNZXRhZGF0YSA9IEFuaW1hdGlvbktleWZyYW1lc1NlcXVlbmNlTWV0YWRhdGE7XG4gICAgZXhwb3J0cy5BbmltYXRpb25TdHlsZU1ldGFkYXRhID0gQW5pbWF0aW9uU3R5bGVNZXRhZGF0YTtcbiAgICBleHBvcnRzLkFuaW1hdGlvbkFuaW1hdGVNZXRhZGF0YSA9IEFuaW1hdGlvbkFuaW1hdGVNZXRhZGF0YTtcbiAgICBleHBvcnRzLkFuaW1hdGlvbldpdGhTdGVwc01ldGFkYXRhID0gQW5pbWF0aW9uV2l0aFN0ZXBzTWV0YWRhdGE7XG4gICAgZXhwb3J0cy5BbmltYXRpb25TZXF1ZW5jZU1ldGFkYXRhID0gQW5pbWF0aW9uU2VxdWVuY2VNZXRhZGF0YTtcbiAgICBleHBvcnRzLkFuaW1hdGlvbkdyb3VwTWV0YWRhdGEgPSBBbmltYXRpb25Hcm91cE1ldGFkYXRhO1xuICAgIGV4cG9ydHMuYW5pbWF0ZSA9IGFuaW1hdGU7XG4gICAgZXhwb3J0cy5ncm91cCA9IGdyb3VwO1xuICAgIGV4cG9ydHMuc2VxdWVuY2UgPSBzZXF1ZW5jZTtcbiAgICBleHBvcnRzLnN0eWxlID0gc3R5bGU7XG4gICAgZXhwb3J0cy5zdGF0ZSA9IHN0YXRlO1xuICAgIGV4cG9ydHMua2V5ZnJhbWVzID0ga2V5ZnJhbWVzO1xuICAgIGV4cG9ydHMudHJhbnNpdGlvbiA9IHRyYW5zaXRpb247XG4gICAgZXhwb3J0cy50cmlnZ2VyID0gdHJpZ2dlcjtcblxufSkpOyIsIlwidXNlIHN0cmljdFwiO1xudmFyIHJvb3RfMSA9IHJlcXVpcmUoJy4vdXRpbC9yb290Jyk7XG52YXIgdG9TdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuL3V0aWwvdG9TdWJzY3JpYmVyJyk7XG52YXIgb2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9zeW1ib2wvb2JzZXJ2YWJsZScpO1xuLyoqXG4gKiBBIHJlcHJlc2VudGF0aW9uIG9mIGFueSBzZXQgb2YgdmFsdWVzIG92ZXIgYW55IGFtb3VudCBvZiB0aW1lLiBUaGlzIHRoZSBtb3N0IGJhc2ljIGJ1aWxkaW5nIGJsb2NrXG4gKiBvZiBSeEpTLlxuICpcbiAqIEBjbGFzcyBPYnNlcnZhYmxlPFQ+XG4gKi9cbnZhciBPYnNlcnZhYmxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdWJzY3JpYmUgdGhlIGZ1bmN0aW9uIHRoYXQgaXMgIGNhbGxlZCB3aGVuIHRoZSBPYnNlcnZhYmxlIGlzXG4gICAgICogaW5pdGlhbGx5IHN1YnNjcmliZWQgdG8uIFRoaXMgZnVuY3Rpb24gaXMgZ2l2ZW4gYSBTdWJzY3JpYmVyLCB0byB3aGljaCBuZXcgdmFsdWVzXG4gICAgICogY2FuIGJlIGBuZXh0YGVkLCBvciBhbiBgZXJyb3JgIG1ldGhvZCBjYW4gYmUgY2FsbGVkIHRvIHJhaXNlIGFuIGVycm9yLCBvclxuICAgICAqIGBjb21wbGV0ZWAgY2FuIGJlIGNhbGxlZCB0byBub3RpZnkgb2YgYSBzdWNjZXNzZnVsIGNvbXBsZXRpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gT2JzZXJ2YWJsZShzdWJzY3JpYmUpIHtcbiAgICAgICAgdGhpcy5faXNTY2FsYXIgPSBmYWxzZTtcbiAgICAgICAgaWYgKHN1YnNjcmliZSkge1xuICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlID0gc3Vic2NyaWJlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgT2JzZXJ2YWJsZSwgd2l0aCB0aGlzIE9ic2VydmFibGUgYXMgdGhlIHNvdXJjZSwgYW5kIHRoZSBwYXNzZWRcbiAgICAgKiBvcGVyYXRvciBkZWZpbmVkIGFzIHRoZSBuZXcgb2JzZXJ2YWJsZSdzIG9wZXJhdG9yLlxuICAgICAqIEBtZXRob2QgbGlmdFxuICAgICAqIEBwYXJhbSB7T3BlcmF0b3J9IG9wZXJhdG9yIHRoZSBvcGVyYXRvciBkZWZpbmluZyB0aGUgb3BlcmF0aW9uIHRvIHRha2Ugb24gdGhlIG9ic2VydmFibGVcbiAgICAgKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBhIG5ldyBvYnNlcnZhYmxlIHdpdGggdGhlIE9wZXJhdG9yIGFwcGxpZWRcbiAgICAgKi9cbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5saWZ0ID0gZnVuY3Rpb24gKG9wZXJhdG9yKSB7XG4gICAgICAgIHZhciBvYnNlcnZhYmxlID0gbmV3IE9ic2VydmFibGUoKTtcbiAgICAgICAgb2JzZXJ2YWJsZS5zb3VyY2UgPSB0aGlzO1xuICAgICAgICBvYnNlcnZhYmxlLm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKG9ic2VydmVyT3JOZXh0LCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgdmFyIG9wZXJhdG9yID0gdGhpcy5vcGVyYXRvcjtcbiAgICAgICAgdmFyIHNpbmsgPSB0b1N1YnNjcmliZXJfMS50b1N1YnNjcmliZXIob2JzZXJ2ZXJPck5leHQsIGVycm9yLCBjb21wbGV0ZSk7XG4gICAgICAgIGlmIChvcGVyYXRvcikge1xuICAgICAgICAgICAgb3BlcmF0b3IuY2FsbChzaW5rLCB0aGlzLnNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzaW5rLmFkZCh0aGlzLl9zdWJzY3JpYmUoc2luaykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaW5rLnN5bmNFcnJvclRocm93YWJsZSkge1xuICAgICAgICAgICAgc2luay5zeW5jRXJyb3JUaHJvd2FibGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChzaW5rLnN5bmNFcnJvclRocm93bikge1xuICAgICAgICAgICAgICAgIHRocm93IHNpbmsuc3luY0Vycm9yVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpbms7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAbWV0aG9kIGZvckVhY2hcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXh0IGEgaGFuZGxlciBmb3IgZWFjaCB2YWx1ZSBlbWl0dGVkIGJ5IHRoZSBvYnNlcnZhYmxlXG4gICAgICogQHBhcmFtIHtQcm9taXNlQ29uc3RydWN0b3J9IFtQcm9taXNlQ3Rvcl0gYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiB1c2VkIHRvIGluc3RhbnRpYXRlIHRoZSBQcm9taXNlXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlIHRoYXQgZWl0aGVyIHJlc29sdmVzIG9uIG9ic2VydmFibGUgY29tcGxldGlvbiBvclxuICAgICAqICByZWplY3RzIHdpdGggdGhlIGhhbmRsZWQgZXJyb3JcbiAgICAgKi9cbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKG5leHQsIFByb21pc2VDdG9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghUHJvbWlzZUN0b3IpIHtcbiAgICAgICAgICAgIGlmIChyb290XzEucm9vdC5SeCAmJiByb290XzEucm9vdC5SeC5jb25maWcgJiYgcm9vdF8xLnJvb3QuUnguY29uZmlnLlByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBQcm9taXNlQ3RvciA9IHJvb3RfMS5yb290LlJ4LmNvbmZpZy5Qcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocm9vdF8xLnJvb3QuUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIFByb21pc2VDdG9yID0gcm9vdF8xLnJvb3QuUHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIVByb21pc2VDdG9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIFByb21pc2UgaW1wbCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZUN0b3IoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IF90aGlzLnN1YnNjcmliZShmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGEgc3Vic2NyaXB0aW9uLCB0aGVuIHdlIGNhbiBzdXJtaXNlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBuZXh0IGhhbmRsaW5nIGlzIGFzeW5jaHJvbm91cy4gQW55IGVycm9ycyB0aHJvd25cbiAgICAgICAgICAgICAgICAgICAgLy8gbmVlZCB0byBiZSByZWplY3RlZCBleHBsaWNpdGx5IGFuZCB1bnN1YnNjcmliZSBtdXN0IGJlXG4gICAgICAgICAgICAgICAgICAgIC8vIGNhbGxlZCBtYW51YWxseVxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgTk8gc3Vic2NyaXB0aW9uLCB0aGVuIHdlJ3JlIGdldHRpbmcgYSBuZXh0ZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gdmFsdWUgc3luY2hyb25vdXNseSBkdXJpbmcgc3Vic2NyaXB0aW9uLiBXZSBjYW4ganVzdCBjYWxsIGl0LlxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBpdCBlcnJvcnMsIE9ic2VydmFibGUncyBgc3Vic2NyaWJlYCB3aWxsIGVuc3VyZSB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gdW5zdWJzY3JpcHRpb24gbG9naWMgaXMgY2FsbGVkLCB0aGVuIHN5bmNocm9ub3VzbHkgcmV0aHJvdyB0aGUgZXJyb3IuXG4gICAgICAgICAgICAgICAgICAgIC8vIEFmdGVyIHRoYXQsIFByb21pc2Ugd2lsbCB0cmFwIHRoZSBlcnJvciBhbmQgc2VuZCBpdFxuICAgICAgICAgICAgICAgICAgICAvLyBkb3duIHRoZSByZWplY3Rpb24gcGF0aC5cbiAgICAgICAgICAgICAgICAgICAgbmV4dCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgcmVqZWN0LCByZXNvbHZlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFuIGludGVyb3AgcG9pbnQgZGVmaW5lZCBieSB0aGUgZXM3LW9ic2VydmFibGUgc3BlYyBodHRwczovL2dpdGh1Yi5jb20vemVucGFyc2luZy9lcy1vYnNlcnZhYmxlXG4gICAgICogQG1ldGhvZCBTeW1ib2wub2JzZXJ2YWJsZVxuICAgICAqIEByZXR1cm4ge09ic2VydmFibGV9IHRoaXMgaW5zdGFuY2Ugb2YgdGhlIG9ic2VydmFibGVcbiAgICAgKi9cbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZVtvYnNlcnZhYmxlXzEuJCRvYnNlcnZhYmxlXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvLyBIQUNLOiBTaW5jZSBUeXBlU2NyaXB0IGluaGVyaXRzIHN0YXRpYyBwcm9wZXJ0aWVzIHRvbywgd2UgaGF2ZSB0b1xuICAgIC8vIGZpZ2h0IGFnYWluc3QgVHlwZVNjcmlwdCBoZXJlIHNvIFN1YmplY3QgY2FuIGhhdmUgYSBkaWZmZXJlbnQgc3RhdGljIGNyZWF0ZSBzaWduYXR1cmVcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGNvbGQgT2JzZXJ2YWJsZSBieSBjYWxsaW5nIHRoZSBPYnNlcnZhYmxlIGNvbnN0cnVjdG9yXG4gICAgICogQHN0YXRpYyB0cnVlXG4gICAgICogQG93bmVyIE9ic2VydmFibGVcbiAgICAgKiBAbWV0aG9kIGNyZWF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN1YnNjcmliZT8gdGhlIHN1YnNjcmliZXIgZnVuY3Rpb24gdG8gYmUgcGFzc2VkIHRvIHRoZSBPYnNlcnZhYmxlIGNvbnN0cnVjdG9yXG4gICAgICogQHJldHVybiB7T2JzZXJ2YWJsZX0gYSBuZXcgY29sZCBvYnNlcnZhYmxlXG4gICAgICovXG4gICAgT2JzZXJ2YWJsZS5jcmVhdGUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlKSB7XG4gICAgICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZShzdWJzY3JpYmUpO1xuICAgIH07XG4gICAgcmV0dXJuIE9ic2VydmFibGU7XG59KCkpO1xuZXhwb3J0cy5PYnNlcnZhYmxlID0gT2JzZXJ2YWJsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9ic2VydmFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmVtcHR5ID0ge1xuICAgIGNsb3NlZDogdHJ1ZSxcbiAgICBuZXh0OiBmdW5jdGlvbiAodmFsdWUpIHsgfSxcbiAgICBlcnJvcjogZnVuY3Rpb24gKGVycikgeyB0aHJvdyBlcnI7IH0sXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uICgpIHsgfVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9ic2VydmVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9PYnNlcnZhYmxlJyk7XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi9TdWJzY3JpYmVyJyk7XG52YXIgU3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKCcuL1N1YnNjcmlwdGlvbicpO1xudmFyIE9iamVjdFVuc3Vic2NyaWJlZEVycm9yXzEgPSByZXF1aXJlKCcuL3V0aWwvT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3InKTtcbnZhciBTdWJqZWN0U3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKCcuL1N1YmplY3RTdWJzY3JpcHRpb24nKTtcbnZhciByeFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4vc3ltYm9sL3J4U3Vic2NyaWJlcicpO1xuLyoqXG4gKiBAY2xhc3MgU3ViamVjdFN1YnNjcmliZXI8VD5cbiAqL1xudmFyIFN1YmplY3RTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3ViamVjdFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3ViamVjdFN1YnNjcmliZXIoZGVzdGluYXRpb24pIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gZGVzdGluYXRpb247XG4gICAgfVxuICAgIHJldHVybiBTdWJqZWN0U3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbmV4cG9ydHMuU3ViamVjdFN1YnNjcmliZXIgPSBTdWJqZWN0U3Vic2NyaWJlcjtcbi8qKlxuICogQGNsYXNzIFN1YmplY3Q8VD5cbiAqL1xudmFyIFN1YmplY3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdWJqZWN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN1YmplY3QoKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLm9ic2VydmVycyA9IFtdO1xuICAgICAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhhc0Vycm9yID0gZmFsc2U7XG4gICAgICAgIHRoaXMudGhyb3duRXJyb3IgPSBudWxsO1xuICAgIH1cbiAgICBTdWJqZWN0LnByb3RvdHlwZVtyeFN1YnNjcmliZXJfMS4kJHJ4U3Vic2NyaWJlcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3ViamVjdFN1YnNjcmliZXIodGhpcyk7XG4gICAgfTtcbiAgICBTdWJqZWN0LnByb3RvdHlwZS5saWZ0ID0gZnVuY3Rpb24gKG9wZXJhdG9yKSB7XG4gICAgICAgIHZhciBzdWJqZWN0ID0gbmV3IEFub255bW91c1N1YmplY3QodGhpcywgdGhpcyk7XG4gICAgICAgIHN1YmplY3Qub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgICAgcmV0dXJuIHN1YmplY3Q7XG4gICAgfTtcbiAgICBTdWJqZWN0LnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9iamVjdFVuc3Vic2NyaWJlZEVycm9yXzEuT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICB2YXIgb2JzZXJ2ZXJzID0gdGhpcy5vYnNlcnZlcnM7XG4gICAgICAgICAgICB2YXIgbGVuID0gb2JzZXJ2ZXJzLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBjb3B5ID0gb2JzZXJ2ZXJzLnNsaWNlKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29weVtpXS5uZXh0KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU3ViamVjdC5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9iamVjdFVuc3Vic2NyaWJlZEVycm9yXzEuT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgdGhpcy50aHJvd25FcnJvciA9IGVycjtcbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICB2YXIgb2JzZXJ2ZXJzID0gdGhpcy5vYnNlcnZlcnM7XG4gICAgICAgIHZhciBsZW4gPSBvYnNlcnZlcnMubGVuZ3RoO1xuICAgICAgICB2YXIgY29weSA9IG9ic2VydmVycy5zbGljZSgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb3B5W2ldLmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vYnNlcnZlcnMubGVuZ3RoID0gMDtcbiAgICB9O1xuICAgIFN1YmplY3QucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPYmplY3RVbnN1YnNjcmliZWRFcnJvcl8xLk9iamVjdFVuc3Vic2NyaWJlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICB2YXIgb2JzZXJ2ZXJzID0gdGhpcy5vYnNlcnZlcnM7XG4gICAgICAgIHZhciBsZW4gPSBvYnNlcnZlcnMubGVuZ3RoO1xuICAgICAgICB2YXIgY29weSA9IG9ic2VydmVycy5zbGljZSgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb3B5W2ldLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vYnNlcnZlcnMubGVuZ3RoID0gMDtcbiAgICB9O1xuICAgIFN1YmplY3QucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vYnNlcnZlcnMgPSBudWxsO1xuICAgIH07XG4gICAgU3ViamVjdC5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9iamVjdFVuc3Vic2NyaWJlZEVycm9yXzEuT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmhhc0Vycm9yKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmVycm9yKHRoaXMudGhyb3duRXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbi5FTVBUWTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbi5FTVBUWTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXJzLnB1c2goc3Vic2NyaWJlcik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN1YmplY3RTdWJzY3JpcHRpb25fMS5TdWJqZWN0U3Vic2NyaXB0aW9uKHRoaXMsIHN1YnNjcmliZXIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdWJqZWN0LnByb3RvdHlwZS5hc09ic2VydmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvYnNlcnZhYmxlID0gbmV3IE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKCk7XG4gICAgICAgIG9ic2VydmFibGUuc291cmNlID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGU7XG4gICAgfTtcbiAgICBTdWJqZWN0LmNyZWF0ZSA9IGZ1bmN0aW9uIChkZXN0aW5hdGlvbiwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBuZXcgQW5vbnltb3VzU3ViamVjdChkZXN0aW5hdGlvbiwgc291cmNlKTtcbiAgICB9O1xuICAgIHJldHVybiBTdWJqZWN0O1xufShPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkpO1xuZXhwb3J0cy5TdWJqZWN0ID0gU3ViamVjdDtcbi8qKlxuICogQGNsYXNzIEFub255bW91c1N1YmplY3Q8VD5cbiAqL1xudmFyIEFub255bW91c1N1YmplY3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBbm9ueW1vdXNTdWJqZWN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFub255bW91c1N1YmplY3QoZGVzdGluYXRpb24sIHNvdXJjZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IGRlc3RpbmF0aW9uO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB9XG4gICAgQW5vbnltb3VzU3ViamVjdC5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICBpZiAoZGVzdGluYXRpb24gJiYgZGVzdGluYXRpb24ubmV4dCkge1xuICAgICAgICAgICAgZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFub255bW91c1N1YmplY3QucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICBpZiAoZGVzdGluYXRpb24gJiYgZGVzdGluYXRpb24uZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQW5vbnltb3VzU3ViamVjdC5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICAgIGlmIChkZXN0aW5hdGlvbiAmJiBkZXN0aW5hdGlvbi5jb21wbGV0ZSkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBbm9ueW1vdXNTdWJqZWN0LnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuc291cmNlO1xuICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbi5FTVBUWTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEFub255bW91c1N1YmplY3Q7XG59KFN1YmplY3QpKTtcbmV4cG9ydHMuQW5vbnltb3VzU3ViamVjdCA9IEFub255bW91c1N1YmplY3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdWJqZWN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKCcuL1N1YnNjcmlwdGlvbicpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBTdWJqZWN0U3Vic2NyaXB0aW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3ViamVjdFN1YnNjcmlwdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdWJqZWN0U3Vic2NyaXB0aW9uKHN1YmplY3QsIHN1YnNjcmliZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuc3ViamVjdCA9IHN1YmplY3Q7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlciA9IHN1YnNjcmliZXI7XG4gICAgICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgfVxuICAgIFN1YmplY3RTdWJzY3JpcHRpb24ucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG4gICAgICAgIHZhciBzdWJqZWN0ID0gdGhpcy5zdWJqZWN0O1xuICAgICAgICB2YXIgb2JzZXJ2ZXJzID0gc3ViamVjdC5vYnNlcnZlcnM7XG4gICAgICAgIHRoaXMuc3ViamVjdCA9IG51bGw7XG4gICAgICAgIGlmICghb2JzZXJ2ZXJzIHx8IG9ic2VydmVycy5sZW5ndGggPT09IDAgfHwgc3ViamVjdC5pc1N0b3BwZWQgfHwgc3ViamVjdC5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3Vic2NyaWJlckluZGV4ID0gb2JzZXJ2ZXJzLmluZGV4T2YodGhpcy5zdWJzY3JpYmVyKTtcbiAgICAgICAgaWYgKHN1YnNjcmliZXJJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIG9ic2VydmVycy5zcGxpY2Uoc3Vic2NyaWJlckluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFN1YmplY3RTdWJzY3JpcHRpb247XG59KFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbikpO1xuZXhwb3J0cy5TdWJqZWN0U3Vic2NyaXB0aW9uID0gU3ViamVjdFN1YnNjcmlwdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN1YmplY3RTdWJzY3JpcHRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBpc0Z1bmN0aW9uXzEgPSByZXF1aXJlKCcuL3V0aWwvaXNGdW5jdGlvbicpO1xudmFyIFN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZSgnLi9TdWJzY3JpcHRpb24nKTtcbnZhciBPYnNlcnZlcl8xID0gcmVxdWlyZSgnLi9PYnNlcnZlcicpO1xudmFyIHJ4U3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi9zeW1ib2wvcnhTdWJzY3JpYmVyJyk7XG4vKipcbiAqIEltcGxlbWVudHMgdGhlIHtAbGluayBPYnNlcnZlcn0gaW50ZXJmYWNlIGFuZCBleHRlbmRzIHRoZVxuICoge0BsaW5rIFN1YnNjcmlwdGlvbn0gY2xhc3MuIFdoaWxlIHRoZSB7QGxpbmsgT2JzZXJ2ZXJ9IGlzIHRoZSBwdWJsaWMgQVBJIGZvclxuICogY29uc3VtaW5nIHRoZSB2YWx1ZXMgb2YgYW4ge0BsaW5rIE9ic2VydmFibGV9LCBhbGwgT2JzZXJ2ZXJzIGdldCBjb252ZXJ0ZWQgdG9cbiAqIGEgU3Vic2NyaWJlciwgaW4gb3JkZXIgdG8gcHJvdmlkZSBTdWJzY3JpcHRpb24tbGlrZSBjYXBhYmlsaXRpZXMgc3VjaCBhc1xuICogYHVuc3Vic2NyaWJlYC4gU3Vic2NyaWJlciBpcyBhIGNvbW1vbiB0eXBlIGluIFJ4SlMsIGFuZCBjcnVjaWFsIGZvclxuICogaW1wbGVtZW50aW5nIG9wZXJhdG9ycywgYnV0IGl0IGlzIHJhcmVseSB1c2VkIGFzIGEgcHVibGljIEFQSS5cbiAqXG4gKiBAY2xhc3MgU3Vic2NyaWJlcjxUPlxuICovXG52YXIgU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYnNlcnZlcnxmdW5jdGlvbih2YWx1ZTogVCk6IHZvaWR9IFtkZXN0aW5hdGlvbk9yTmV4dF0gQSBwYXJ0aWFsbHlcbiAgICAgKiBkZWZpbmVkIE9ic2VydmVyIG9yIGEgYG5leHRgIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oZTogP2FueSk6IHZvaWR9IFtlcnJvcl0gVGhlIGBlcnJvcmAgY2FsbGJhY2sgb2YgYW5cbiAgICAgKiBPYnNlcnZlci5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IHZvaWR9IFtjb21wbGV0ZV0gVGhlIGBjb21wbGV0ZWAgY2FsbGJhY2sgb2YgYW5cbiAgICAgKiBPYnNlcnZlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTdWJzY3JpYmVyKGRlc3RpbmF0aW9uT3JOZXh0LCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuc3luY0Vycm9yVmFsdWUgPSBudWxsO1xuICAgICAgICB0aGlzLnN5bmNFcnJvclRocm93biA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN5bmNFcnJvclRocm93YWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gT2JzZXJ2ZXJfMS5lbXB0eTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBpZiAoIWRlc3RpbmF0aW9uT3JOZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBPYnNlcnZlcl8xLmVtcHR5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkZXN0aW5hdGlvbk9yTmV4dCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlc3RpbmF0aW9uT3JOZXh0IGluc3RhbmNlb2YgU3Vic2NyaWJlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IGRlc3RpbmF0aW9uT3JOZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5hZGQodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN5bmNFcnJvclRocm93YWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gbmV3IFNhZmVTdWJzY3JpYmVyKHRoaXMsIGRlc3RpbmF0aW9uT3JOZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRoaXMuc3luY0Vycm9yVGhyb3dhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gbmV3IFNhZmVTdWJzY3JpYmVyKHRoaXMsIGRlc3RpbmF0aW9uT3JOZXh0LCBlcnJvciwgY29tcGxldGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIFN1YnNjcmliZXIucHJvdG90eXBlW3J4U3Vic2NyaWJlcl8xLiQkcnhTdWJzY3JpYmVyXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG4gICAgLyoqXG4gICAgICogQSBzdGF0aWMgZmFjdG9yeSBmb3IgYSBTdWJzY3JpYmVyLCBnaXZlbiBhIChwb3RlbnRpYWxseSBwYXJ0aWFsKSBkZWZpbml0aW9uXG4gICAgICogb2YgYW4gT2JzZXJ2ZXIuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbih4OiA/VCk6IHZvaWR9IFtuZXh0XSBUaGUgYG5leHRgIGNhbGxiYWNrIG9mIGFuIE9ic2VydmVyLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oZTogP2FueSk6IHZvaWR9IFtlcnJvcl0gVGhlIGBlcnJvcmAgY2FsbGJhY2sgb2YgYW5cbiAgICAgKiBPYnNlcnZlci5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IHZvaWR9IFtjb21wbGV0ZV0gVGhlIGBjb21wbGV0ZWAgY2FsbGJhY2sgb2YgYW5cbiAgICAgKiBPYnNlcnZlci5cbiAgICAgKiBAcmV0dXJuIHtTdWJzY3JpYmVyPFQ+fSBBIFN1YnNjcmliZXIgd3JhcHBpbmcgdGhlIChwYXJ0aWFsbHkgZGVmaW5lZClcbiAgICAgKiBPYnNlcnZlciByZXByZXNlbnRlZCBieSB0aGUgZ2l2ZW4gYXJndW1lbnRzLlxuICAgICAqL1xuICAgIFN1YnNjcmliZXIuY3JlYXRlID0gZnVuY3Rpb24gKG5leHQsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgICAgICB2YXIgc3Vic2NyaWJlciA9IG5ldyBTdWJzY3JpYmVyKG5leHQsIGVycm9yLCBjb21wbGV0ZSk7XG4gICAgICAgIHN1YnNjcmliZXIuc3luY0Vycm9yVGhyb3dhYmxlID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBzdWJzY3JpYmVyO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhlIHtAbGluayBPYnNlcnZlcn0gY2FsbGJhY2sgdG8gcmVjZWl2ZSBub3RpZmljYXRpb25zIG9mIHR5cGUgYG5leHRgIGZyb21cbiAgICAgKiB0aGUgT2JzZXJ2YWJsZSwgd2l0aCBhIHZhbHVlLiBUaGUgT2JzZXJ2YWJsZSBtYXkgY2FsbCB0aGlzIG1ldGhvZCAwIG9yIG1vcmVcbiAgICAgKiB0aW1lcy5cbiAgICAgKiBAcGFyYW0ge1R9IFt2YWx1ZV0gVGhlIGBuZXh0YCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgdGhpcy5fbmV4dCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZSB7QGxpbmsgT2JzZXJ2ZXJ9IGNhbGxiYWNrIHRvIHJlY2VpdmUgbm90aWZpY2F0aW9ucyBvZiB0eXBlIGBlcnJvcmAgZnJvbVxuICAgICAqIHRoZSBPYnNlcnZhYmxlLCB3aXRoIGFuIGF0dGFjaGVkIHtAbGluayBFcnJvcn0uIE5vdGlmaWVzIHRoZSBPYnNlcnZlciB0aGF0XG4gICAgICogdGhlIE9ic2VydmFibGUgaGFzIGV4cGVyaWVuY2VkIGFuIGVycm9yIGNvbmRpdGlvbi5cbiAgICAgKiBAcGFyYW0ge2FueX0gW2Vycl0gVGhlIGBlcnJvcmAgZXhjZXB0aW9uLlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZSB7QGxpbmsgT2JzZXJ2ZXJ9IGNhbGxiYWNrIHRvIHJlY2VpdmUgYSB2YWx1ZWxlc3Mgbm90aWZpY2F0aW9uIG9mIHR5cGVcbiAgICAgKiBgY29tcGxldGVgIGZyb20gdGhlIE9ic2VydmFibGUuIE5vdGlmaWVzIHRoZSBPYnNlcnZlciB0aGF0IHRoZSBPYnNlcnZhYmxlXG4gICAgICogaGFzIGZpbmlzaGVkIHNlbmRpbmcgcHVzaC1iYXNlZCBub3RpZmljYXRpb25zLlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2NvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudW5zdWJzY3JpYmUuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gICAgfTtcbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICAgIHJldHVybiBTdWJzY3JpYmVyO1xufShTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24pKTtcbmV4cG9ydHMuU3Vic2NyaWJlciA9IFN1YnNjcmliZXI7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFNhZmVTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2FmZVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2FmZVN1YnNjcmliZXIoX3BhcmVudCwgb2JzZXJ2ZXJPck5leHQsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gX3BhcmVudDtcbiAgICAgICAgdmFyIG5leHQ7XG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgICAgaWYgKGlzRnVuY3Rpb25fMS5pc0Z1bmN0aW9uKG9ic2VydmVyT3JOZXh0KSkge1xuICAgICAgICAgICAgbmV4dCA9IG9ic2VydmVyT3JOZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9ic2VydmVyT3JOZXh0KSB7XG4gICAgICAgICAgICBjb250ZXh0ID0gb2JzZXJ2ZXJPck5leHQ7XG4gICAgICAgICAgICBuZXh0ID0gb2JzZXJ2ZXJPck5leHQubmV4dDtcbiAgICAgICAgICAgIGVycm9yID0gb2JzZXJ2ZXJPck5leHQuZXJyb3I7XG4gICAgICAgICAgICBjb21wbGV0ZSA9IG9ic2VydmVyT3JOZXh0LmNvbXBsZXRlO1xuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb25fMS5pc0Z1bmN0aW9uKGNvbnRleHQudW5zdWJzY3JpYmUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGQoY29udGV4dC51bnN1YnNjcmliZS5iaW5kKGNvbnRleHQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRleHQudW5zdWJzY3JpYmUgPSB0aGlzLnVuc3Vic2NyaWJlLmJpbmQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuX25leHQgPSBuZXh0O1xuICAgICAgICB0aGlzLl9lcnJvciA9IGVycm9yO1xuICAgICAgICB0aGlzLl9jb21wbGV0ZSA9IGNvbXBsZXRlO1xuICAgIH1cbiAgICBTYWZlU3Vic2NyaWJlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkICYmIHRoaXMuX25leHQpIHtcbiAgICAgICAgICAgIHZhciBfcGFyZW50ID0gdGhpcy5fcGFyZW50O1xuICAgICAgICAgICAgaWYgKCFfcGFyZW50LnN5bmNFcnJvclRocm93YWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX190cnlPclVuc3ViKHRoaXMuX25leHQsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX190cnlPclNldEVycm9yKF9wYXJlbnQsIHRoaXMuX25leHQsIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU2FmZVN1YnNjcmliZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICB2YXIgX3BhcmVudCA9IHRoaXMuX3BhcmVudDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9lcnJvcikge1xuICAgICAgICAgICAgICAgIGlmICghX3BhcmVudC5zeW5jRXJyb3JUaHJvd2FibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3RyeU9yVW5zdWIodGhpcy5fZXJyb3IsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX190cnlPclNldEVycm9yKF9wYXJlbnQsIHRoaXMuX2Vycm9yLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9wYXJlbnQuc3luY0Vycm9yVGhyb3dhYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF9wYXJlbnQuc3luY0Vycm9yVmFsdWUgPSBlcnI7XG4gICAgICAgICAgICAgICAgX3BhcmVudC5zeW5jRXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU2FmZVN1YnNjcmliZXIucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICB2YXIgX3BhcmVudCA9IHRoaXMuX3BhcmVudDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIGlmICghX3BhcmVudC5zeW5jRXJyb3JUaHJvd2FibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3RyeU9yVW5zdWIodGhpcy5fY29tcGxldGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fdHJ5T3JTZXRFcnJvcihfcGFyZW50LCB0aGlzLl9jb21wbGV0ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNhZmVTdWJzY3JpYmVyLnByb3RvdHlwZS5fX3RyeU9yVW5zdWIgPSBmdW5jdGlvbiAoZm4sIHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmbi5jYWxsKHRoaXMuX2NvbnRleHQsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNhZmVTdWJzY3JpYmVyLnByb3RvdHlwZS5fX3RyeU9yU2V0RXJyb3IgPSBmdW5jdGlvbiAocGFyZW50LCBmbiwgdmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZuLmNhbGwodGhpcy5fY29udGV4dCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHBhcmVudC5zeW5jRXJyb3JWYWx1ZSA9IGVycjtcbiAgICAgICAgICAgIHBhcmVudC5zeW5jRXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgU2FmZVN1YnNjcmliZXIucHJvdG90eXBlLl91bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9wYXJlbnQgPSB0aGlzLl9wYXJlbnQ7XG4gICAgICAgIHRoaXMuX2NvbnRleHQgPSBudWxsO1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBudWxsO1xuICAgICAgICBfcGFyZW50LnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gU2FmZVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN1YnNjcmliZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBpc0FycmF5XzEgPSByZXF1aXJlKCcuL3V0aWwvaXNBcnJheScpO1xudmFyIGlzT2JqZWN0XzEgPSByZXF1aXJlKCcuL3V0aWwvaXNPYmplY3QnKTtcbnZhciBpc0Z1bmN0aW9uXzEgPSByZXF1aXJlKCcuL3V0aWwvaXNGdW5jdGlvbicpO1xudmFyIHRyeUNhdGNoXzEgPSByZXF1aXJlKCcuL3V0aWwvdHJ5Q2F0Y2gnKTtcbnZhciBlcnJvck9iamVjdF8xID0gcmVxdWlyZSgnLi91dGlsL2Vycm9yT2JqZWN0Jyk7XG52YXIgVW5zdWJzY3JpcHRpb25FcnJvcl8xID0gcmVxdWlyZSgnLi91dGlsL1Vuc3Vic2NyaXB0aW9uRXJyb3InKTtcbi8qKlxuICogUmVwcmVzZW50cyBhIGRpc3Bvc2FibGUgcmVzb3VyY2UsIHN1Y2ggYXMgdGhlIGV4ZWN1dGlvbiBvZiBhbiBPYnNlcnZhYmxlLiBBXG4gKiBTdWJzY3JpcHRpb24gaGFzIG9uZSBpbXBvcnRhbnQgbWV0aG9kLCBgdW5zdWJzY3JpYmVgLCB0aGF0IHRha2VzIG5vIGFyZ3VtZW50XG4gKiBhbmQganVzdCBkaXNwb3NlcyB0aGUgcmVzb3VyY2UgaGVsZCBieSB0aGUgc3Vic2NyaXB0aW9uLlxuICpcbiAqIEFkZGl0aW9uYWxseSwgc3Vic2NyaXB0aW9ucyBtYXkgYmUgZ3JvdXBlZCB0b2dldGhlciB0aHJvdWdoIHRoZSBgYWRkKClgXG4gKiBtZXRob2QsIHdoaWNoIHdpbGwgYXR0YWNoIGEgY2hpbGQgU3Vic2NyaXB0aW9uIHRvIHRoZSBjdXJyZW50IFN1YnNjcmlwdGlvbi5cbiAqIFdoZW4gYSBTdWJzY3JpcHRpb24gaXMgdW5zdWJzY3JpYmVkLCBhbGwgaXRzIGNoaWxkcmVuIChhbmQgaXRzIGdyYW5kY2hpbGRyZW4pXG4gKiB3aWxsIGJlIHVuc3Vic2NyaWJlZCBhcyB3ZWxsLlxuICpcbiAqIEBjbGFzcyBTdWJzY3JpcHRpb25cbiAqL1xudmFyIFN1YnNjcmlwdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbigpOiB2b2lkfSBbdW5zdWJzY3JpYmVdIEEgZnVuY3Rpb24gZGVzY3JpYmluZyBob3cgdG9cbiAgICAgKiBwZXJmb3JtIHRoZSBkaXNwb3NhbCBvZiByZXNvdXJjZXMgd2hlbiB0aGUgYHVuc3Vic2NyaWJlYCBtZXRob2QgaXMgY2FsbGVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFN1YnNjcmlwdGlvbih1bnN1YnNjcmliZSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgdGhpcyBTdWJzY3JpcHRpb24gaGFzIGFscmVhZHkgYmVlbiB1bnN1YnNjcmliZWQuXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHVuc3Vic2NyaWJlKSB7XG4gICAgICAgICAgICB0aGlzLl91bnN1YnNjcmliZSA9IHVuc3Vic2NyaWJlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc3Bvc2VzIHRoZSByZXNvdXJjZXMgaGVsZCBieSB0aGUgc3Vic2NyaXB0aW9uLiBNYXksIGZvciBpbnN0YW5jZSwgY2FuY2VsXG4gICAgICogYW4gb25nb2luZyBPYnNlcnZhYmxlIGV4ZWN1dGlvbiBvciBjYW5jZWwgYW55IG90aGVyIHR5cGUgb2Ygd29yayB0aGF0XG4gICAgICogc3RhcnRlZCB3aGVuIHRoZSBTdWJzY3JpcHRpb24gd2FzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKi9cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaGFzRXJyb3JzID0gZmFsc2U7XG4gICAgICAgIHZhciBlcnJvcnM7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgX3Vuc3Vic2NyaWJlID0gX2EuX3Vuc3Vic2NyaWJlLCBfc3Vic2NyaXB0aW9ucyA9IF9hLl9zdWJzY3JpcHRpb25zO1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zID0gbnVsbDtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb25fMS5pc0Z1bmN0aW9uKF91bnN1YnNjcmliZSkpIHtcbiAgICAgICAgICAgIHZhciB0cmlhbCA9IHRyeUNhdGNoXzEudHJ5Q2F0Y2goX3Vuc3Vic2NyaWJlKS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgaWYgKHRyaWFsID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgaGFzRXJyb3JzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBlcnJvcnMgPSBlcnJvcnMgfHwgKGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QuZSBpbnN0YW5jZW9mIFVuc3Vic2NyaXB0aW9uRXJyb3JfMS5VbnN1YnNjcmlwdGlvbkVycm9yID9cbiAgICAgICAgICAgICAgICAgICAgZmxhdHRlblVuc3Vic2NyaXB0aW9uRXJyb3JzKGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QuZS5lcnJvcnMpIDogW2Vycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QuZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FycmF5XzEuaXNBcnJheShfc3Vic2NyaXB0aW9ucykpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgICAgICAgdmFyIGxlbiA9IF9zdWJzY3JpcHRpb25zLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1YiA9IF9zdWJzY3JpcHRpb25zW2luZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3RfMS5pc09iamVjdChzdWIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmlhbCA9IHRyeUNhdGNoXzEudHJ5Q2F0Y2goc3ViLnVuc3Vic2NyaWJlKS5jYWxsKHN1Yik7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmlhbCA9PT0gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzRXJyb3JzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycyA9IGVycm9ycyB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnIgPSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgVW5zdWJzY3JpcHRpb25FcnJvcl8xLlVuc3Vic2NyaXB0aW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KGZsYXR0ZW5VbnN1YnNjcmlwdGlvbkVycm9ycyhlcnIuZXJyb3JzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNFcnJvcnMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBVbnN1YnNjcmlwdGlvbkVycm9yXzEuVW5zdWJzY3JpcHRpb25FcnJvcihlcnJvcnMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGRzIGEgdGVhciBkb3duIHRvIGJlIGNhbGxlZCBkdXJpbmcgdGhlIHVuc3Vic2NyaWJlKCkgb2YgdGhpc1xuICAgICAqIFN1YnNjcmlwdGlvbi5cbiAgICAgKlxuICAgICAqIElmIHRoZSB0ZWFyIGRvd24gYmVpbmcgYWRkZWQgaXMgYSBzdWJzY3JpcHRpb24gdGhhdCBpcyBhbHJlYWR5XG4gICAgICogdW5zdWJzY3JpYmVkLCBpcyB0aGUgc2FtZSByZWZlcmVuY2UgYGFkZGAgaXMgYmVpbmcgY2FsbGVkIG9uLCBvciBpc1xuICAgICAqIGBTdWJzY3JpcHRpb24uRU1QVFlgLCBpdCB3aWxsIG5vdCBiZSBhZGRlZC5cbiAgICAgKlxuICAgICAqIElmIHRoaXMgc3Vic2NyaXB0aW9uIGlzIGFscmVhZHkgaW4gYW4gYGNsb3NlZGAgc3RhdGUsIHRoZSBwYXNzZWRcbiAgICAgKiB0ZWFyIGRvd24gbG9naWMgd2lsbCBiZSBleGVjdXRlZCBpbW1lZGlhdGVseS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7VGVhcmRvd25Mb2dpY30gdGVhcmRvd24gVGhlIGFkZGl0aW9uYWwgbG9naWMgdG8gZXhlY3V0ZSBvblxuICAgICAqIHRlYXJkb3duLlxuICAgICAqIEByZXR1cm4ge1N1YnNjcmlwdGlvbn0gUmV0dXJucyB0aGUgU3Vic2NyaXB0aW9uIHVzZWQgb3IgY3JlYXRlZCB0byBiZVxuICAgICAqIGFkZGVkIHRvIHRoZSBpbm5lciBzdWJzY3JpcHRpb25zIGxpc3QuIFRoaXMgU3Vic2NyaXB0aW9uIGNhbiBiZSB1c2VkIHdpdGhcbiAgICAgKiBgcmVtb3ZlKClgIHRvIHJlbW92ZSB0aGUgcGFzc2VkIHRlYXJkb3duIGxvZ2ljIGZyb20gdGhlIGlubmVyIHN1YnNjcmlwdGlvbnNcbiAgICAgKiBsaXN0LlxuICAgICAqL1xuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHRlYXJkb3duKSB7XG4gICAgICAgIGlmICghdGVhcmRvd24gfHwgKHRlYXJkb3duID09PSBTdWJzY3JpcHRpb24uRU1QVFkpKSB7XG4gICAgICAgICAgICByZXR1cm4gU3Vic2NyaXB0aW9uLkVNUFRZO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0ZWFyZG93biA9PT0gdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN1YiA9IHRlYXJkb3duO1xuICAgICAgICBzd2l0Y2ggKHR5cGVvZiB0ZWFyZG93bikge1xuICAgICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgICAgIHN1YiA9IG5ldyBTdWJzY3JpcHRpb24odGVhcmRvd24pO1xuICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICBpZiAoc3ViLmNsb3NlZCB8fCB0eXBlb2Ygc3ViLnVuc3Vic2NyaWJlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3ViO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnJlY29nbml6ZWQgdGVhcmRvd24gJyArIHRlYXJkb3duICsgJyBhZGRlZCB0byBTdWJzY3JpcHRpb24uJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNoaWxkU3ViID0gbmV3IENoaWxkU3Vic2NyaXB0aW9uKHN1YiwgdGhpcyk7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMgPSB0aGlzLl9zdWJzY3JpcHRpb25zIHx8IFtdO1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zLnB1c2goY2hpbGRTdWIpO1xuICAgICAgICByZXR1cm4gY2hpbGRTdWI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgU3Vic2NyaXB0aW9uIGZyb20gdGhlIGludGVybmFsIGxpc3Qgb2Ygc3Vic2NyaXB0aW9ucyB0aGF0IHdpbGxcbiAgICAgKiB1bnN1YnNjcmliZSBkdXJpbmcgdGhlIHVuc3Vic2NyaWJlIHByb2Nlc3Mgb2YgdGhpcyBTdWJzY3JpcHRpb24uXG4gICAgICogQHBhcmFtIHtTdWJzY3JpcHRpb259IHN1YnNjcmlwdGlvbiBUaGUgc3Vic2NyaXB0aW9uIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKHN1YnNjcmlwdGlvbikge1xuICAgICAgICAvLyBIQUNLOiBUaGlzIG1pZ2h0IGJlIHJlZHVuZGFudCBiZWNhdXNlIG9mIHRoZSBsb2dpYyBpbiBgYWRkKClgXG4gICAgICAgIGlmIChzdWJzY3JpcHRpb24gPT0gbnVsbCB8fCAoc3Vic2NyaXB0aW9uID09PSB0aGlzKSB8fCAoc3Vic2NyaXB0aW9uID09PSBTdWJzY3JpcHRpb24uRU1QVFkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbnMgPSB0aGlzLl9zdWJzY3JpcHRpb25zO1xuICAgICAgICBpZiAoc3Vic2NyaXB0aW9ucykge1xuICAgICAgICAgICAgdmFyIHN1YnNjcmlwdGlvbkluZGV4ID0gc3Vic2NyaXB0aW9ucy5pbmRleE9mKHN1YnNjcmlwdGlvbik7XG4gICAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9ucy5zcGxpY2Uoc3Vic2NyaXB0aW9uSW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBTdWJzY3JpcHRpb24uRU1QVFkgPSAoZnVuY3Rpb24gKGVtcHR5KSB7XG4gICAgICAgIGVtcHR5LmNsb3NlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBlbXB0eTtcbiAgICB9KG5ldyBTdWJzY3JpcHRpb24oKSkpO1xuICAgIHJldHVybiBTdWJzY3JpcHRpb247XG59KCkpO1xuZXhwb3J0cy5TdWJzY3JpcHRpb24gPSBTdWJzY3JpcHRpb247XG52YXIgQ2hpbGRTdWJzY3JpcHRpb24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDaGlsZFN1YnNjcmlwdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDaGlsZFN1YnNjcmlwdGlvbihfaW5uZXJTdWIsIF9wYXJlbnQpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuX2lubmVyU3ViID0gX2lubmVyU3ViO1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBfcGFyZW50O1xuICAgIH1cbiAgICBDaGlsZFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuX3Vuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBfaW5uZXJTdWIgPSBfYS5faW5uZXJTdWIsIF9wYXJlbnQgPSBfYS5fcGFyZW50O1xuICAgICAgICBfcGFyZW50LnJlbW92ZSh0aGlzKTtcbiAgICAgICAgX2lubmVyU3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2hpbGRTdWJzY3JpcHRpb247XG59KFN1YnNjcmlwdGlvbikpO1xuZXhwb3J0cy5DaGlsZFN1YnNjcmlwdGlvbiA9IENoaWxkU3Vic2NyaXB0aW9uO1xuZnVuY3Rpb24gZmxhdHRlblVuc3Vic2NyaXB0aW9uRXJyb3JzKGVycm9ycykge1xuICAgIHJldHVybiBlcnJvcnMucmVkdWNlKGZ1bmN0aW9uIChlcnJzLCBlcnIpIHsgcmV0dXJuIGVycnMuY29uY2F0KChlcnIgaW5zdGFuY2VvZiBVbnN1YnNjcmlwdGlvbkVycm9yXzEuVW5zdWJzY3JpcHRpb25FcnJvcikgPyBlcnIuZXJyb3JzIDogZXJyKTsgfSwgW10pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3Vic2NyaXB0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIHJvb3RfMSA9IHJlcXVpcmUoJy4uL3V0aWwvcm9vdCcpO1xuZnVuY3Rpb24gZ2V0U3ltYm9sT2JzZXJ2YWJsZShjb250ZXh0KSB7XG4gICAgdmFyICQkb2JzZXJ2YWJsZTtcbiAgICB2YXIgU3ltYm9sID0gY29udGV4dC5TeW1ib2w7XG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKFN5bWJvbC5vYnNlcnZhYmxlKSB7XG4gICAgICAgICAgICAkJG9ic2VydmFibGUgPSBTeW1ib2wub2JzZXJ2YWJsZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICQkb2JzZXJ2YWJsZSA9IFN5bWJvbCgnb2JzZXJ2YWJsZScpO1xuICAgICAgICAgICAgU3ltYm9sLm9ic2VydmFibGUgPSAkJG9ic2VydmFibGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgICQkb2JzZXJ2YWJsZSA9ICdAQG9ic2VydmFibGUnO1xuICAgIH1cbiAgICByZXR1cm4gJCRvYnNlcnZhYmxlO1xufVxuZXhwb3J0cy5nZXRTeW1ib2xPYnNlcnZhYmxlID0gZ2V0U3ltYm9sT2JzZXJ2YWJsZTtcbmV4cG9ydHMuJCRvYnNlcnZhYmxlID0gZ2V0U3ltYm9sT2JzZXJ2YWJsZShyb290XzEucm9vdCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vYnNlcnZhYmxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIHJvb3RfMSA9IHJlcXVpcmUoJy4uL3V0aWwvcm9vdCcpO1xudmFyIFN5bWJvbCA9IHJvb3RfMS5yb290LlN5bWJvbDtcbmV4cG9ydHMuJCRyeFN1YnNjcmliZXIgPSAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sLmZvciA9PT0gJ2Z1bmN0aW9uJykgP1xuICAgIFN5bWJvbC5mb3IoJ3J4U3Vic2NyaWJlcicpIDogJ0BAcnhTdWJzY3JpYmVyJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJ4U3Vic2NyaWJlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xuLyoqXG4gKiBBbiBlcnJvciB0aHJvd24gd2hlbiBhbiBhY3Rpb24gaXMgaW52YWxpZCBiZWNhdXNlIHRoZSBvYmplY3QgaGFzIGJlZW5cbiAqIHVuc3Vic2NyaWJlZC5cbiAqXG4gKiBAc2VlIHtAbGluayBTdWJqZWN0fVxuICogQHNlZSB7QGxpbmsgQmVoYXZpb3JTdWJqZWN0fVxuICpcbiAqIEBjbGFzcyBPYmplY3RVbnN1YnNjcmliZWRFcnJvclxuICovXG52YXIgT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhPYmplY3RVbnN1YnNjcmliZWRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBPYmplY3RVbnN1YnNjcmliZWRFcnJvcigpIHtcbiAgICAgICAgdmFyIGVyciA9IF9zdXBlci5jYWxsKHRoaXMsICdvYmplY3QgdW5zdWJzY3JpYmVkJyk7XG4gICAgICAgIHRoaXMubmFtZSA9IGVyci5uYW1lID0gJ09iamVjdFVuc3Vic2NyaWJlZEVycm9yJztcbiAgICAgICAgdGhpcy5zdGFjayA9IGVyci5zdGFjaztcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gZXJyLm1lc3NhZ2U7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3RVbnN1YnNjcmliZWRFcnJvcjtcbn0oRXJyb3IpKTtcbmV4cG9ydHMuT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IgPSBPYmplY3RVbnN1YnNjcmliZWRFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9iamVjdFVuc3Vic2NyaWJlZEVycm9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG4vKipcbiAqIEFuIGVycm9yIHRocm93biB3aGVuIG9uZSBvciBtb3JlIGVycm9ycyBoYXZlIG9jY3VycmVkIGR1cmluZyB0aGVcbiAqIGB1bnN1YnNjcmliZWAgb2YgYSB7QGxpbmsgU3Vic2NyaXB0aW9ufS5cbiAqL1xudmFyIFVuc3Vic2NyaXB0aW9uRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhVbnN1YnNjcmlwdGlvbkVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFVuc3Vic2NyaXB0aW9uRXJyb3IoZXJyb3JzKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICAgICAgdmFyIGVyciA9IEVycm9yLmNhbGwodGhpcywgZXJyb3JzID9cbiAgICAgICAgICAgIGVycm9ycy5sZW5ndGggKyBcIiBlcnJvcnMgb2NjdXJyZWQgZHVyaW5nIHVuc3Vic2NyaXB0aW9uOlxcbiAgXCIgKyBlcnJvcnMubWFwKGZ1bmN0aW9uIChlcnIsIGkpIHsgcmV0dXJuICgoaSArIDEpICsgXCIpIFwiICsgZXJyLnRvU3RyaW5nKCkpOyB9KS5qb2luKCdcXG4gICcpIDogJycpO1xuICAgICAgICB0aGlzLm5hbWUgPSBlcnIubmFtZSA9ICdVbnN1YnNjcmlwdGlvbkVycm9yJztcbiAgICAgICAgdGhpcy5zdGFjayA9IGVyci5zdGFjaztcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gZXJyLm1lc3NhZ2U7XG4gICAgfVxuICAgIHJldHVybiBVbnN1YnNjcmlwdGlvbkVycm9yO1xufShFcnJvcikpO1xuZXhwb3J0cy5VbnN1YnNjcmlwdGlvbkVycm9yID0gVW5zdWJzY3JpcHRpb25FcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVVuc3Vic2NyaXB0aW9uRXJyb3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vLyB0eXBlb2YgYW55IHNvIHRoYXQgaXQgd2UgZG9uJ3QgaGF2ZSB0byBjYXN0IHdoZW4gY29tcGFyaW5nIGEgcmVzdWx0IHRvIHRoZSBlcnJvciBvYmplY3RcbmV4cG9ydHMuZXJyb3JPYmplY3QgPSB7IGU6IHt9IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvck9iamVjdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4ICYmIHR5cGVvZiB4Lmxlbmd0aCA9PT0gJ251bWJlcic7IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNBcnJheS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGlzRnVuY3Rpb24oeCkge1xuICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc0Z1bmN0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gaXNPYmplY3QoeCkge1xuICAgIHJldHVybiB4ICE9IG51bGwgJiYgdHlwZW9mIHggPT09ICdvYmplY3QnO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNPYmplY3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIHdpbmRvdzogYnJvd3NlciBpbiBET00gbWFpbiB0aHJlYWRcbiAqIHNlbGY6IGJyb3dzZXIgaW4gV2ViV29ya2VyXG4gKiBnbG9iYWw6IE5vZGUuanMvb3RoZXJcbiAqL1xuZXhwb3J0cy5yb290ID0gKHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93LndpbmRvdyA9PT0gd2luZG93ICYmIHdpbmRvd1xuICAgIHx8IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYuc2VsZiA9PT0gc2VsZiAmJiBzZWxmXG4gICAgfHwgdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwuZ2xvYmFsID09PSBnbG9iYWwgJiYgZ2xvYmFsKTtcbmlmICghZXhwb3J0cy5yb290KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSeEpTIGNvdWxkIG5vdCBmaW5kIGFueSBnbG9iYWwgY29udGV4dCAod2luZG93LCBzZWxmLCBnbG9iYWwpJyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb290LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbnZhciByeFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL3N5bWJvbC9yeFN1YnNjcmliZXInKTtcbnZhciBPYnNlcnZlcl8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2ZXInKTtcbmZ1bmN0aW9uIHRvU3Vic2NyaWJlcihuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgaWYgKG5leHRPck9ic2VydmVyKSB7XG4gICAgICAgIGlmIChuZXh0T3JPYnNlcnZlciBpbnN0YW5jZW9mIFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dE9yT2JzZXJ2ZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5leHRPck9ic2VydmVyW3J4U3Vic2NyaWJlcl8xLiQkcnhTdWJzY3JpYmVyXSkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHRPck9ic2VydmVyW3J4U3Vic2NyaWJlcl8xLiQkcnhTdWJzY3JpYmVyXSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghbmV4dE9yT2JzZXJ2ZXIgJiYgIWVycm9yICYmICFjb21wbGV0ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKE9ic2VydmVyXzEuZW1wdHkpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpO1xufVxuZXhwb3J0cy50b1N1YnNjcmliZXIgPSB0b1N1YnNjcmliZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10b1N1YnNjcmliZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgZXJyb3JPYmplY3RfMSA9IHJlcXVpcmUoJy4vZXJyb3JPYmplY3QnKTtcbnZhciB0cnlDYXRjaFRhcmdldDtcbmZ1bmN0aW9uIHRyeUNhdGNoZXIoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHRyeUNhdGNoVGFyZ2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QuZSA9IGU7XG4gICAgICAgIHJldHVybiBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRyeUNhdGNoKGZuKSB7XG4gICAgdHJ5Q2F0Y2hUYXJnZXQgPSBmbjtcbiAgICByZXR1cm4gdHJ5Q2F0Y2hlcjtcbn1cbmV4cG9ydHMudHJ5Q2F0Y2ggPSB0cnlDYXRjaDtcbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyeUNhdGNoLmpzLm1hcCIsImltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgc2VsZWN0b3I6ICdteS1hcHAnLFxyXG4gIHRlbXBsYXRlOiBgPGgxPkhlbGxvIHt7bmFtZX19PC9oMT5gXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQgeyBuYW1lID0gJ0FuZ3VsYXInOyB9Il19
